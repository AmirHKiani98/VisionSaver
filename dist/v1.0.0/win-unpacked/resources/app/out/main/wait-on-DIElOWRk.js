"use strict";
const require$$6 = require("fs");
const require$$1 = require("util");
const require$$0$1 = require("url");
const require$$4 = require("https");
const require$$4$2 = require("net");
const require$$0$2 = require("stream");
const require$$1$1 = require("path");
const require$$3 = require("http");
const require$$1$3 = require("crypto");
const require$$4$1 = require("assert");
const require$$1$2 = require("tty");
const require$$0$3 = require("os");
const require$$8 = require("zlib");
const require$$10 = require("events");
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var error = { exports: {} };
var stringify;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  stringify = function(...args2) {
    try {
      return JSON.stringify(...args2);
    } catch (err) {
      return "[Cannot display object: " + err.message + "]";
    }
  };
  return stringify;
}
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error.exports;
  hasRequiredError = 1;
  (function(module2, exports2) {
    const Stringify = requireStringify();
    module2.exports = class extends Error {
      constructor(args2) {
        const msgs = args2.filter((arg) => arg !== "").map((arg) => {
          return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
        });
        super(msgs.join(" ") || "Unknown error");
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, exports2.assert);
        }
      }
    };
  })(error, error.exports);
  return error.exports;
}
var assert;
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert) return assert;
  hasRequiredAssert = 1;
  const AssertError = requireError();
  assert = function(condition, ...args2) {
    if (condition) {
      return;
    }
    if (args2.length === 1 && args2[0] instanceof Error) {
      throw args2[0];
    }
    throw new AssertError(args2);
  };
  return assert;
}
var reach;
var hasRequiredReach;
function requireReach() {
  if (hasRequiredReach) return reach;
  hasRequiredReach = 1;
  const Assert = requireAssert();
  const internals = {};
  reach = function(obj, chain, options) {
    if (chain === false || chain === null || chain === void 0) {
      return obj;
    }
    options = options || {};
    if (typeof options === "string") {
      options = { separator: options };
    }
    const isChainArray = Array.isArray(chain);
    Assert(!isChainArray || !options.separator, "Separator option is not valid for array-based chain");
    const path = isChainArray ? chain : chain.split(options.separator || ".");
    let ref2 = obj;
    for (let i = 0; i < path.length; ++i) {
      let key = path[i];
      const type2 = options.iterables && internals.iterables(ref2);
      if (Array.isArray(ref2) || type2 === "set") {
        const number2 = Number(key);
        if (Number.isInteger(number2)) {
          key = number2 < 0 ? ref2.length + number2 : number2;
        }
      }
      if (!ref2 || typeof ref2 === "function" && options.functions === false || // Defaults to true
      !type2 && ref2[key] === void 0) {
        Assert(!options.strict || i + 1 === path.length, "Missing segment", key, "in reach path ", chain);
        Assert(typeof ref2 === "object" || options.functions === true || typeof ref2 !== "function", "Invalid segment", key, "in reach path ", chain);
        ref2 = options.default;
        break;
      }
      if (!type2) {
        ref2 = ref2[key];
      } else if (type2 === "set") {
        ref2 = [...ref2][key];
      } else {
        ref2 = ref2.get(key);
      }
    }
    return ref2;
  };
  internals.iterables = function(ref2) {
    if (ref2 instanceof Set) {
      return "set";
    }
    if (ref2 instanceof Map) {
      return "map";
    }
  };
  return reach;
}
var types$1 = { exports: {} };
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1.exports;
  hasRequiredTypes$1 = 1;
  (function(module2, exports2) {
    const internals = {};
    exports2 = module2.exports = {
      array: Array.prototype,
      buffer: Buffer && Buffer.prototype,
      // $lab:coverage:ignore$
      date: Date.prototype,
      error: Error.prototype,
      generic: Object.prototype,
      map: Map.prototype,
      promise: Promise.prototype,
      regex: RegExp.prototype,
      set: Set.prototype,
      weakMap: WeakMap.prototype,
      weakSet: WeakSet.prototype
    };
    internals.typeMap = /* @__PURE__ */ new Map([
      ["[object Error]", exports2.error],
      ["[object Map]", exports2.map],
      ["[object Promise]", exports2.promise],
      ["[object Set]", exports2.set],
      ["[object WeakMap]", exports2.weakMap],
      ["[object WeakSet]", exports2.weakSet]
    ]);
    exports2.getInternalProto = function(obj) {
      if (Array.isArray(obj)) {
        return exports2.array;
      }
      if (Buffer && obj instanceof Buffer) {
        return exports2.buffer;
      }
      if (obj instanceof Date) {
        return exports2.date;
      }
      if (obj instanceof RegExp) {
        return exports2.regex;
      }
      if (obj instanceof Error) {
        return exports2.error;
      }
      const objName = Object.prototype.toString.call(obj);
      return internals.typeMap.get(objName) || exports2.generic;
    };
  })(types$1, types$1.exports);
  return types$1.exports;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  utils.keys = function(obj, options = {}) {
    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
  };
  return utils;
}
var clone;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone;
  hasRequiredClone = 1;
  const Reach = requireReach();
  const Types = requireTypes$1();
  const Utils = requireUtils();
  const internals = {
    needsProtoHack: /* @__PURE__ */ new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
  };
  clone = internals.clone = function(obj, options = {}, _seen = null) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    let clone2 = internals.clone;
    let seen = _seen;
    if (options.shallow) {
      if (options.shallow !== true) {
        return internals.cloneWithShallow(obj, options);
      }
      clone2 = (value) => value;
    } else if (seen) {
      const lookup = seen.get(obj);
      if (lookup) {
        return lookup;
      }
    } else {
      seen = /* @__PURE__ */ new Map();
    }
    const baseProto = Types.getInternalProto(obj);
    if (baseProto === Types.buffer) {
      return Buffer && Buffer.from(obj);
    }
    if (baseProto === Types.date) {
      return new Date(obj.getTime());
    }
    if (baseProto === Types.regex) {
      return new RegExp(obj);
    }
    const newObj = internals.base(obj, baseProto, options);
    if (newObj === obj) {
      return obj;
    }
    if (seen) {
      seen.set(obj, newObj);
    }
    if (baseProto === Types.set) {
      for (const value of obj) {
        newObj.add(clone2(value, options, seen));
      }
    } else if (baseProto === Types.map) {
      for (const [key, value] of obj) {
        newObj.set(key, clone2(value, options, seen));
      }
    }
    const keys2 = Utils.keys(obj, options);
    for (const key of keys2) {
      if (key === "__proto__") {
        continue;
      }
      if (baseProto === Types.array && key === "length") {
        newObj.length = obj.length;
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj, key);
      if (descriptor) {
        if (descriptor.get || descriptor.set) {
          Object.defineProperty(newObj, key, descriptor);
        } else if (descriptor.enumerable) {
          newObj[key] = clone2(obj[key], options, seen);
        } else {
          Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone2(obj[key], options, seen) });
        }
      } else {
        Object.defineProperty(newObj, key, {
          enumerable: true,
          writable: true,
          configurable: true,
          value: clone2(obj[key], options, seen)
        });
      }
    }
    return newObj;
  };
  internals.cloneWithShallow = function(source, options) {
    const keys2 = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;
    const seen = /* @__PURE__ */ new Map();
    for (const key of keys2) {
      const ref2 = Reach(source, key);
      if (typeof ref2 === "object" || typeof ref2 === "function") {
        seen.set(ref2, ref2);
      }
    }
    return internals.clone(source, options, seen);
  };
  internals.base = function(obj, baseProto, options) {
    if (options.prototype === false) {
      if (internals.needsProtoHack.has(baseProto)) {
        return new baseProto.constructor();
      }
      return baseProto === Types.array ? [] : {};
    }
    const proto = Object.getPrototypeOf(obj);
    if (proto && proto.isImmutable) {
      return obj;
    }
    if (baseProto === Types.array) {
      const newObj = [];
      if (proto !== baseProto) {
        Object.setPrototypeOf(newObj, proto);
      }
      return newObj;
    }
    if (internals.needsProtoHack.has(baseProto)) {
      const newObj = new proto.constructor();
      if (proto !== baseProto) {
        Object.setPrototypeOf(newObj, proto);
      }
      return newObj;
    }
    return Object.create(proto);
  };
  return clone;
}
var cache = {};
var common$1 = {};
const version = "17.13.3";
const require$$2 = {
  version
};
var schemas = {};
var hasRequiredSchemas;
function requireSchemas() {
  if (hasRequiredSchemas) return schemas;
  hasRequiredSchemas = 1;
  const Joi = requireLib();
  const internals = {};
  internals.wrap = Joi.string().min(1).max(2).allow(false);
  schemas.preferences = Joi.object({
    allowUnknown: Joi.boolean(),
    abortEarly: Joi.boolean(),
    artifacts: Joi.boolean(),
    cache: Joi.boolean(),
    context: Joi.object(),
    convert: Joi.boolean(),
    dateFormat: Joi.valid("date", "iso", "string", "time", "utc"),
    debug: Joi.boolean(),
    errors: {
      escapeHtml: Joi.boolean(),
      label: Joi.valid("path", "key", false),
      language: [
        Joi.string(),
        Joi.object().ref()
      ],
      render: Joi.boolean(),
      stack: Joi.boolean(),
      wrap: {
        label: internals.wrap,
        array: internals.wrap,
        string: internals.wrap
      }
    },
    externals: Joi.boolean(),
    messages: Joi.object(),
    noDefaults: Joi.boolean(),
    nonEnumerables: Joi.boolean(),
    presence: Joi.valid("required", "optional", "forbidden"),
    skipFunctions: Joi.boolean(),
    stripUnknown: Joi.object({
      arrays: Joi.boolean(),
      objects: Joi.boolean()
    }).or("arrays", "objects").allow(true, false),
    warnings: Joi.boolean()
  }).strict();
  internals.nameRx = /^[a-zA-Z0-9]\w*$/;
  internals.rule = Joi.object({
    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),
    args: Joi.array().items(
      Joi.string(),
      Joi.object({
        name: Joi.string().pattern(internals.nameRx).required(),
        ref: Joi.boolean(),
        assert: Joi.alternatives([
          Joi.function(),
          Joi.object().schema()
        ]).conditional("ref", { is: true, then: Joi.required() }),
        normalize: Joi.function(),
        message: Joi.string().when("assert", { is: Joi.function(), then: Joi.required() })
      })
    ),
    convert: Joi.boolean(),
    manifest: Joi.boolean(),
    method: Joi.function().allow(false),
    multi: Joi.boolean(),
    validate: Joi.function()
  });
  schemas.extension = Joi.object({
    type: Joi.alternatives([
      Joi.string(),
      Joi.object().regex()
    ]).required(),
    args: Joi.function(),
    cast: Joi.object().pattern(internals.nameRx, Joi.object({
      from: Joi.function().maxArity(1).required(),
      to: Joi.function().minArity(1).maxArity(2).required()
    })),
    base: Joi.object().schema().when("type", { is: Joi.object().regex(), then: Joi.forbidden() }),
    coerce: [
      Joi.function().maxArity(3),
      Joi.object({ method: Joi.function().maxArity(3).required(), from: Joi.array().items(Joi.string()).single() })
    ],
    flags: Joi.object().pattern(internals.nameRx, Joi.object({
      setter: Joi.string(),
      default: Joi.any()
    })),
    manifest: {
      build: Joi.function().arity(2)
    },
    messages: [Joi.object(), Joi.string()],
    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),
    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),
    prepare: Joi.function().maxArity(3),
    rebuild: Joi.function().arity(1),
    rules: Joi.object().pattern(internals.nameRx, internals.rule),
    terms: Joi.object().pattern(internals.nameRx, Joi.object({
      init: Joi.array().allow(null).required(),
      manifest: Joi.object().pattern(/.+/, [
        Joi.valid("schema", "single"),
        Joi.object({
          mapped: Joi.object({
            from: Joi.string().required(),
            to: Joi.string().required()
          }).required()
        })
      ])
    })),
    validate: Joi.function().maxArity(3)
  }).strict();
  schemas.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();
  internals.desc = {
    buffer: Joi.object({
      buffer: Joi.string()
    }),
    func: Joi.object({
      function: Joi.function().required(),
      options: {
        literal: true
      }
    }),
    override: Joi.object({
      override: true
    }),
    ref: Joi.object({
      ref: Joi.object({
        type: Joi.valid("value", "global", "local"),
        path: Joi.array().required(),
        separator: Joi.string().length(1).allow(false),
        ancestor: Joi.number().min(0).integer().allow("root"),
        map: Joi.array().items(Joi.array().length(2)).min(1),
        adjust: Joi.function(),
        iterables: Joi.boolean(),
        in: Joi.boolean(),
        render: Joi.boolean()
      }).required()
    }),
    regex: Joi.object({
      regex: Joi.string().min(3)
    }),
    special: Joi.object({
      special: Joi.valid("deep").required()
    }),
    template: Joi.object({
      template: Joi.string().required(),
      options: Joi.object()
    }),
    value: Joi.object({
      value: Joi.alternatives([Joi.object(), Joi.array()]).required()
    })
  };
  internals.desc.entity = Joi.alternatives([
    Joi.array().items(Joi.link("...")),
    Joi.boolean(),
    Joi.function(),
    Joi.number(),
    Joi.string(),
    internals.desc.buffer,
    internals.desc.func,
    internals.desc.ref,
    internals.desc.regex,
    internals.desc.special,
    internals.desc.template,
    internals.desc.value,
    Joi.link("/")
  ]);
  internals.desc.values = Joi.array().items(
    null,
    Joi.boolean(),
    Joi.function(),
    Joi.number().allow(Infinity, -Infinity),
    Joi.string().allow(""),
    Joi.symbol(),
    internals.desc.buffer,
    internals.desc.func,
    internals.desc.override,
    internals.desc.ref,
    internals.desc.regex,
    internals.desc.template,
    internals.desc.value
  );
  internals.desc.messages = Joi.object().pattern(/.+/, [
    Joi.string(),
    internals.desc.template,
    Joi.object().pattern(/.+/, [Joi.string(), internals.desc.template])
  ]);
  schemas.description = Joi.object({
    type: Joi.string().required(),
    flags: Joi.object({
      cast: Joi.string(),
      default: Joi.any(),
      description: Joi.string(),
      empty: Joi.link("/"),
      failover: internals.desc.entity,
      id: Joi.string(),
      label: Joi.string(),
      only: true,
      presence: ["optional", "required", "forbidden"],
      result: ["raw", "strip"],
      strip: Joi.boolean(),
      unit: Joi.string()
    }).unknown(),
    preferences: {
      allowUnknown: Joi.boolean(),
      abortEarly: Joi.boolean(),
      artifacts: Joi.boolean(),
      cache: Joi.boolean(),
      convert: Joi.boolean(),
      dateFormat: ["date", "iso", "string", "time", "utc"],
      errors: {
        escapeHtml: Joi.boolean(),
        label: ["path", "key"],
        language: [
          Joi.string(),
          internals.desc.ref
        ],
        wrap: {
          label: internals.wrap,
          array: internals.wrap
        }
      },
      externals: Joi.boolean(),
      messages: internals.desc.messages,
      noDefaults: Joi.boolean(),
      nonEnumerables: Joi.boolean(),
      presence: ["required", "optional", "forbidden"],
      skipFunctions: Joi.boolean(),
      stripUnknown: Joi.object({
        arrays: Joi.boolean(),
        objects: Joi.boolean()
      }).or("arrays", "objects").allow(true, false),
      warnings: Joi.boolean()
    },
    allow: internals.desc.values,
    invalid: internals.desc.values,
    rules: Joi.array().min(1).items({
      name: Joi.string().required(),
      args: Joi.object().min(1),
      keep: Joi.boolean(),
      message: [
        Joi.string(),
        internals.desc.messages
      ],
      warn: Joi.boolean()
    }),
    // Terms
    keys: Joi.object().pattern(/.*/, Joi.link("/")),
    link: internals.desc.ref
  }).pattern(/^[a-z]\w*$/, Joi.any());
  return schemas;
}
var messages = {};
var template = { exports: {} };
var escapeHtml;
var hasRequiredEscapeHtml;
function requireEscapeHtml() {
  if (hasRequiredEscapeHtml) return escapeHtml;
  hasRequiredEscapeHtml = 1;
  const internals = {};
  escapeHtml = function(input) {
    if (!input) {
      return "";
    }
    let escaped = "";
    for (let i = 0; i < input.length; ++i) {
      const charCode = input.charCodeAt(i);
      if (internals.isSafe(charCode)) {
        escaped += input[i];
      } else {
        escaped += internals.escapeHtmlChar(charCode);
      }
    }
    return escaped;
  };
  internals.escapeHtmlChar = function(charCode) {
    const namedEscape = internals.namedHtml.get(charCode);
    if (namedEscape) {
      return namedEscape;
    }
    if (charCode >= 256) {
      return "&#" + charCode + ";";
    }
    const hexValue = charCode.toString(16).padStart(2, "0");
    return `&#x${hexValue};`;
  };
  internals.isSafe = function(charCode) {
    return internals.safeCharCodes.has(charCode);
  };
  internals.namedHtml = /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [34, "&quot;"],
    [160, "&nbsp;"],
    [162, "&cent;"],
    [163, "&pound;"],
    [164, "&curren;"],
    [169, "&copy;"],
    [174, "&reg;"]
  ]);
  internals.safeCharCodes = function() {
    const safe = /* @__PURE__ */ new Set();
    for (let i = 32; i < 123; ++i) {
      if (i >= 97 || // a-z
      i >= 65 && i <= 90 || // A-Z
      i >= 48 && i <= 57 || // 0-9
      i === 32 || // space
      i === 46 || // .
      i === 44 || // ,
      i === 45 || // -
      i === 58 || // :
      i === 95) {
        safe.add(i);
      }
    }
    return safe;
  }();
  return escapeHtml;
}
var lib$3 = {};
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$3;
  hasRequiredLib$3 = 1;
  (function(exports2) {
    const internals = {
      operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
      operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
      operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]],
      operatorsPrefix: ["!", "n"],
      literals: {
        '"': '"',
        "`": "`",
        "'": "'",
        "[": "]"
      },
      numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
      tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
      symbol: Symbol("formula"),
      settings: Symbol("settings")
    };
    exports2.Parser = class {
      constructor(string2, options = {}) {
        if (!options[internals.settings] && options.constants) {
          for (const constant in options.constants) {
            const value = options.constants[constant];
            if (value !== null && !["boolean", "number", "string"].includes(typeof value)) {
              throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
            }
          }
        }
        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
        this.single = null;
        this._parts = null;
        this._parse(string2);
      }
      _parse(string2) {
        let parts = [];
        let current = "";
        let parenthesis = 0;
        let literal = false;
        const flush = (inner) => {
          if (parenthesis) {
            throw new Error("Formula missing closing parenthesis");
          }
          const last2 = parts.length ? parts[parts.length - 1] : null;
          if (!literal && !current && !inner) {
            return;
          }
          if (last2 && last2.type === "reference" && inner === ")") {
            last2.type = "function";
            last2.value = this._subFormula(current, last2.value);
            current = "";
            return;
          }
          if (inner === ")") {
            const sub = new exports2.Parser(current, this.settings);
            parts.push({ type: "segment", value: sub });
          } else if (literal) {
            if (literal === "]") {
              parts.push({ type: "reference", value: current });
              current = "";
              return;
            }
            parts.push({ type: "literal", value: current });
          } else if (internals.operatorCharacters.includes(current)) {
            if (last2 && last2.type === "operator" && internals.operators.includes(last2.value + current)) {
              last2.value += current;
            } else {
              parts.push({ type: "operator", value: current });
            }
          } else if (current.match(internals.numberRx)) {
            parts.push({ type: "constant", value: parseFloat(current) });
          } else if (this.settings.constants[current] !== void 0) {
            parts.push({ type: "constant", value: this.settings.constants[current] });
          } else {
            if (!current.match(internals.tokenRx)) {
              throw new Error(`Formula contains invalid token: ${current}`);
            }
            parts.push({ type: "reference", value: current });
          }
          current = "";
        };
        for (const c of string2) {
          if (literal) {
            if (c === literal) {
              flush();
              literal = false;
            } else {
              current += c;
            }
          } else if (parenthesis) {
            if (c === "(") {
              current += c;
              ++parenthesis;
            } else if (c === ")") {
              --parenthesis;
              if (!parenthesis) {
                flush(c);
              } else {
                current += c;
              }
            } else {
              current += c;
            }
          } else if (c in internals.literals) {
            literal = internals.literals[c];
          } else if (c === "(") {
            flush();
            ++parenthesis;
          } else if (internals.operatorCharacters.includes(c)) {
            flush();
            current = c;
            flush();
          } else if (c !== " ") {
            current += c;
          } else {
            flush();
          }
        }
        flush();
        parts = parts.map((part, i) => {
          if (part.type !== "operator" || part.value !== "-" || i && parts[i - 1].type !== "operator") {
            return part;
          }
          return { type: "operator", value: "n" };
        });
        let operator = false;
        for (const part of parts) {
          if (part.type === "operator") {
            if (internals.operatorsPrefix.includes(part.value)) {
              continue;
            }
            if (!operator) {
              throw new Error("Formula contains an operator in invalid position");
            }
            if (!internals.operators.includes(part.value)) {
              throw new Error(`Formula contains an unknown operator ${part.value}`);
            }
          } else if (operator) {
            throw new Error("Formula missing expected operator");
          }
          operator = !operator;
        }
        if (!operator) {
          throw new Error("Formula contains invalid trailing operator");
        }
        if (parts.length === 1 && ["reference", "literal", "constant"].includes(parts[0].type)) {
          this.single = { type: parts[0].type === "reference" ? "reference" : "value", value: parts[0].value };
        }
        this._parts = parts.map((part) => {
          if (part.type === "operator") {
            return internals.operatorsPrefix.includes(part.value) ? part : part.value;
          }
          if (part.type !== "reference") {
            return part.value;
          }
          if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {
            throw new Error(`Formula contains invalid reference ${part.value}`);
          }
          if (this.settings.reference) {
            return this.settings.reference(part.value);
          }
          return internals.reference(part.value);
        });
      }
      _subFormula(string2, name) {
        const method = this.settings.functions[name];
        if (typeof method !== "function") {
          throw new Error(`Formula contains unknown function ${name}`);
        }
        let args2 = [];
        if (string2) {
          let current = "";
          let parenthesis = 0;
          let literal = false;
          const flush = () => {
            if (!current) {
              throw new Error(`Formula contains function ${name} with invalid arguments ${string2}`);
            }
            args2.push(current);
            current = "";
          };
          for (let i = 0; i < string2.length; ++i) {
            const c = string2[i];
            if (literal) {
              current += c;
              if (c === literal) {
                literal = false;
              }
            } else if (c in internals.literals && !parenthesis) {
              current += c;
              literal = internals.literals[c];
            } else if (c === "," && !parenthesis) {
              flush();
            } else {
              current += c;
              if (c === "(") {
                ++parenthesis;
              } else if (c === ")") {
                --parenthesis;
              }
            }
          }
          flush();
        }
        args2 = args2.map((arg) => new exports2.Parser(arg, this.settings));
        return function(context) {
          const innerValues = [];
          for (const arg of args2) {
            innerValues.push(arg.evaluate(context));
          }
          return method.call(context, ...innerValues);
        };
      }
      evaluate(context) {
        const parts = this._parts.slice();
        for (let i = parts.length - 2; i >= 0; --i) {
          const part = parts[i];
          if (part && part.type === "operator") {
            const current = parts[i + 1];
            parts.splice(i + 1, 1);
            const value = internals.evaluate(current, context);
            parts[i] = internals.single(part.value, value);
          }
        }
        internals.operatorsOrder.forEach((set) => {
          for (let i = 1; i < parts.length - 1; ) {
            if (set.includes(parts[i])) {
              const operator = parts[i];
              const left = internals.evaluate(parts[i - 1], context);
              const right = internals.evaluate(parts[i + 1], context);
              parts.splice(i, 2);
              const result = internals.calculate(operator, left, right);
              parts[i - 1] = result === 0 ? 0 : result;
            } else {
              i += 2;
            }
          }
        });
        return internals.evaluate(parts[0], context);
      }
    };
    exports2.Parser.prototype[internals.symbol] = true;
    internals.reference = function(name) {
      return function(context) {
        return context && context[name] !== void 0 ? context[name] : null;
      };
    };
    internals.evaluate = function(part, context) {
      if (part === null) {
        return null;
      }
      if (typeof part === "function") {
        return part(context);
      }
      if (part[internals.symbol]) {
        return part.evaluate(context);
      }
      return part;
    };
    internals.single = function(operator, value) {
      if (operator === "!") {
        return value ? false : true;
      }
      const negative = -value;
      if (negative === 0) {
        return 0;
      }
      return negative;
    };
    internals.calculate = function(operator, left, right) {
      if (operator === "??") {
        return internals.exists(left) ? left : right;
      }
      if (typeof left === "string" || typeof right === "string") {
        if (operator === "+") {
          left = internals.exists(left) ? left : "";
          right = internals.exists(right) ? right : "";
          return left + right;
        }
      } else {
        switch (operator) {
          case "^":
            return Math.pow(left, right);
          case "*":
            return left * right;
          case "/":
            return left / right;
          case "%":
            return left % right;
          case "+":
            return left + right;
          case "-":
            return left - right;
        }
      }
      switch (operator) {
        case "<":
          return left < right;
        case "<=":
          return left <= right;
        case ">":
          return left > right;
        case ">=":
          return left >= right;
        case "==":
          return left === right;
        case "!=":
          return left !== right;
        case "&&":
          return left && right;
        case "||":
          return left || right;
      }
      return null;
    };
    internals.exists = function(value) {
      return value !== null && value !== void 0;
    };
  })(lib$3);
  return lib$3;
}
var errors$1 = {};
var annotate = {};
var hasRequiredAnnotate;
function requireAnnotate() {
  if (hasRequiredAnnotate) return annotate;
  hasRequiredAnnotate = 1;
  const Clone = requireClone();
  const Common = requireCommon$1();
  const internals = {
    annotations: Symbol("annotations")
  };
  annotate.error = function(stripColorCodes) {
    if (!this._original || typeof this._original !== "object") {
      return this.details[0].message;
    }
    const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
    const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
    const endColor = stripColorCodes ? "" : "\x1B[0m";
    const obj = Clone(this._original);
    for (let i = this.details.length - 1; i >= 0; --i) {
      const pos = i + 1;
      const error2 = this.details[i];
      const path = error2.path;
      let node2 = obj;
      for (let j = 0; ; ++j) {
        const seg = path[j];
        if (Common.isSchema(node2)) {
          node2 = node2.clone();
        }
        if (j + 1 < path.length && typeof node2[seg] !== "string") {
          node2 = node2[seg];
        } else {
          const refAnnotations = node2[internals.annotations] || { errors: {}, missing: {} };
          node2[internals.annotations] = refAnnotations;
          const cacheKey = seg || error2.context.key;
          if (node2[seg] !== void 0) {
            refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
            refAnnotations.errors[cacheKey].push(pos);
          } else {
            refAnnotations.missing[cacheKey] = pos;
          }
          break;
        }
      }
    }
    const replacers = {
      key: /_\$key\$_([, \d]+)_\$end\$_"/g,
      missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
      arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
      specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };
    let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
    message = `${message}
${redFgEscape}`;
    for (let i = 0; i < this.details.length; ++i) {
      const pos = i + 1;
      message = `${message}
[${pos}] ${this.details[i].message}`;
    }
    message = message + endColor;
    return message;
  };
  internals.safeStringify = function(obj, spaces) {
    return JSON.stringify(obj, internals.serializer(), spaces);
  };
  internals.serializer = function() {
    const keys2 = [];
    const stack = [];
    const cycleReplacer = (key, value) => {
      if (stack[0] === value) {
        return "[Circular ~]";
      }
      return "[Circular ~." + keys2.slice(0, stack.indexOf(value)).join(".") + "]";
    };
    return function(key, value) {
      if (stack.length > 0) {
        const thisPos = stack.indexOf(this);
        if (~thisPos) {
          stack.length = thisPos + 1;
          keys2.length = thisPos + 1;
          keys2[thisPos] = key;
        } else {
          stack.push(this);
          keys2.push(key);
        }
        if (~stack.indexOf(value)) {
          value = cycleReplacer.call(this, key, value);
        }
      } else {
        stack.push(value);
      }
      if (value) {
        const annotations = value[internals.annotations];
        if (annotations) {
          if (Array.isArray(value)) {
            const annotated = [];
            for (let i = 0; i < value.length; ++i) {
              if (annotations.errors[i]) {
                annotated.push(`_$idx$_${annotations.errors[i].sort().join(", ")}_$end$_`);
              }
              annotated.push(value[i]);
            }
            value = annotated;
          } else {
            for (const errorKey in annotations.errors) {
              value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
              value[errorKey] = void 0;
            }
            for (const missingKey in annotations.missing) {
              value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
            }
          }
          return value;
        }
      }
      if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
        return "[" + value.toString() + "]";
      }
      return value;
    };
  };
  return annotate;
}
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  (function(exports2) {
    const Annotate = requireAnnotate();
    const Common = requireCommon$1();
    const Template = requireTemplate();
    exports2.Report = class {
      constructor(code, value, local, flags, messages2, state2, prefs) {
        this.code = code;
        this.flags = flags;
        this.messages = messages2;
        this.path = state2.path;
        this.prefs = prefs;
        this.state = state2;
        this.value = value;
        this.message = null;
        this.template = null;
        this.local = local || {};
        this.local.label = exports2.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      _setTemplate(template2) {
        this.template = template2;
        if (!this.flags.label && this.path.length === 0) {
          const localized = this._template(this.template, "root");
          if (localized) {
            this.local.label = localized;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template2 = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
        if (template2 === void 0) {
          return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template2.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages2, code) {
        return exports2.template(this.value, messages2, code || this.code, this.state, this.prefs);
      }
    };
    exports2.path = function(path) {
      let label = "";
      for (const segment of path) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports2.template = function(value, messages2, code, state2, prefs) {
      if (!messages2) {
        return;
      }
      if (Template.isTemplate(messages2)) {
        return code !== "root" ? messages2 : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state2, prefs);
      }
      if (lang && messages2[lang]) {
        if (messages2[lang][code] !== void 0) {
          return messages2[lang][code];
        }
        if (messages2[lang]["*"] !== void 0) {
          return messages2[lang]["*"];
        }
      }
      if (!messages2[code]) {
        return messages2["*"];
      }
      return messages2[code];
    };
    exports2.label = function(flags, state2, prefs, messages2) {
      if (!prefs.errors.label) {
        return "";
      }
      if (flags.label) {
        return flags.label;
      }
      let path = state2.path;
      if (prefs.errors.label === "key" && state2.path.length > 1) {
        path = state2.path.slice(-1);
      }
      const normalized = exports2.path(path);
      if (normalized) {
        return normalized;
      }
      return exports2.template(null, prefs.messages, "root", state2, prefs) || messages2 && exports2.template(null, messages2, "root", state2, prefs) || "value";
    };
    exports2.process = function(errors2, original, prefs) {
      if (!errors2) {
        return null;
      }
      const { override, message, details } = exports2.details(errors2);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports2.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports2.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports2.details = function(errors2, options = {}) {
      let messages2 = [];
      const details = [];
      for (const item of errors2) {
        if (item instanceof Error) {
          if (options.override !== false) {
            return { override: item };
          }
          const message2 = item.toString();
          messages2.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: { error: item }
          });
          continue;
        }
        const message = item.toString();
        messages2.push(message);
        details.push({
          message,
          path: item.path.filter((v) => typeof v !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages2.length > 1) {
        messages2 = [...new Set(messages2)];
      }
      return { message: messages2.join(". "), details };
    };
    exports2.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports2.ValidationError;
      }
    };
    exports2.ValidationError.prototype.isJoi = true;
    exports2.ValidationError.prototype.name = "ValidationError";
    exports2.ValidationError.prototype.annotate = Annotate.error;
  })(errors$1);
  return errors$1;
}
var ref$1 = {};
var hasRequiredRef$1;
function requireRef$1() {
  if (hasRequiredRef$1) return ref$1;
  hasRequiredRef$1 = 1;
  (function(exports2) {
    const Assert = requireAssert();
    const Clone = requireClone();
    const Reach = requireReach();
    const Common = requireCommon$1();
    let Template;
    const internals = {
      symbol: Symbol("ref"),
      // Used to internally identify references (shared with other joi versions)
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports2.create = function(key, options = {}) {
      Assert(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]);
      Assert(!options.prefix || typeof options.prefix === "object", "options.prefix must be of type object");
      const ref2 = Object.assign({}, internals.defaults, options);
      delete ref2.prefix;
      const separator = ref2.separator;
      const context = internals.context(key, separator, options.prefix);
      ref2.type = context.type;
      key = context.key;
      if (ref2.type === "value") {
        if (context.root) {
          Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref2.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref2.ancestor = 0;
        } else {
          if (ref2.ancestor !== void 0) {
            Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref2.ancestor = ancestor;
          }
        }
      }
      ref2.path = separator ? key === null ? [] : key.split(separator) : [key];
      return new internals.Ref(ref2);
    };
    exports2.in = function(key, options = {}) {
      return exports2.create(key, { ...options, in: true });
    };
    exports2.isRef = function(ref2) {
      return ref2 ? !!ref2[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options) {
        Assert(typeof options === "object", "Invalid reference construction");
        Common.assertOptions(options, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "render",
          "separator",
          "type",
          // Copied
          "depth",
          "key",
          "root",
          "display"
          // Overridden
        ]);
        Assert([false, void 0].includes(options.separator) || typeof options.separator === "string" && options.separator.length === 1, "Invalid separator");
        Assert(!options.adjust || typeof options.adjust === "function", "options.adjust must be a function");
        Assert(!options.map || Array.isArray(options.map), "options.map must be an array");
        Assert(!options.map || !options.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options);
        Assert(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state2, prefs, local, options = {}) {
        Assert(!this.in || options.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state2, options);
        }
        if (this.type === "local") {
          return this._resolve(local, state2, options);
        }
        if (!this.ancestor) {
          return this._resolve(value, state2, options);
        }
        if (this.ancestor === "root") {
          return this._resolve(state2.ancestors[state2.ancestors.length - 1], state2, options);
        }
        Assert(this.ancestor <= state2.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state2.ancestors[this.ancestor - 1], state2, options);
      }
      _resolve(target, state2, options) {
        let resolved;
        if (this.type === "value" && state2.mainstay.shadow && options.shadow !== false) {
          resolved = state2.mainstay.shadow.get(this.absolute(state2));
        }
        if (resolved === void 0) {
          resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        if (state2.mainstay) {
          state2.mainstay.tracer.resolve(state2, this, resolved);
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state2) {
        return [...state2.path.slice(0, -this.ancestor), ...this.path];
      }
      clone() {
        return new internals.Ref(this);
      }
      describe() {
        const ref2 = { path: this.path };
        if (this.type !== "value") {
          ref2.type = this.type;
        }
        if (this.separator !== ".") {
          ref2.separator = this.separator;
        }
        if (this.type === "value" && this.ancestor !== 1) {
          ref2.ancestor = this.ancestor;
        }
        if (this.map) {
          ref2.map = [...this.map];
        }
        for (const key of ["adjust", "iterables", "render"]) {
          if (this[key] !== null && this[key] !== void 0) {
            ref2[key] = this[key];
          }
        }
        if (this.in !== false) {
          ref2.in = true;
        }
        return { ref: ref2 };
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    exports2.build = function(desc) {
      desc = Object.assign({}, internals.defaults, desc);
      if (desc.type === "value" && desc.ancestor === void 0) {
        desc.ancestor = 1;
      }
      return new internals.Ref(desc);
    };
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return { key: key.slice(globalp.length), type: "global" };
        }
        const local = prefix.local === void 0 ? "#" : prefix.local;
        if (local !== separator && key.startsWith(local)) {
          return { key: key.slice(local.length), type: "local" };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return { key: key.slice(root.length), type: "value", root: true };
        }
      }
      return { key, type: "value" };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [1, 0];
      }
      if (key[0] !== separator) {
        return [1, 0];
      }
      if (key[1] !== separator) {
        return [0, 1];
      }
      let i = 2;
      while (key[i] === separator) {
        ++i;
      }
      return [i - 1, i];
    };
    exports2.toSibling = 0;
    exports2.toParent = 1;
    exports2.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports2.toParent : target;
        if (Array.isArray(source)) {
          for (const ref2 of source) {
            this.register(ref2, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({ ancestor: item.ancestor - target, root: item.root });
            }
          }
          return;
        }
        if (exports2.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }
        Template = Template || requireTemplate();
        if (Template.isTemplate(source)) {
          this.register(source.refs(), target);
        }
      }
      get length() {
        return this.refs.length;
      }
      clone() {
        const copy = new exports2.Manager();
        copy.refs = Clone(this.refs);
        return copy;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref2) => !ref2.ancestor).map((ref2) => ref2.root);
      }
    };
  })(ref$1);
  return ref$1;
}
var hasRequiredTemplate;
function requireTemplate() {
  if (hasRequiredTemplate) return template.exports;
  hasRequiredTemplate = 1;
  (function(module2, exports2) {
    const Assert = requireAssert();
    const Clone = requireClone();
    const EscapeHtml = requireEscapeHtml();
    const Formula = requireLib$3();
    const Common = requireCommon$1();
    const Errors = requireErrors$1();
    const Ref = requireRef$1();
    const internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module2.exports = internals.Template = class {
      constructor(source, options) {
        Assert(typeof source === "string", "Template source must be a string");
        Assert(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        if (options) {
          const { functions, ...opts } = options;
          this._settings = Object.keys(opts).length ? Clone(opts) : void 0;
          this._functions = functions;
          if (this._functions) {
            Assert(Object.keys(this._functions).every((key) => typeof key === "string"), "Functions keys must be strings");
            Assert(Object.values(this._functions).every((key) => typeof key === "function"), "Functions values must be functions");
          }
        } else {
          this._settings = void 0;
          this._functions = void 0;
        }
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          if (end === -1 || // Ignore non-matching closing
          part[1] === "{") {
            processed.push(`{${internals.decode(part)}`);
            continue;
          }
          let variable = part.slice(raw ? 0 : 1, end);
          const wrapped = variable[0] === ":";
          if (wrapped) {
            variable = variable.slice(1);
          }
          const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
          processed.push(dynamic);
          if (typeof dynamic !== "string") {
            refs = true;
          }
          const rest = part.slice(end + ender.length);
          if (rest) {
            processed.push(internals.decode(rest));
          }
        }
        if (!refs) {
          this.rendered = processed.join("");
          return;
        }
        this._template = processed;
      }
      static date(date2, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date2);
      }
      describe(options = {}) {
        if (!this._settings && options.compact) {
          return this.source;
        }
        const desc = { template: this.source };
        if (this._settings) {
          desc.options = this._settings;
        }
        if (this._functions) {
          desc.functions = this._functions;
        }
        return desc;
      }
      static build(desc) {
        return new internals.Template(desc.template, desc.options || desc.functions ? { ...desc.options, functions: desc.functions } : void 0);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template2) {
        return template2 ? !!template2[Common.symbols.template] : false;
      }
      refs() {
        if (!this._template) {
          return;
        }
        const refs = [];
        for (const part of this._template) {
          if (typeof part !== "string") {
            refs.push(...part.refs);
          }
        }
        return refs;
      }
      resolve(value, state2, prefs, local) {
        if (this._template && this._template.length === 1) {
          return this._part(
            this._template[0],
            /* context -> [*/
            value,
            state2,
            prefs,
            local,
            {}
            /*] */
          );
        }
        return this.render(value, state2, prefs, local);
      }
      _part(part, ...args2) {
        if (part.ref) {
          return part.ref.resolve(...args2);
        }
        return part.formula.evaluate(args2);
      }
      render(value, state2, prefs, local, options = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = this._part(
              part,
              /* context -> [*/
              value,
              state2,
              prefs,
              local,
              options
              /*] */
            );
            const string2 = internals.stringify(rendered, value, state2, prefs, local, options);
            if (string2 !== void 0) {
              const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string2 : EscapeHtml(string2);
              parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
            }
          }
        }
        return parts.join("");
      }
      _ref(content, { raw, wrapped }) {
        const refs = [];
        const reference = (variable) => {
          const ref2 = Ref.create(variable, this._settings);
          refs.push(ref2);
          return (context) => {
            const resolved = ref2.resolve(...context);
            return resolved !== void 0 ? resolved : null;
          };
        };
        try {
          const functions = this._functions ? { ...internals.functions, ...this._functions } : internals.functions;
          var formula = new Formula.Parser(content, { reference, functions, constants: internals.constants });
        } catch (err) {
          err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
          throw err;
        }
        if (formula.single) {
          if (formula.single.type === "reference") {
            const ref2 = refs[0];
            return { ref: ref2, raw, refs, wrapped: wrapped || ref2.type === "local" && ref2.key === "label" };
          }
          return internals.stringify(formula.single.value);
        }
        return { formula, raw, refs };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string2) {
      return string2.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string2) {
      return string2.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string2) {
      const parts = [];
      let current = "";
      for (let i = 0; i < string2.length; ++i) {
        const char = string2[i];
        if (char === "{") {
          let next = "";
          while (i + 1 < string2.length && string2[i + 1] === "{") {
            next += "{";
            ++i;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, original, state2, prefs, local, options = {}) {
      const type2 = typeof value;
      const wrap = prefs && prefs.errors && prefs.errors.wrap || {};
      let skipWrap = false;
      if (Ref.isRef(value) && value.render) {
        skipWrap = value.in;
        value = value.resolve(original, state2, prefs, local, { in: value.in, ...options });
      }
      if (value === null) {
        return "null";
      }
      if (type2 === "string") {
        return internals.wrap(value, options.arrayItems && wrap.string);
      }
      if (type2 === "number" || type2 === "function" || type2 === "symbol") {
        return value.toString();
      }
      if (type2 !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs2 = [];
        for (const [key, sym] of value.entries()) {
          pairs2.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs2;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      const values2 = [];
      for (const item of value) {
        values2.push(internals.stringify(item, original, state2, prefs, local, { arrayItems: true, ...options }));
      }
      return internals.wrap(values2.join(", "), !skipWrap && wrap.array);
    };
    internals.constants = {
      true: true,
      false: false,
      null: null,
      second: 1e3,
      minute: 60 * 1e3,
      hour: 60 * 60 * 1e3,
      day: 24 * 60 * 60 * 1e3
    };
    internals.functions = {
      if(condition, then, otherwise) {
        return condition ? then : otherwise;
      },
      length(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (!item || typeof item !== "object") {
          return null;
        }
        if (Array.isArray(item)) {
          return item.length;
        }
        return Object.keys(item).length;
      },
      msg(code) {
        const [value, state2, prefs, local, options] = this;
        const messages2 = options.messages;
        if (!messages2) {
          return "";
        }
        const template2 = Errors.template(value, messages2[0], code, state2, prefs) || Errors.template(value, messages2[1], code, state2, prefs);
        if (!template2) {
          return "";
        }
        return template2.render(value, state2, prefs, local, options);
      },
      number(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          return parseFloat(value);
        }
        if (typeof value === "boolean") {
          return value ? 1 : 0;
        }
        if (value instanceof Date) {
          return value.getTime();
        }
        return null;
      }
    };
  })(template);
  return template.exports;
}
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages;
  hasRequiredMessages = 1;
  (function(exports2) {
    const Assert = requireAssert();
    const Clone = requireClone();
    const Template = requireTemplate();
    exports2.compile = function(messages2, target) {
      if (typeof messages2 === "string") {
        Assert(!target, "Cannot set single message string");
        return new Template(messages2);
      }
      if (Template.isTemplate(messages2)) {
        Assert(!target, "Cannot set single message template");
        return messages2;
      }
      Assert(typeof messages2 === "object" && !Array.isArray(messages2), "Invalid message options");
      target = target ? Clone(target) : {};
      for (let code in messages2) {
        const message = messages2[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
    exports2.decompile = function(messages2) {
      const target = {};
      for (let code in messages2) {
        const message = messages2[code];
        if (code === "root") {
          target.root = message;
          continue;
        }
        if (Template.isTemplate(message)) {
          target[code] = message.describe({ compact: true });
          continue;
        }
        const language = code;
        target[language] = {};
        for (code in message) {
          const localized = message[code];
          if (code === "root") {
            target[language].root = localized;
            continue;
          }
          target[language][code] = localized.describe({ compact: true });
        }
      }
      return target;
    };
    exports2.merge = function(base2, extended) {
      if (!base2) {
        return exports2.compile(extended);
      }
      if (!extended) {
        return base2;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = Clone(base2);
      for (let code in extended) {
        const message = extended[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
  })(messages);
  return messages;
}
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  (function(exports2) {
    const Assert = requireAssert();
    const AssertError = requireError();
    const Pkg = require$$2;
    let Messages;
    let Schemas;
    const internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports2.version = Pkg.version;
    exports2.defaults = {
      abortEarly: true,
      allowUnknown: false,
      artifacts: false,
      cache: true,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      externals: true,
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false,
      warnings: false
    };
    exports2.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      // Used to internally identify any-based types (shared with other joi versions)
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      errors: Symbol("errors"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      parent: Symbol("parent"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      template: Symbol("template"),
      values: Symbol("values")
    };
    exports2.assertOptions = function(options, keys2, name = "Options") {
      Assert(options && typeof options === "object" && !Array.isArray(options), "Options must be of type object");
      const unknownKeys = Object.keys(options).filter((k) => !keys2.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports2.checkPreferences = function(prefs) {
      Schemas = Schemas || requireSchemas();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([result.error.details[0].message]);
      }
    };
    exports2.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports2.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports2.isIsoDate = function(date2) {
      return internals.isoDate.test(date2);
    };
    exports2.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports2.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports2.symbols.ref] || obj[exports2.symbols.template];
    };
    exports2.isSchema = function(schema, options = {}) {
      const any2 = schema && schema[exports2.symbols.any];
      if (!any2) {
        return false;
      }
      Assert(options.legacy || any2.version === exports2.version, "Cannot mix different versions of joi schemas");
      return true;
    };
    exports2.isValues = function(obj) {
      return obj[exports2.symbols.values];
    };
    exports2.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports2.preferences = function(target, source) {
      Messages = Messages || requireMessages();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports2.symbols.prefs];
      return merged;
    };
    exports2.tryWithPath = function(fn, key, options = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports2.validateArg = function(value, label, { assert: assert2, message }) {
      if (exports2.isSchema(assert2)) {
        const result = assert2.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert2(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports2.verifyFlat = function(args2, method) {
      for (const arg of args2) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  })(common$1);
  return common$1;
}
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache;
  hasRequiredCache = 1;
  const Assert = requireAssert();
  const Clone = requireClone();
  const Common = requireCommon$1();
  const internals = {
    max: 1e3,
    supported: /* @__PURE__ */ new Set(["undefined", "boolean", "number", "string"])
  };
  cache.provider = {
    provision(options) {
      return new internals.Cache(options);
    }
  };
  internals.Cache = class {
    constructor(options = {}) {
      Common.assertOptions(options, ["max"]);
      Assert(options.max === void 0 || options.max && options.max > 0 && isFinite(options.max), "Invalid max cache size");
      this._max = options.max || internals.max;
      this._map = /* @__PURE__ */ new Map();
      this._list = new internals.List();
    }
    get length() {
      return this._map.size;
    }
    set(key, value) {
      if (key !== null && !internals.supported.has(typeof key)) {
        return;
      }
      let node2 = this._map.get(key);
      if (node2) {
        node2.value = value;
        this._list.first(node2);
        return;
      }
      node2 = this._list.unshift({ key, value });
      this._map.set(key, node2);
      this._compact();
    }
    get(key) {
      const node2 = this._map.get(key);
      if (node2) {
        this._list.first(node2);
        return Clone(node2.value);
      }
    }
    _compact() {
      if (this._map.size > this._max) {
        const node2 = this._list.pop();
        this._map.delete(node2.key);
      }
    }
  };
  internals.List = class {
    constructor() {
      this.tail = null;
      this.head = null;
    }
    unshift(node2) {
      node2.next = null;
      node2.prev = this.head;
      if (this.head) {
        this.head.next = node2;
      }
      this.head = node2;
      if (!this.tail) {
        this.tail = node2;
      }
      return node2;
    }
    first(node2) {
      if (node2 === this.head) {
        return;
      }
      this._remove(node2);
      this.unshift(node2);
    }
    pop() {
      return this._remove(this.tail);
    }
    _remove(node2) {
      const { next, prev } = node2;
      next.prev = prev;
      if (prev) {
        prev.next = next;
      }
      if (node2 === this.tail) {
        this.tail = next;
      }
      node2.prev = null;
      node2.next = null;
      return node2;
    }
  };
  return cache;
}
var compile = {};
var hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile;
  hasRequiredCompile = 1;
  (function(exports2) {
    const Assert = requireAssert();
    const Common = requireCommon$1();
    const Ref = requireRef$1();
    const internals = {};
    exports2.schema = function(Joi, config2, options = {}) {
      Common.assertOptions(options, ["appendPath", "override"]);
      try {
        return internals.schema(Joi, config2, options);
      } catch (err) {
        if (options.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi, config2, options) {
      Assert(config2 !== void 0, "Invalid undefined schema");
      if (Array.isArray(config2)) {
        Assert(config2.length, "Invalid empty array schema");
        if (config2.length === 1) {
          config2 = config2[0];
        }
      }
      const valid = (base2, ...values2) => {
        if (options.override !== false) {
          return base2.valid(Joi.override, ...values2);
        }
        return base2.valid(...values2);
      };
      if (internals.simple(config2)) {
        return valid(Joi, config2);
      }
      if (typeof config2 === "function") {
        return Joi.custom(config2);
      }
      Assert(typeof config2 === "object", "Invalid schema content:", typeof config2);
      if (Common.isResolvable(config2)) {
        return valid(Joi, config2);
      }
      if (Common.isSchema(config2)) {
        return config2;
      }
      if (Array.isArray(config2)) {
        for (const item of config2) {
          if (!internals.simple(item)) {
            return Joi.alternatives().try(...config2);
          }
        }
        return valid(Joi, ...config2);
      }
      if (config2 instanceof RegExp) {
        return Joi.string().regex(config2);
      }
      if (config2 instanceof Date) {
        return valid(Joi.date(), config2);
      }
      Assert(Object.getPrototypeOf(config2) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi.object().keys(config2);
    };
    exports2.ref = function(id, options) {
      return Ref.isRef(id) ? id : Ref.create(id, options);
    };
    exports2.compile = function(root, schema, options = {}) {
      Common.assertOptions(options, ["legacy"]);
      const any2 = schema && schema[Common.symbols.any];
      if (any2) {
        Assert(options.legacy || any2.version === Common.version, "Cannot mix different versions of joi schemas:", any2.version, Common.version);
        return schema;
      }
      if (typeof schema !== "object" || !options.legacy) {
        return exports2.schema(root, schema, { appendPath: true });
      }
      const compiler = internals.walk(schema);
      if (!compiler) {
        return exports2.schema(root, schema, { appendPath: true });
      }
      return compiler.compile(compiler.root, schema);
    };
    internals.walk = function(schema) {
      if (typeof schema !== "object") {
        return null;
      }
      if (Array.isArray(schema)) {
        for (const item of schema) {
          const compiler = internals.walk(item);
          if (compiler) {
            return compiler;
          }
        }
        return null;
      }
      const any2 = schema[Common.symbols.any];
      if (any2) {
        return { root: schema[any2.root], compile: any2.compile };
      }
      Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      for (const key in schema) {
        const compiler = internals.walk(schema[key]);
        if (compiler) {
          return compiler;
        }
      }
      return null;
    };
    internals.simple = function(value) {
      return value === null || ["boolean", "string", "number"].includes(typeof value);
    };
    exports2.when = function(schema, condition, options) {
      if (options === void 0) {
        Assert(condition && typeof condition === "object", "Missing options");
        options = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options)) {
        options = { switch: options };
      }
      Common.assertOptions(options, ["is", "not", "then", "otherwise", "switch", "break"]);
      if (Common.isSchema(condition)) {
        Assert(options.is === void 0, '"is" can not be used with a schema condition');
        Assert(options.not === void 0, '"not" can not be used with a schema condition');
        Assert(options.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
      }
      Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      Assert(options.not === void 0 || options.is === void 0, 'Cannot combine "is" with "not"');
      if (options.switch === void 0) {
        let rule2 = options;
        if (options.not !== void 0) {
          rule2 = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }
        let is = rule2.is !== void 0 ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
        Assert(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options.is !== void 0 && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
          is = is.required();
        }
        return internals.condition(schema, { ref: exports2.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
      }
      Assert(Array.isArray(options.switch), '"switch" must be an array');
      Assert(options.is === void 0, 'Cannot combine "switch" with "is"');
      Assert(options.not === void 0, 'Cannot combine "switch" with "not"');
      Assert(options.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports2.ref(condition),
        switch: [],
        break: options.break
      };
      for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last2 = i === options.switch.length - 1;
        Common.assertOptions(test, last2 ? ["is", "then", "otherwise"] : ["is", "then"]);
        Assert(test.is !== void 0, 'Switch statement missing "is"');
        Assert(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema.$_compile(test.is),
          then: schema.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last2) {
          Assert(options.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options.otherwise !== void 0 ? options.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            Assert(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema, condition) {
      for (const key of ["then", "otherwise"]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema.$_compile(condition[key]);
        }
      }
      return condition;
    };
  })(compile);
  return compile;
}
var extend = {};
var hasRequiredExtend;
function requireExtend() {
  if (hasRequiredExtend) return extend;
  hasRequiredExtend = 1;
  const Assert = requireAssert();
  const Clone = requireClone();
  const Common = requireCommon$1();
  const Messages = requireMessages();
  const internals = {};
  extend.type = function(from2, options) {
    const base2 = Object.getPrototypeOf(from2);
    const prototype = Clone(base2);
    const schema = from2._assign(Object.create(prototype));
    const def = Object.assign({}, options);
    delete def.base;
    prototype._definition = def;
    const parent = base2._definition || {};
    def.messages = Messages.merge(parent.messages, def.messages);
    def.properties = Object.assign({}, parent.properties, def.properties);
    schema.type = def.type;
    def.flags = Object.assign({}, parent.flags, def.flags);
    const terms = Object.assign({}, parent.terms);
    if (def.terms) {
      for (const name in def.terms) {
        const term = def.terms[name];
        Assert(schema.$_terms[name] === void 0, "Invalid term override for", def.type, name);
        schema.$_terms[name] = term.init;
        terms[name] = term;
      }
    }
    def.terms = terms;
    if (!def.args) {
      def.args = parent.args;
    }
    def.prepare = internals.prepare(def.prepare, parent.prepare);
    if (def.coerce) {
      if (typeof def.coerce === "function") {
        def.coerce = { method: def.coerce };
      }
      if (def.coerce.from && !Array.isArray(def.coerce.from)) {
        def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
      }
    }
    def.coerce = internals.coerce(def.coerce, parent.coerce);
    def.validate = internals.validate(def.validate, parent.validate);
    const rules = Object.assign({}, parent.rules);
    if (def.rules) {
      for (const name in def.rules) {
        const rule = def.rules[name];
        Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
        let method = rule.method;
        if (method === void 0) {
          method = function() {
            return this.$_addRule(name);
          };
        }
        if (method) {
          Assert(!prototype[name], "Rule conflict in", def.type, name);
          prototype[name] = method;
        }
        Assert(!rules[name], "Rule conflict in", def.type, name);
        rules[name] = rule;
        if (rule.alias) {
          const aliases = [].concat(rule.alias);
          for (const alias of aliases) {
            prototype[alias] = rule.method;
          }
        }
        if (rule.args) {
          rule.argsByName = /* @__PURE__ */ new Map();
          rule.args = rule.args.map((arg) => {
            if (typeof arg === "string") {
              arg = { name: arg };
            }
            Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
            if (Common.isSchema(arg.assert)) {
              arg.assert = arg.assert.strict().label(arg.name);
            }
            rule.argsByName.set(arg.name, arg);
            return arg;
          });
        }
      }
    }
    def.rules = rules;
    const modifiers = Object.assign({}, parent.modifiers);
    if (def.modifiers) {
      for (const name in def.modifiers) {
        Assert(!prototype[name], "Rule conflict in", def.type, name);
        const modifier = def.modifiers[name];
        Assert(typeof modifier === "function", "Invalid modifier definition for", def.type, name);
        const method = function(arg) {
          return this.rule({ [name]: arg });
        };
        prototype[name] = method;
        modifiers[name] = modifier;
      }
    }
    def.modifiers = modifiers;
    if (def.overrides) {
      prototype._super = base2;
      schema.$_super = {};
      for (const override in def.overrides) {
        Assert(base2[override], "Cannot override missing", override);
        def.overrides[override][Common.symbols.parent] = base2[override];
        schema.$_super[override] = base2[override].bind(schema);
      }
      Object.assign(prototype, def.overrides);
    }
    def.cast = Object.assign({}, parent.cast, def.cast);
    const manifest2 = Object.assign({}, parent.manifest, def.manifest);
    manifest2.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
    def.manifest = manifest2;
    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
    return schema;
  };
  internals.build = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(obj, desc) {
      return parent(child(obj, desc), desc);
    };
  };
  internals.coerce = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return {
      from: child.from && parent.from ? [.../* @__PURE__ */ new Set([...child.from, ...parent.from])] : null,
      method(value, helpers) {
        let coerced;
        if (!parent.from || parent.from.includes(typeof value)) {
          coerced = parent.method(value, helpers);
          if (coerced) {
            if (coerced.errors || coerced.value === void 0) {
              return coerced;
            }
            value = coerced.value;
          }
        }
        if (!child.from || child.from.includes(typeof value)) {
          const own = child.method(value, helpers);
          if (own) {
            return own;
          }
        }
        return coerced;
      }
    };
  };
  internals.prepare = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(value, helpers) {
      const prepared = child(value, helpers);
      if (prepared) {
        if (prepared.errors || prepared.value === void 0) {
          return prepared;
        }
        value = prepared.value;
      }
      return parent(value, helpers) || prepared;
    };
  };
  internals.rebuild = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(schema) {
      parent(schema);
      child(schema);
    };
  };
  internals.validate = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(value, helpers) {
      const result = parent(value, helpers);
      if (result) {
        if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
          return result;
        }
        value = result.value;
      }
      return child(value, helpers) || result;
    };
  };
  return extend;
}
var manifest = {};
var hasRequiredManifest;
function requireManifest() {
  if (hasRequiredManifest) return manifest;
  hasRequiredManifest = 1;
  const Assert = requireAssert();
  const Clone = requireClone();
  const Common = requireCommon$1();
  const Messages = requireMessages();
  const Ref = requireRef$1();
  const Template = requireTemplate();
  let Schemas;
  const internals = {};
  manifest.describe = function(schema) {
    const def = schema._definition;
    const desc = {
      type: schema.type,
      flags: {},
      rules: []
    };
    for (const flag in schema._flags) {
      if (flag[0] !== "_") {
        desc.flags[flag] = internals.describe(schema._flags[flag]);
      }
    }
    if (!Object.keys(desc.flags).length) {
      delete desc.flags;
    }
    if (schema._preferences) {
      desc.preferences = Clone(schema._preferences, { shallow: ["messages"] });
      delete desc.preferences[Common.symbols.prefs];
      if (desc.preferences.messages) {
        desc.preferences.messages = Messages.decompile(desc.preferences.messages);
      }
    }
    if (schema._valids) {
      desc.allow = schema._valids.describe();
    }
    if (schema._invalids) {
      desc.invalid = schema._invalids.describe();
    }
    for (const rule of schema._rules) {
      const ruleDef = def.rules[rule.name];
      if (ruleDef.manifest === false) {
        continue;
      }
      const item = { name: rule.name };
      for (const custom in def.modifiers) {
        if (rule[custom] !== void 0) {
          item[custom] = internals.describe(rule[custom]);
        }
      }
      if (rule.args) {
        item.args = {};
        for (const key in rule.args) {
          const arg = rule.args[key];
          if (key === "options" && !Object.keys(arg).length) {
            continue;
          }
          item.args[key] = internals.describe(arg, { assign: key });
        }
        if (!Object.keys(item.args).length) {
          delete item.args;
        }
      }
      desc.rules.push(item);
    }
    if (!desc.rules.length) {
      delete desc.rules;
    }
    for (const term in schema.$_terms) {
      if (term[0] === "_") {
        continue;
      }
      Assert(!desc[term], "Cannot describe schema due to internal name conflict with", term);
      const items = schema.$_terms[term];
      if (!items) {
        continue;
      }
      if (items instanceof Map) {
        if (items.size) {
          desc[term] = [...items.entries()];
        }
        continue;
      }
      if (Common.isValues(items)) {
        desc[term] = items.describe();
        continue;
      }
      Assert(def.terms[term], "Term", term, "missing configuration");
      const manifest2 = def.terms[term].manifest;
      const mapped = typeof manifest2 === "object";
      if (!items.length && !mapped) {
        continue;
      }
      const normalized = [];
      for (const item of items) {
        normalized.push(internals.describe(item));
      }
      if (mapped) {
        const { from: from2, to } = manifest2.mapped;
        desc[term] = {};
        for (const item of normalized) {
          desc[term][item[to]] = item[from2];
        }
        continue;
      }
      if (manifest2 === "single") {
        Assert(normalized.length === 1, "Term", term, "contains more than one item");
        desc[term] = normalized[0];
        continue;
      }
      desc[term] = normalized;
    }
    internals.validate(schema.$_root, desc);
    return desc;
  };
  internals.describe = function(item, options = {}) {
    if (Array.isArray(item)) {
      return item.map(internals.describe);
    }
    if (item === Common.symbols.deepDefault) {
      return { special: "deep" };
    }
    if (typeof item !== "object" || item === null) {
      return item;
    }
    if (options.assign === "options") {
      return Clone(item);
    }
    if (Buffer && Buffer.isBuffer(item)) {
      return { buffer: item.toString("binary") };
    }
    if (item instanceof Date) {
      return item.toISOString();
    }
    if (item instanceof Error) {
      return item;
    }
    if (item instanceof RegExp) {
      if (options.assign === "regex") {
        return item.toString();
      }
      return { regex: item.toString() };
    }
    if (item[Common.symbols.literal]) {
      return { function: item.literal };
    }
    if (typeof item.describe === "function") {
      if (options.assign === "ref") {
        return item.describe().ref;
      }
      return item.describe();
    }
    const normalized = {};
    for (const key in item) {
      const value = item[key];
      if (value === void 0) {
        continue;
      }
      normalized[key] = internals.describe(value, { assign: key });
    }
    return normalized;
  };
  manifest.build = function(joi, desc) {
    const builder = new internals.Builder(joi);
    return builder.parse(desc);
  };
  internals.Builder = class {
    constructor(joi) {
      this.joi = joi;
    }
    parse(desc) {
      internals.validate(this.joi, desc);
      let schema = this.joi[desc.type]()._bare();
      const def = schema._definition;
      if (desc.flags) {
        for (const flag in desc.flags) {
          const setter = def.flags[flag] && def.flags[flag].setter || flag;
          Assert(typeof schema[setter] === "function", "Invalid flag", flag, "for type", desc.type);
          schema = schema[setter](this.build(desc.flags[flag]));
        }
      }
      if (desc.preferences) {
        schema = schema.preferences(this.build(desc.preferences));
      }
      if (desc.allow) {
        schema = schema.allow(...this.build(desc.allow));
      }
      if (desc.invalid) {
        schema = schema.invalid(...this.build(desc.invalid));
      }
      if (desc.rules) {
        for (const rule of desc.rules) {
          Assert(typeof schema[rule.name] === "function", "Invalid rule", rule.name, "for type", desc.type);
          const args2 = [];
          if (rule.args) {
            const built = {};
            for (const key in rule.args) {
              built[key] = this.build(rule.args[key], { assign: key });
            }
            const keys2 = Object.keys(built);
            const definition = def.rules[rule.name].args;
            if (definition) {
              Assert(keys2.length <= definition.length, "Invalid number of arguments for", desc.type, rule.name, "(expected up to", definition.length, ", found", keys2.length, ")");
              for (const { name } of definition) {
                args2.push(built[name]);
              }
            } else {
              Assert(keys2.length === 1, "Invalid number of arguments for", desc.type, rule.name, "(expected up to 1, found", keys2.length, ")");
              args2.push(built[keys2[0]]);
            }
          }
          schema = schema[rule.name](...args2);
          const options = {};
          for (const custom in def.modifiers) {
            if (rule[custom] !== void 0) {
              options[custom] = this.build(rule[custom]);
            }
          }
          if (Object.keys(options).length) {
            schema = schema.rule(options);
          }
        }
      }
      const terms = {};
      for (const key in desc) {
        if (["allow", "flags", "invalid", "whens", "preferences", "rules", "type"].includes(key)) {
          continue;
        }
        Assert(def.terms[key], "Term", key, "missing configuration");
        const manifest2 = def.terms[key].manifest;
        if (manifest2 === "schema") {
          terms[key] = desc[key].map((item) => this.parse(item));
          continue;
        }
        if (manifest2 === "values") {
          terms[key] = desc[key].map((item) => this.build(item));
          continue;
        }
        if (manifest2 === "single") {
          terms[key] = this.build(desc[key]);
          continue;
        }
        if (typeof manifest2 === "object") {
          terms[key] = {};
          for (const name in desc[key]) {
            const value = desc[key][name];
            terms[key][name] = this.parse(value);
          }
          continue;
        }
        terms[key] = this.build(desc[key]);
      }
      if (desc.whens) {
        terms.whens = desc.whens.map((when) => this.build(when));
      }
      schema = def.manifest.build(schema, terms);
      schema.$_temp.ruleset = false;
      return schema;
    }
    build(desc, options = {}) {
      if (desc === null) {
        return null;
      }
      if (Array.isArray(desc)) {
        return desc.map((item) => this.build(item));
      }
      if (desc instanceof Error) {
        return desc;
      }
      if (options.assign === "options") {
        return Clone(desc);
      }
      if (options.assign === "regex") {
        return internals.regex(desc);
      }
      if (options.assign === "ref") {
        return Ref.build(desc);
      }
      if (typeof desc !== "object") {
        return desc;
      }
      if (Object.keys(desc).length === 1) {
        if (desc.buffer) {
          Assert(Buffer, "Buffers are not supported");
          return Buffer && Buffer.from(desc.buffer, "binary");
        }
        if (desc.function) {
          return { [Common.symbols.literal]: true, literal: desc.function };
        }
        if (desc.override) {
          return Common.symbols.override;
        }
        if (desc.ref) {
          return Ref.build(desc.ref);
        }
        if (desc.regex) {
          return internals.regex(desc.regex);
        }
        if (desc.special) {
          Assert(["deep"].includes(desc.special), "Unknown special value", desc.special);
          return Common.symbols.deepDefault;
        }
        if (desc.value) {
          return Clone(desc.value);
        }
      }
      if (desc.type) {
        return this.parse(desc);
      }
      if (desc.template) {
        return Template.build(desc);
      }
      const normalized = {};
      for (const key in desc) {
        normalized[key] = this.build(desc[key], { assign: key });
      }
      return normalized;
    }
  };
  internals.regex = function(string2) {
    const end = string2.lastIndexOf("/");
    const exp = string2.slice(1, end);
    const flags = string2.slice(end + 1);
    return new RegExp(exp, flags);
  };
  internals.validate = function(joi, desc) {
    Schemas = Schemas || requireSchemas();
    joi.assert(desc, Schemas.description);
  };
  return manifest;
}
var trace = {};
var deepEqual;
var hasRequiredDeepEqual;
function requireDeepEqual() {
  if (hasRequiredDeepEqual) return deepEqual;
  hasRequiredDeepEqual = 1;
  const Types = requireTypes$1();
  const internals = {
    mismatched: null
  };
  deepEqual = function(obj, ref2, options) {
    options = Object.assign({ prototype: true }, options);
    return !!internals.isDeepEqual(obj, ref2, options, []);
  };
  internals.isDeepEqual = function(obj, ref2, options, seen) {
    if (obj === ref2) {
      return obj !== 0 || 1 / obj === 1 / ref2;
    }
    const type2 = typeof obj;
    if (type2 !== typeof ref2) {
      return false;
    }
    if (obj === null || ref2 === null) {
      return false;
    }
    if (type2 === "function") {
      if (!options.deepFunction || obj.toString() !== ref2.toString()) {
        return false;
      }
    } else if (type2 !== "object") {
      return obj !== obj && ref2 !== ref2;
    }
    const instanceType = internals.getSharedType(obj, ref2, !!options.prototype);
    switch (instanceType) {
      case Types.buffer:
        return Buffer && Buffer.prototype.equals.call(obj, ref2);
      // $lab:coverage:ignore$
      case Types.promise:
        return obj === ref2;
      case Types.regex:
        return obj.toString() === ref2.toString();
      case internals.mismatched:
        return false;
    }
    for (let i = seen.length - 1; i >= 0; --i) {
      if (seen[i].isSame(obj, ref2)) {
        return true;
      }
    }
    seen.push(new internals.SeenEntry(obj, ref2));
    try {
      return !!internals.isDeepEqualObj(instanceType, obj, ref2, options, seen);
    } finally {
      seen.pop();
    }
  };
  internals.getSharedType = function(obj, ref2, checkPrototype) {
    if (checkPrototype) {
      if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref2)) {
        return internals.mismatched;
      }
      return Types.getInternalProto(obj);
    }
    const type2 = Types.getInternalProto(obj);
    if (type2 !== Types.getInternalProto(ref2)) {
      return internals.mismatched;
    }
    return type2;
  };
  internals.valueOf = function(obj) {
    const objValueOf = obj.valueOf;
    if (objValueOf === void 0) {
      return obj;
    }
    try {
      return objValueOf.call(obj);
    } catch (err) {
      return err;
    }
  };
  internals.hasOwnEnumerableProperty = function(obj, key) {
    return Object.prototype.propertyIsEnumerable.call(obj, key);
  };
  internals.isSetSimpleEqual = function(obj, ref2) {
    for (const entry of Set.prototype.values.call(obj)) {
      if (!Set.prototype.has.call(ref2, entry)) {
        return false;
      }
    }
    return true;
  };
  internals.isDeepEqualObj = function(instanceType, obj, ref2, options, seen) {
    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys: keys2, getOwnPropertySymbols } = Object;
    if (instanceType === Types.array) {
      if (options.part) {
        for (const objValue of obj) {
          for (const refValue of ref2) {
            if (isDeepEqual(objValue, refValue, options, seen)) {
              return true;
            }
          }
        }
      } else {
        if (obj.length !== ref2.length) {
          return false;
        }
        for (let i = 0; i < obj.length; ++i) {
          if (!isDeepEqual(obj[i], ref2[i], options, seen)) {
            return false;
          }
        }
        return true;
      }
    } else if (instanceType === Types.set) {
      if (obj.size !== ref2.size) {
        return false;
      }
      if (!internals.isSetSimpleEqual(obj, ref2)) {
        const ref22 = new Set(Set.prototype.values.call(ref2));
        for (const objEntry of Set.prototype.values.call(obj)) {
          if (ref22.delete(objEntry)) {
            continue;
          }
          let found = false;
          for (const refEntry of ref22) {
            if (isDeepEqual(objEntry, refEntry, options, seen)) {
              ref22.delete(refEntry);
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
      }
    } else if (instanceType === Types.map) {
      if (obj.size !== ref2.size) {
        return false;
      }
      for (const [key, value] of Map.prototype.entries.call(obj)) {
        if (value === void 0 && !Map.prototype.has.call(ref2, key)) {
          return false;
        }
        if (!isDeepEqual(value, Map.prototype.get.call(ref2, key), options, seen)) {
          return false;
        }
      }
    } else if (instanceType === Types.error) {
      if (obj.name !== ref2.name || obj.message !== ref2.message) {
        return false;
      }
    }
    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref2);
    if ((obj !== valueOfObj || ref2 !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
      return false;
    }
    const objKeys = keys2(obj);
    if (!options.part && objKeys.length !== keys2(ref2).length && !options.skip) {
      return false;
    }
    let skipped = 0;
    for (const key of objKeys) {
      if (options.skip && options.skip.includes(key)) {
        if (ref2[key] === void 0) {
          ++skipped;
        }
        continue;
      }
      if (!hasOwnEnumerableProperty(ref2, key)) {
        return false;
      }
      if (!isDeepEqual(obj[key], ref2[key], options, seen)) {
        return false;
      }
    }
    if (!options.part && objKeys.length - skipped !== keys2(ref2).length) {
      return false;
    }
    if (options.symbols !== false) {
      const objSymbols = getOwnPropertySymbols(obj);
      const refSymbols = new Set(getOwnPropertySymbols(ref2));
      for (const key of objSymbols) {
        if (!options.skip || !options.skip.includes(key)) {
          if (hasOwnEnumerableProperty(obj, key)) {
            if (!hasOwnEnumerableProperty(ref2, key)) {
              return false;
            }
            if (!isDeepEqual(obj[key], ref2[key], options, seen)) {
              return false;
            }
          } else if (hasOwnEnumerableProperty(ref2, key)) {
            return false;
          }
        }
        refSymbols.delete(key);
      }
      for (const key of refSymbols) {
        if (hasOwnEnumerableProperty(ref2, key)) {
          return false;
        }
      }
    }
    return true;
  };
  internals.SeenEntry = class {
    constructor(obj, ref2) {
      this.obj = obj;
      this.ref = ref2;
    }
    isSame(obj, ref2) {
      return this.obj === obj && this.ref === ref2;
    }
  };
  return deepEqual;
}
var lib$2 = {};
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2;
  hasRequiredLib$2 = 1;
  lib$2.location = function(depth = 0) {
    const orig = Error.prepareStackTrace;
    Error.prepareStackTrace = (ignore2, stack) => stack;
    const capture = {};
    Error.captureStackTrace(capture, this);
    const line = capture.stack[depth + 1];
    Error.prepareStackTrace = orig;
    return {
      filename: line.getFileName(),
      line: line.getLineNumber()
    };
  };
  return lib$2;
}
var hasRequiredTrace;
function requireTrace() {
  if (hasRequiredTrace) return trace;
  hasRequiredTrace = 1;
  const DeepEqual = requireDeepEqual();
  const Pinpoint = requireLib$2();
  const Errors = requireErrors$1();
  const internals = {
    codes: {
      error: 1,
      pass: 2,
      full: 3
    },
    labels: {
      0: "never used",
      1: "always error",
      2: "always pass"
    }
  };
  trace.setup = function(root) {
    const trace2 = function() {
      root._tracer = root._tracer || new internals.Tracer();
      return root._tracer;
    };
    root.trace = trace2;
    root[Symbol.for("@hapi/lab/coverage/initialize")] = trace2;
    root.untrace = () => {
      root._tracer = null;
    };
  };
  trace.location = function(schema) {
    return schema.$_setFlag("_tracerLocation", Pinpoint.location(2));
  };
  internals.Tracer = class {
    constructor() {
      this.name = "Joi";
      this._schemas = /* @__PURE__ */ new Map();
    }
    _register(schema) {
      const existing = this._schemas.get(schema);
      if (existing) {
        return existing.store;
      }
      const store = new internals.Store(schema);
      const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);
      this._schemas.set(schema, { filename, line, store });
      return store;
    }
    _combine(merged, sources) {
      for (const { store } of this._schemas.values()) {
        store._combine(merged, sources);
      }
    }
    report(file) {
      const coverage = [];
      for (const { filename, line, store } of this._schemas.values()) {
        if (file && file !== filename) {
          continue;
        }
        const missing = [];
        const skipped = [];
        for (const [schema, log] of store._sources.entries()) {
          if (internals.sub(log.paths, skipped)) {
            continue;
          }
          if (!log.entry) {
            missing.push({
              status: "never reached",
              paths: [...log.paths]
            });
            skipped.push(...log.paths);
            continue;
          }
          for (const type2 of ["valid", "invalid"]) {
            const set = schema[`_${type2}s`];
            if (!set) {
              continue;
            }
            const values2 = new Set(set._values);
            const refs = new Set(set._refs);
            for (const { value, ref: ref2 } of log[type2]) {
              values2.delete(value);
              refs.delete(ref2);
            }
            if (values2.size || refs.size) {
              missing.push({
                status: [...values2, ...[...refs].map((ref2) => ref2.display)],
                rule: `${type2}s`
              });
            }
          }
          const rules = schema._rules.map((rule) => rule.name);
          for (const type2 of ["default", "failover"]) {
            if (schema._flags[type2] !== void 0) {
              rules.push(type2);
            }
          }
          for (const name of rules) {
            const status = internals.labels[log.rule[name] || 0];
            if (status) {
              const report = { rule: name, status };
              if (log.paths.size) {
                report.paths = [...log.paths];
              }
              missing.push(report);
            }
          }
        }
        if (missing.length) {
          coverage.push({
            filename,
            line,
            missing,
            severity: "error",
            message: `Schema missing tests for ${missing.map(internals.message).join(", ")}`
          });
        }
      }
      return coverage.length ? coverage : null;
    }
  };
  internals.Store = class {
    constructor(schema) {
      this.active = true;
      this._sources = /* @__PURE__ */ new Map();
      this._combos = /* @__PURE__ */ new Map();
      this._scan(schema);
    }
    debug(state2, source, name, result) {
      state2.mainstay.debug && state2.mainstay.debug.push({ type: source, name, result, path: state2.path });
    }
    entry(schema, state2) {
      internals.debug(state2, { type: "entry" });
      this._record(schema, (log) => {
        log.entry = true;
      });
    }
    filter(schema, state2, source, value) {
      internals.debug(state2, { type: source, ...value });
      this._record(schema, (log) => {
        log[source].add(value);
      });
    }
    log(schema, state2, source, name, result) {
      internals.debug(state2, { type: source, name, result: result === "full" ? "pass" : result });
      this._record(schema, (log) => {
        log[source][name] = log[source][name] || 0;
        log[source][name] |= internals.codes[result];
      });
    }
    resolve(state2, ref2, to) {
      if (!state2.mainstay.debug) {
        return;
      }
      const log = { type: "resolve", ref: ref2.display, to, path: state2.path };
      state2.mainstay.debug.push(log);
    }
    value(state2, by, from2, to, name) {
      if (!state2.mainstay.debug || DeepEqual(from2, to)) {
        return;
      }
      const log = { type: "value", by, from: from2, to, path: state2.path };
      if (name) {
        log.name = name;
      }
      state2.mainstay.debug.push(log);
    }
    _record(schema, each) {
      const log = this._sources.get(schema);
      if (log) {
        each(log);
        return;
      }
      const sources = this._combos.get(schema);
      for (const source of sources) {
        this._record(source, each);
      }
    }
    _scan(schema, _path) {
      const path = _path || [];
      let log = this._sources.get(schema);
      if (!log) {
        log = {
          paths: /* @__PURE__ */ new Set(),
          entry: false,
          rule: {},
          valid: /* @__PURE__ */ new Set(),
          invalid: /* @__PURE__ */ new Set()
        };
        this._sources.set(schema, log);
      }
      if (path.length) {
        log.paths.add(path);
      }
      const each = (sub, source) => {
        const subId = internals.id(sub, source);
        this._scan(sub, path.concat(subId));
      };
      schema.$_modify({ each, ref: false });
    }
    _combine(merged, sources) {
      this._combos.set(merged, sources);
    }
  };
  internals.message = function(item) {
    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ":" : "") : "";
    return `${path}${item.rule || ""} (${item.status})`;
  };
  internals.id = function(schema, { source, name, path, key }) {
    if (schema._flags.id) {
      return schema._flags.id;
    }
    if (key) {
      return key;
    }
    name = `@${name}`;
    if (source === "terms") {
      return [name, path[Math.min(path.length - 1, 1)]];
    }
    return name;
  };
  internals.sub = function(paths, skipped) {
    for (const path of paths) {
      for (const skip2 of skipped) {
        if (DeepEqual(path.slice(0, skip2.length), skip2)) {
          return true;
        }
      }
    }
    return false;
  };
  internals.debug = function(state2, event) {
    if (state2.mainstay.debug) {
      event.path = state2.debug ? [...state2.path, state2.debug] : state2.path;
      state2.mainstay.debug.push(event);
    }
  };
  return trace;
}
var merge$2;
var hasRequiredMerge$2;
function requireMerge$2() {
  if (hasRequiredMerge$2) return merge$2;
  hasRequiredMerge$2 = 1;
  const Assert = requireAssert();
  const Clone = requireClone();
  const Utils = requireUtils();
  const internals = {};
  merge$2 = internals.merge = function(target, source, options) {
    Assert(target && typeof target === "object", "Invalid target value: must be an object");
    Assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
    if (!source) {
      return target;
    }
    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);
    if (Array.isArray(source)) {
      Assert(Array.isArray(target), "Cannot merge array onto an object");
      if (!options.mergeArrays) {
        target.length = 0;
      }
      for (let i = 0; i < source.length; ++i) {
        target.push(Clone(source[i], { symbols: options.symbols }));
      }
      return target;
    }
    const keys2 = Utils.keys(source, options);
    for (let i = 0; i < keys2.length; ++i) {
      const key = keys2[i];
      if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
        continue;
      }
      const value = source[key];
      if (value && typeof value === "object") {
        if (target[key] === value) {
          continue;
        }
        if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || // $lab:coverage:ignore$
        value instanceof RegExp) {
          target[key] = Clone(value, { symbols: options.symbols });
        } else {
          internals.merge(target[key], value, options);
        }
      } else {
        if (value !== null && value !== void 0) {
          target[key] = value;
        } else if (options.nullOverride) {
          target[key] = value;
        }
      }
    }
    return target;
  };
  return merge$2;
}
var modify = {};
var hasRequiredModify;
function requireModify() {
  if (hasRequiredModify) return modify;
  hasRequiredModify = 1;
  (function(exports2) {
    const Assert = requireAssert();
    const Common = requireCommon$1();
    const Ref = requireRef$1();
    const internals = {};
    exports2.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone2 = new internals.Ids();
        clone2._byId = new Map(this._byId);
        clone2._byKey = new Map(this._byKey);
        clone2._schemaChain = this._schemaChain;
        return clone2;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      fork(path, adjuster, root) {
        const chain = this._collect(path);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };
        Assert(Common.isSchema(adjusted.schema), "adjuster function failed to return a joi schema type");
        for (const node2 of chain) {
          adjusted = { id: node2.id, schema: internals.fork(node2.schema, adjusted.id, adjusted.schema) };
        }
        return adjusted.schema;
      }
      labels(path, behind = []) {
        const current = path[0];
        const node2 = this._get(current);
        if (!node2) {
          return [...behind, ...path].join(".");
        }
        const forward = path.slice(1);
        behind = [...behind, node2.schema._flags.label || current];
        if (!forward.length) {
          return behind.join(".");
        }
        return node2.schema._ids.labels(forward, behind);
      }
      reach(path, behind = []) {
        const current = path[0];
        const node2 = this._get(current);
        Assert(node2, "Schema does not contain path", [...behind, ...path].join("."));
        const forward = path.slice(1);
        if (!forward.length) {
          return node2.schema;
        }
        return node2.schema._ids.reach(forward, [...behind, current]);
      }
      register(schema, { key } = {}) {
        if (!schema || !Common.isSchema(schema)) {
          return;
        }
        if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          Assert(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, { schema, id });
        }
        if (key) {
          Assert(!this._byKey.has(key), "Schema already contains key:", key);
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, { schema, id: key });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _collect(path, behind = [], nodes = []) {
        const current = path[0];
        const node2 = this._get(current);
        Assert(node2, "Schema does not contain path", [...behind, ...path].join("."));
        nodes = [node2, ...nodes];
        const forward = path.slice(1);
        if (!forward.length) {
          return nodes;
        }
        return node2.schema._ids._collect(forward, [...behind, current], nodes);
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    internals.fork = function(schema, id, replacement) {
      const each = (item, { key }) => {
        if (id === (item._flags.id || key)) {
          return replacement;
        }
      };
      const obj = exports2.schema(schema, { each, ref: false });
      return obj ? obj.$_mutateRebuild() : schema;
    };
    exports2.schema = function(schema, options) {
      let obj;
      for (const name in schema._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema._flags[name], { source: "flags", name }, options);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj._flags[name] = result;
        }
      }
      for (let i = 0; i < schema._rules.length; ++i) {
        const rule = schema._rules[i];
        const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options);
        if (result !== void 0) {
          obj = obj || schema.clone();
          const clone2 = Object.assign({}, rule);
          clone2.args = result;
          obj._rules[i] = clone2;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone2);
          }
        }
      }
      for (const name in schema.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema.$_terms[name], { source: "terms", name }, options);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options, _path, _key) {
      const path = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone2;
      if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
          const key = source.source === "terms" && source.name === "keys" && item[i].key;
          const result = internals.scan(item[i], source, options, [i, ...path], key);
          if (result !== void 0) {
            clone2 = clone2 || item.slice();
            clone2[i] = result;
          }
        }
        return clone2;
      }
      if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
        const result = options.each(item, { ...source, path, key: _key });
        if (result === item) {
          return;
        }
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== void 0) {
          clone2 = clone2 || Object.assign({}, item);
          clone2[key] = result;
        }
      }
      return clone2;
    };
  })(modify);
  return modify;
}
var validator = {};
var ignore;
var hasRequiredIgnore;
function requireIgnore() {
  if (hasRequiredIgnore) return ignore;
  hasRequiredIgnore = 1;
  ignore = function() {
  };
  return ignore;
}
var state;
var hasRequiredState$1;
function requireState$1() {
  if (hasRequiredState$1) return state;
  hasRequiredState$1 = 1;
  const Clone = requireClone();
  const Reach = requireReach();
  const Common = requireCommon$1();
  const internals = {
    value: Symbol("value")
  };
  state = internals.State = class {
    constructor(path, ancestors, state2) {
      this.path = path;
      this.ancestors = ancestors;
      this.mainstay = state2.mainstay;
      this.schemas = state2.schemas;
      this.debug = null;
    }
    localize(path, ancestors = null, schema = null) {
      const state2 = new internals.State(path, ancestors, this);
      if (schema && state2.schemas) {
        state2.schemas = [internals.schemas(schema), ...state2.schemas];
      }
      return state2;
    }
    nest(schema, debug) {
      const state2 = new internals.State(this.path, this.ancestors, this);
      state2.schemas = state2.schemas && [internals.schemas(schema), ...state2.schemas];
      state2.debug = debug;
      return state2;
    }
    shadow(value, reason) {
      this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
      this.mainstay.shadow.set(this.path, value, reason);
    }
    snapshot() {
      if (this.mainstay.shadow) {
        this._snapshot = Clone(this.mainstay.shadow.node(this.path));
      }
      this.mainstay.snapshot();
    }
    restore() {
      if (this.mainstay.shadow) {
        this.mainstay.shadow.override(this.path, this._snapshot);
        this._snapshot = void 0;
      }
      this.mainstay.restore();
    }
    commit() {
      if (this.mainstay.shadow) {
        this.mainstay.shadow.override(this.path, this._snapshot);
        this._snapshot = void 0;
      }
      this.mainstay.commit();
    }
  };
  internals.schemas = function(schema) {
    if (Common.isSchema(schema)) {
      return { schema };
    }
    return schema;
  };
  internals.Shadow = class {
    constructor() {
      this._values = null;
    }
    set(path, value, reason) {
      if (!path.length) {
        return;
      }
      if (reason === "strip" && typeof path[path.length - 1] === "number") {
        return;
      }
      this._values = this._values || /* @__PURE__ */ new Map();
      let node2 = this._values;
      for (let i = 0; i < path.length; ++i) {
        const segment = path[i];
        let next = node2.get(segment);
        if (!next) {
          next = /* @__PURE__ */ new Map();
          node2.set(segment, next);
        }
        node2 = next;
      }
      node2[internals.value] = value;
    }
    get(path) {
      const node2 = this.node(path);
      if (node2) {
        return node2[internals.value];
      }
    }
    node(path) {
      if (!this._values) {
        return;
      }
      return Reach(this._values, path, { iterables: true });
    }
    override(path, node2) {
      if (!this._values) {
        return;
      }
      const parents = path.slice(0, -1);
      const own = path[path.length - 1];
      const parent = Reach(this._values, parents, { iterables: true });
      if (node2) {
        parent.set(own, node2);
        return;
      }
      if (parent) {
        parent.delete(own);
      }
    }
  };
  return state;
}
var hasRequiredValidator;
function requireValidator() {
  if (hasRequiredValidator) return validator;
  hasRequiredValidator = 1;
  (function(exports2) {
    const Assert = requireAssert();
    const Clone = requireClone();
    const Ignore = requireIgnore();
    const Reach = requireReach();
    const Common = requireCommon$1();
    const Errors = requireErrors$1();
    const State = requireState$1();
    const internals = {
      result: Symbol("result")
    };
    exports2.entry = function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        Assert(prefs.warnings === void 0, "Cannot override warnings preference in synchronous validation");
        Assert(prefs.artifacts === void 0, "Cannot override artifacts preference in synchronous validation");
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      Assert(!result.mainstay.externals.length, "Schema with external rules must use validateAsync()");
      const outcome = { value: result.value };
      if (result.error) {
        outcome.error = result.error;
      }
      if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
      }
      if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
      }
      if (result.mainstay.artifacts) {
        outcome.artifacts = result.mainstay.artifacts;
      }
      return outcome;
    };
    exports2.entryAsync = async function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      const mainstay = result.mainstay;
      if (result.error) {
        if (mainstay.debug) {
          result.error.debug = mainstay.debug;
        }
        throw result.error;
      }
      if (mainstay.externals.length) {
        let root = result.value;
        const errors2 = [];
        for (const external of mainstay.externals) {
          const path = external.state.path;
          const linked = external.schema.type === "link" ? mainstay.links.get(external.schema) : null;
          let node2 = root;
          let key;
          let parent;
          const ancestors = path.length ? [root] : [];
          const original = path.length ? Reach(value, path) : value;
          if (path.length) {
            key = path[path.length - 1];
            let current = root;
            for (const segment of path.slice(0, -1)) {
              current = current[segment];
              ancestors.unshift(current);
            }
            parent = ancestors[0];
            node2 = parent[key];
          }
          try {
            const createError = (code, local) => (linked || external.schema).$_createError(code, node2, local, external.state, settings);
            const output = await external.method(node2, {
              schema: external.schema,
              linked,
              state: external.state,
              prefs,
              original,
              error: createError,
              errorsArray: internals.errorsArray,
              warn: (code, local) => mainstay.warnings.push((linked || external.schema).$_createError(code, node2, local, external.state, settings)),
              message: (messages2, local) => (linked || external.schema).$_createError("external", node2, local, external.state, settings, { messages: messages2 })
            });
            if (output === void 0 || output === node2) {
              continue;
            }
            if (output instanceof Errors.Report) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors2.push(output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (Array.isArray(output) && output[Common.symbols.errors]) {
              mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
              errors2.push(...output);
              if (settings.abortEarly) {
                break;
              }
              continue;
            }
            if (parent) {
              mainstay.tracer.value(external.state, "rule", node2, output, "external");
              parent[key] = output;
            } else {
              mainstay.tracer.value(external.state, "rule", root, output, "external");
              root = output;
            }
          } catch (err) {
            if (settings.errors.label) {
              err.message += ` (${external.label})`;
            }
            throw err;
          }
        }
        result.value = root;
        if (errors2.length) {
          result.error = Errors.process(errors2, value, settings);
          if (mainstay.debug) {
            result.error.debug = mainstay.debug;
          }
          throw result.error;
        }
      }
      if (!settings.warnings && !settings.debug && !settings.artifacts) {
        return result.value;
      }
      const outcome = { value: result.value };
      if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
      }
      if (mainstay.debug) {
        outcome.debug = mainstay.debug;
      }
      if (mainstay.artifacts) {
        outcome.artifacts = mainstay.artifacts;
      }
      return outcome;
    };
    internals.Mainstay = class {
      constructor(tracer, debug, links) {
        this.externals = [];
        this.warnings = [];
        this.tracer = tracer;
        this.debug = debug;
        this.links = links;
        this.shadow = null;
        this.artifacts = null;
        this._snapshots = [];
      }
      snapshot() {
        this._snapshots.push({
          externals: this.externals.slice(),
          warnings: this.warnings.slice()
        });
      }
      restore() {
        const snapshot = this._snapshots.pop();
        this.externals = snapshot.externals;
        this.warnings = snapshot.warnings;
      }
      commit() {
        this._snapshots.pop();
      }
    };
    internals.entry = function(value, schema, prefs) {
      const { tracer, cleanup } = internals.tracer(schema, prefs);
      const debug = prefs.debug ? [] : null;
      const links = schema._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = new internals.Mainstay(tracer, debug, links);
      const schemas2 = schema._ids._schemaChain ? [{ schema }] : null;
      const state2 = new State([], [], { mainstay, schemas: schemas2 });
      const result = exports2.validate(value, schema, state2, prefs);
      if (cleanup) {
        schema.$_root.untrace();
      }
      const error2 = Errors.process(result.errors, value, prefs);
      return { value: result.value, error: error2, mainstay };
    };
    internals.tracer = function(schema, prefs) {
      if (schema.$_root._tracer) {
        return { tracer: schema.$_root._tracer._register(schema) };
      }
      if (prefs.debug) {
        Assert(schema.$_root.trace, "Debug mode not supported");
        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };
      }
      return { tracer: internals.ignore };
    };
    exports2.validate = function(value, schema, state2, prefs, overrides = {}) {
      if (schema.$_terms.whens) {
        schema = schema._generate(value, state2, prefs).schema;
      }
      if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
      }
      if (schema._cache && prefs.cache) {
        const result = schema._cache.get(value);
        state2.mainstay.tracer.debug(state2, "validate", "cached", !!result);
        if (result) {
          return result;
        }
      }
      const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state2, prefs);
      const helpers = {
        original: value,
        prefs,
        schema,
        state: state2,
        error: createError,
        errorsArray: internals.errorsArray,
        warn: (code, local, localState) => state2.mainstay.warnings.push(createError(code, local, localState)),
        message: (messages2, local) => schema.$_createError("custom", value, local, state2, prefs, { messages: messages2 })
      };
      state2.mainstay.tracer.entry(schema, state2);
      const def = schema._definition;
      if (def.prepare && value !== void 0 && prefs.convert) {
        const prepared = def.prepare(value, helpers);
        if (prepared) {
          state2.mainstay.tracer.value(state2, "prepare", value, prepared.value);
          if (prepared.errors) {
            return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);
          }
          value = prepared.value;
        }
      }
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          state2.mainstay.tracer.value(state2, "coerced", value, coerced.value);
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty2 = schema._flags.empty;
      if (empty2 && empty2.$_match(internals.trim(value, schema), state2.nest(empty2), Common.defaults)) {
        state2.mainstay.tracer.value(state2, "empty", value, void 0);
        value = void 0;
      }
      const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [schema.$_createError("any.required", value, null, state2, prefs)], helpers);
        }
        if (presence === "optional") {
          if (schema._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          state2.mainstay.tracer.value(state2, "default", value, {});
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [schema.$_createError("any.unknown", value, null, state2, prefs)], helpers);
      }
      const errors2 = [];
      if (schema._valids) {
        const match = schema._valids.get(value, state2, prefs, schema._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            state2.mainstay.tracer.value(state2, "valids", value, match.value);
            value = match.value;
          }
          state2.mainstay.tracer.filter(schema, state2, "valid", match);
          return internals.finalize(value, null, helpers);
        }
        if (schema._flags.only) {
          const report = schema.$_createError("any.only", value, { valids: schema._valids.values({ display: true }) }, state2, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors2.push(report);
        }
      }
      if (schema._invalids) {
        const match = schema._invalids.get(value, state2, prefs, schema._flags.insensitive);
        if (match) {
          state2.mainstay.tracer.filter(schema, state2, "invalid", match);
          const report = schema.$_createError("any.invalid", value, { invalids: schema._invalids.values({ display: true }) }, state2, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors2.push(report);
        }
      }
      if (def.validate) {
        const base2 = def.validate(value, helpers);
        if (base2) {
          state2.mainstay.tracer.value(state2, "base", value, base2.value);
          value = base2.value;
          if (base2.errors) {
            if (!Array.isArray(base2.errors)) {
              errors2.push(base2.errors);
              return internals.finalize(value, errors2, helpers);
            }
            if (base2.errors.length) {
              errors2.push(...base2.errors);
              return internals.finalize(value, errors2, helpers);
            }
          }
        }
      }
      if (!schema._rules.length) {
        return internals.finalize(value, errors2, helpers);
      }
      return internals.rules(value, errors2, helpers);
    };
    internals.rules = function(value, errors2, helpers) {
      const { schema, state: state2, prefs } = helpers;
      for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          state2.mainstay.tracer.log(schema, state2, "rule", rule.name, "full");
          continue;
        }
        let ret;
        let args2 = rule.args;
        if (rule._resolve.length) {
          args2 = Object.assign({}, args2);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args2[key].resolve(value, state2, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema.$_createError("any.ref", resolved, { arg: key, ref: args2[key], reason: invalid }, state2, prefs);
              break;
            }
            args2[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args2, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          state2.mainstay.tracer.log(schema, state2, "rule", rule.name, "error");
          if (rule.warn) {
            state2.mainstay.warnings.push(...result.errors);
            continue;
          }
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors2.push(...result.errors);
        } else {
          state2.mainstay.tracer.log(schema, state2, "rule", rule.name, "pass");
          state2.mainstay.tracer.value(state2, "rule", value, result.value, rule.name);
          value = result.value;
        }
      }
      return internals.finalize(value, errors2, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
      }
      if (Array.isArray(ret) && ret[Common.symbols.errors]) {
        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
      }
      return { errors: null, value: ret };
    };
    internals.error = function(report, rule) {
      if (rule.message) {
        report._setTemplate(rule.message);
      }
      return report;
    };
    internals.finalize = function(value, errors2, helpers) {
      errors2 = errors2 || [];
      const { schema, state: state2, prefs } = helpers;
      if (errors2.length) {
        const failover = internals.default("failover", void 0, errors2, helpers);
        if (failover !== void 0) {
          state2.mainstay.tracer.value(state2, "failover", value, failover);
          value = failover;
          errors2 = [];
        }
      }
      if (errors2.length && schema._flags.error) {
        if (typeof schema._flags.error === "function") {
          errors2 = schema._flags.error(errors2);
          if (!Array.isArray(errors2)) {
            errors2 = [errors2];
          }
          for (const error2 of errors2) {
            Assert(error2 instanceof Error || error2 instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors2 = [schema._flags.error];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors2, helpers);
        state2.mainstay.tracer.value(state2, "default", value, defaulted);
        value = defaulted;
      }
      if (schema._flags.cast && value !== void 0) {
        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          state2.mainstay.tracer.value(state2, "cast", value, casted, schema._flags.cast);
          value = casted;
        }
      }
      if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {
        for (const { method } of schema.$_terms.externals) {
          state2.mainstay.externals.push({ method, schema, state: state2, label: Errors.label(schema._flags, state2, prefs) });
        }
      }
      const result = { value, errors: errors2.length ? errors2 : null };
      if (schema._flags.result) {
        result.value = schema._flags.result === "strip" ? void 0 : (
          /* raw */
          helpers.original
        );
        state2.mainstay.tracer.value(state2, schema._flags.result, value, result.value);
        state2.shadow(value, schema._flags.result);
      }
      if (schema._cache && prefs.cache !== false && !schema._refs.length) {
        schema._cache.set(helpers.original, result);
      }
      if (value !== void 0 && !result.errors && schema._flags.artifact !== void 0) {
        state2.mainstay.artifacts = state2.mainstay.artifacts || /* @__PURE__ */ new Map();
        if (!state2.mainstay.artifacts.has(schema._flags.artifact)) {
          state2.mainstay.artifacts.set(schema._flags.artifact, []);
        }
        state2.mainstay.artifacts.get(schema._flags.artifact).push(state2.path);
      }
      return result;
    };
    internals.prefs = function(schema, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
        return schema._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema._preferences);
      if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors2, helpers) {
      const { schema, state: state2, prefs } = helpers;
      const source = schema._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      state2.mainstay.tracer.log(schema, state2, "rule", flag, "full");
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args2 = source.length ? [Clone(state2.ancestors[0]), helpers] : [];
        try {
          return source(...args2);
        } catch (err) {
          errors2.push(schema.$_createError(`any.${flag}`, null, { error: err }, state2, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state2, prefs);
      }
      return Clone(source);
    };
    internals.trim = function(value, schema) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.ignore = {
      active: false,
      debug: Ignore,
      entry: Ignore,
      filter: Ignore,
      log: Ignore,
      resolve: Ignore,
      value: Ignore
    };
    internals.errorsArray = function() {
      const errors2 = [];
      errors2[Common.symbols.errors] = true;
      return errors2;
    };
  })(validator);
  return validator;
}
var values;
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues) return values;
  hasRequiredValues = 1;
  const Assert = requireAssert();
  const DeepEqual = requireDeepEqual();
  const Common = requireCommon$1();
  const internals = {};
  values = internals.Values = class {
    constructor(values2, refs) {
      this._values = new Set(values2);
      this._refs = new Set(refs);
      this._lowercase = internals.lowercases(values2);
      this._override = false;
    }
    get length() {
      return this._values.size + this._refs.size;
    }
    add(value, refs) {
      if (Common.isResolvable(value)) {
        if (!this._refs.has(value)) {
          this._refs.add(value);
          if (refs) {
            refs.register(value);
          }
        }
        return;
      }
      if (!this.has(value, null, null, false)) {
        this._values.add(value);
        if (typeof value === "string") {
          this._lowercase.set(value.toLowerCase(), value);
        }
      }
    }
    static merge(target, source, remove) {
      target = target || new internals.Values();
      if (source) {
        if (source._override) {
          return source.clone();
        }
        for (const item of [...source._values, ...source._refs]) {
          target.add(item);
        }
      }
      if (remove) {
        for (const item of [...remove._values, ...remove._refs]) {
          target.remove(item);
        }
      }
      return target.length ? target : null;
    }
    remove(value) {
      if (Common.isResolvable(value)) {
        this._refs.delete(value);
        return;
      }
      this._values.delete(value);
      if (typeof value === "string") {
        this._lowercase.delete(value.toLowerCase());
      }
    }
    has(value, state2, prefs, insensitive) {
      return !!this.get(value, state2, prefs, insensitive);
    }
    get(value, state2, prefs, insensitive) {
      if (!this.length) {
        return false;
      }
      if (this._values.has(value)) {
        return { value };
      }
      if (typeof value === "string" && value && insensitive) {
        const found = this._lowercase.get(value.toLowerCase());
        if (found) {
          return { value: found };
        }
      }
      if (!this._refs.size && typeof value !== "object") {
        return false;
      }
      if (typeof value === "object") {
        for (const item of this._values) {
          if (DeepEqual(item, value)) {
            return { value: item };
          }
        }
      }
      if (state2) {
        for (const ref2 of this._refs) {
          const resolved = ref2.resolve(value, state2, prefs, null, { in: true });
          if (resolved === void 0) {
            continue;
          }
          const items = !ref2.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
          for (const item of items) {
            if (typeof item !== typeof value) {
              continue;
            }
            if (insensitive && value && typeof value === "string") {
              if (item.toLowerCase() === value.toLowerCase()) {
                return { value: item, ref: ref2 };
              }
            } else {
              if (DeepEqual(item, value)) {
                return { value: item, ref: ref2 };
              }
            }
          }
        }
      }
      return false;
    }
    override() {
      this._override = true;
    }
    values(options) {
      if (options && options.display) {
        const values2 = [];
        for (const item of [...this._values, ...this._refs]) {
          if (item !== void 0) {
            values2.push(item);
          }
        }
        return values2;
      }
      return Array.from([...this._values, ...this._refs]);
    }
    clone() {
      const set = new internals.Values(this._values, this._refs);
      set._override = this._override;
      return set;
    }
    concat(source) {
      Assert(!source._override, "Cannot concat override set of values");
      const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
      set._override = this._override;
      return set;
    }
    describe() {
      const normalized = [];
      if (this._override) {
        normalized.push({ override: true });
      }
      for (const value of this._values.values()) {
        normalized.push(value && typeof value === "object" ? { value } : value);
      }
      for (const value of this._refs.values()) {
        normalized.push(value.describe());
      }
      return normalized;
    }
  };
  internals.Values.prototype[Common.symbols.values] = true;
  internals.Values.prototype.slice = internals.Values.prototype.clone;
  internals.lowercases = function(from2) {
    const map2 = /* @__PURE__ */ new Map();
    if (from2) {
      for (const value of from2) {
        if (typeof value === "string") {
          map2.set(value.toLowerCase(), value);
        }
      }
    }
    return map2;
  };
  return values;
}
var base;
var hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base;
  hasRequiredBase = 1;
  const Assert = requireAssert();
  const Clone = requireClone();
  const DeepEqual = requireDeepEqual();
  const Merge = requireMerge$2();
  const Cache = requireCache();
  const Common = requireCommon$1();
  const Compile = requireCompile();
  const Errors = requireErrors$1();
  const Extend = requireExtend();
  const Manifest = requireManifest();
  const Messages = requireMessages();
  const Modify = requireModify();
  const Ref = requireRef$1();
  const Trace = requireTrace();
  const Validator = requireValidator();
  const Values = requireValues();
  const internals = {};
  internals.Base = class {
    constructor(type2) {
      this.type = type2;
      this.$_root = null;
      this._definition = {};
      this._reset();
    }
    _reset() {
      this._ids = new Modify.Ids();
      this._preferences = null;
      this._refs = new Ref.Manager();
      this._cache = null;
      this._valids = null;
      this._invalids = null;
      this._flags = {};
      this._rules = [];
      this._singleRules = /* @__PURE__ */ new Map();
      this.$_terms = {};
      this.$_temp = {
        // Runtime state (not cloned)
        ruleset: null,
        // null: use last, false: error, number: start position
        whens: {}
        // Runtime cache of generated whens
      };
    }
    // Manifest
    describe() {
      Assert(typeof Manifest.describe === "function", "Manifest functionality disabled");
      return Manifest.describe(this);
    }
    // Rules
    allow(...values2) {
      Common.verifyFlat(values2, "allow");
      return this._values(values2, "_valids");
    }
    alter(targets) {
      Assert(targets && typeof targets === "object" && !Array.isArray(targets), "Invalid targets argument");
      Assert(!this._inRuleset(), "Cannot set alterations inside a ruleset");
      const obj = this.clone();
      obj.$_terms.alterations = obj.$_terms.alterations || [];
      for (const target in targets) {
        const adjuster = targets[target];
        Assert(typeof adjuster === "function", "Alteration adjuster for", target, "must be a function");
        obj.$_terms.alterations.push({ target, adjuster });
      }
      obj.$_temp.ruleset = false;
      return obj;
    }
    artifact(id) {
      Assert(id !== void 0, "Artifact cannot be undefined");
      Assert(!this._cache, "Cannot set an artifact with a rule cache");
      return this.$_setFlag("artifact", id);
    }
    cast(to) {
      Assert(to === false || typeof to === "string", "Invalid to value");
      Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
      return this.$_setFlag("cast", to === false ? void 0 : to);
    }
    default(value, options) {
      return this._default("default", value, options);
    }
    description(desc) {
      Assert(desc && typeof desc === "string", "Description must be a non-empty string");
      return this.$_setFlag("description", desc);
    }
    empty(schema) {
      const obj = this.clone();
      if (schema !== void 0) {
        schema = obj.$_compile(schema, { override: false });
      }
      return obj.$_setFlag("empty", schema, { clone: false });
    }
    error(err) {
      Assert(err, "Missing error");
      Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
      return this.$_setFlag("error", err);
    }
    example(example, options = {}) {
      Assert(example !== void 0, "Missing example");
      Common.assertOptions(options, ["override"]);
      return this._inner("examples", example, { single: true, override: options.override });
    }
    external(method, description) {
      if (typeof method === "object") {
        Assert(!description, "Cannot combine options with description");
        description = method.description;
        method = method.method;
      }
      Assert(typeof method === "function", "Method must be a function");
      Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
      return this._inner("externals", { method, description }, { single: true });
    }
    failover(value, options) {
      return this._default("failover", value, options);
    }
    forbidden() {
      return this.presence("forbidden");
    }
    id(id) {
      if (!id) {
        return this.$_setFlag("id", void 0);
      }
      Assert(typeof id === "string", "id must be a non-empty string");
      Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
      return this.$_setFlag("id", id);
    }
    invalid(...values2) {
      return this._values(values2, "_invalids");
    }
    label(name) {
      Assert(name && typeof name === "string", "Label name must be a non-empty string");
      return this.$_setFlag("label", name);
    }
    meta(meta) {
      Assert(meta !== void 0, "Meta cannot be undefined");
      return this._inner("metas", meta, { single: true });
    }
    note(...notes) {
      Assert(notes.length, "Missing notes");
      for (const note of notes) {
        Assert(note && typeof note === "string", "Notes must be non-empty strings");
      }
      return this._inner("notes", notes);
    }
    only(mode = true) {
      Assert(typeof mode === "boolean", "Invalid mode:", mode);
      return this.$_setFlag("only", mode);
    }
    optional() {
      return this.presence("optional");
    }
    prefs(prefs) {
      Assert(prefs, "Missing preferences");
      Assert(prefs.context === void 0, "Cannot override context");
      Assert(prefs.externals === void 0, "Cannot override externals");
      Assert(prefs.warnings === void 0, "Cannot override warnings");
      Assert(prefs.debug === void 0, "Cannot override debug");
      Common.checkPreferences(prefs);
      const obj = this.clone();
      obj._preferences = Common.preferences(obj._preferences, prefs);
      return obj;
    }
    presence(mode) {
      Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
      return this.$_setFlag("presence", mode);
    }
    raw(enabled = true) {
      return this.$_setFlag("result", enabled ? "raw" : void 0);
    }
    result(mode) {
      Assert(["raw", "strip"].includes(mode), "Unknown result mode", mode);
      return this.$_setFlag("result", mode);
    }
    required() {
      return this.presence("required");
    }
    strict(enabled) {
      const obj = this.clone();
      const convert = enabled === void 0 ? false : !enabled;
      obj._preferences = Common.preferences(obj._preferences, { convert });
      return obj;
    }
    strip(enabled = true) {
      return this.$_setFlag("result", enabled ? "strip" : void 0);
    }
    tag(...tags) {
      Assert(tags.length, "Missing tags");
      for (const tag of tags) {
        Assert(tag && typeof tag === "string", "Tags must be non-empty strings");
      }
      return this._inner("tags", tags);
    }
    unit(name) {
      Assert(name && typeof name === "string", "Unit name must be a non-empty string");
      return this.$_setFlag("unit", name);
    }
    valid(...values2) {
      Common.verifyFlat(values2, "valid");
      const obj = this.allow(...values2);
      obj.$_setFlag("only", !!obj._valids, { clone: false });
      return obj;
    }
    when(condition, options) {
      const obj = this.clone();
      if (!obj.$_terms.whens) {
        obj.$_terms.whens = [];
      }
      const when = Compile.when(obj, condition, options);
      if (!["any", "link"].includes(obj.type)) {
        const conditions = when.is ? [when] : when.switch;
        for (const item of conditions) {
          Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
          Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
        }
      }
      obj.$_terms.whens.push(when);
      return obj.$_mutateRebuild();
    }
    // Helpers
    cache(cache2) {
      Assert(!this._inRuleset(), "Cannot set caching inside a ruleset");
      Assert(!this._cache, "Cannot override schema cache");
      Assert(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
      const obj = this.clone();
      obj._cache = cache2 || Cache.provider.provision();
      obj.$_temp.ruleset = false;
      return obj;
    }
    clone() {
      const obj = Object.create(Object.getPrototypeOf(this));
      return this._assign(obj);
    }
    concat(source) {
      Assert(Common.isSchema(source), "Invalid schema object");
      Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
      Assert(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset");
      Assert(!source._inRuleset(), "Cannot concatenate a schema with open ruleset");
      let obj = this.clone();
      if (this.type === "any" && source.type !== "any") {
        const tmpObj = source.clone();
        for (const key of Object.keys(obj)) {
          if (key !== "type") {
            tmpObj[key] = obj[key];
          }
        }
        obj = tmpObj;
      }
      obj._ids.concat(source._ids);
      obj._refs.register(source, Ref.toSibling);
      obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
      obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
      obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
      for (const name of source._singleRules.keys()) {
        if (obj._singleRules.has(name)) {
          obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
          obj._singleRules.delete(name);
        }
      }
      for (const test of source._rules) {
        if (!source._definition.rules[test.method].multi) {
          obj._singleRules.set(test.name, test);
        }
        obj._rules.push(test);
      }
      if (obj._flags.empty && source._flags.empty) {
        obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
        const flags = Object.assign({}, source._flags);
        delete flags.empty;
        Merge(obj._flags, flags);
      } else if (source._flags.empty) {
        obj._flags.empty = source._flags.empty;
        const flags = Object.assign({}, source._flags);
        delete flags.empty;
        Merge(obj._flags, flags);
      } else {
        Merge(obj._flags, source._flags);
      }
      for (const key in source.$_terms) {
        const terms = source.$_terms[key];
        if (!terms) {
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms;
          }
          continue;
        }
        if (!obj.$_terms[key]) {
          obj.$_terms[key] = terms.slice();
          continue;
        }
        obj.$_terms[key] = obj.$_terms[key].concat(terms);
      }
      if (this.$_root._tracer) {
        this.$_root._tracer._combine(obj, [this, source]);
      }
      return obj.$_mutateRebuild();
    }
    extend(options) {
      Assert(!options.base, "Cannot extend type with another base");
      return Extend.type(this, options);
    }
    extract(path) {
      path = Array.isArray(path) ? path : path.split(".");
      return this._ids.reach(path);
    }
    fork(paths, adjuster) {
      Assert(!this._inRuleset(), "Cannot fork inside a ruleset");
      let obj = this;
      for (let path of [].concat(paths)) {
        path = Array.isArray(path) ? path : path.split(".");
        obj = obj._ids.fork(path, adjuster, obj);
      }
      obj.$_temp.ruleset = false;
      return obj;
    }
    rule(options) {
      const def = this._definition;
      Common.assertOptions(options, Object.keys(def.modifiers));
      Assert(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
      const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
      Assert(start >= 0 && start < this._rules.length, "Cannot apply rules to empty ruleset");
      const obj = this.clone();
      for (let i = start; i < obj._rules.length; ++i) {
        const original = obj._rules[i];
        const rule = Clone(original);
        for (const name in options) {
          def.modifiers[name](rule, options[name]);
          Assert(rule.name === original.name, "Cannot change rule name");
        }
        obj._rules[i] = rule;
        if (obj._singleRules.get(rule.name) === original) {
          obj._singleRules.set(rule.name, rule);
        }
      }
      obj.$_temp.ruleset = false;
      return obj.$_mutateRebuild();
    }
    get ruleset() {
      Assert(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
      const obj = this.clone();
      obj.$_temp.ruleset = obj._rules.length;
      return obj;
    }
    get $() {
      return this.ruleset;
    }
    tailor(targets) {
      targets = [].concat(targets);
      Assert(!this._inRuleset(), "Cannot tailor inside a ruleset");
      let obj = this;
      if (this.$_terms.alterations) {
        for (const { target, adjuster } of this.$_terms.alterations) {
          if (targets.includes(target)) {
            obj = adjuster(obj);
            Assert(Common.isSchema(obj), "Alteration adjuster for", target, "failed to return a schema object");
          }
        }
      }
      obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
      obj.$_temp.ruleset = false;
      return obj.$_mutateRebuild();
    }
    tracer() {
      return Trace.location ? Trace.location(this) : this;
    }
    validate(value, options) {
      return Validator.entry(value, this, options);
    }
    validateAsync(value, options) {
      return Validator.entryAsync(value, this, options);
    }
    // Extensions
    $_addRule(options) {
      if (typeof options === "string") {
        options = { name: options };
      }
      Assert(options && typeof options === "object", "Invalid options");
      Assert(options.name && typeof options.name === "string", "Invalid rule name");
      for (const key in options) {
        Assert(key[0] !== "_", "Cannot set private rule properties");
      }
      const rule = Object.assign({}, options);
      rule._resolve = [];
      rule.method = rule.method || rule.name;
      const definition = this._definition.rules[rule.method];
      const args2 = rule.args;
      Assert(definition, "Unknown rule", rule.method);
      const obj = this.clone();
      if (args2) {
        Assert(Object.keys(args2).length === 1 || Object.keys(args2).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
        for (const key in args2) {
          let arg = args2[key];
          if (definition.argsByName) {
            const resolver = definition.argsByName.get(key);
            if (resolver.ref && Common.isResolvable(arg)) {
              rule._resolve.push(key);
              obj.$_mutateRegister(arg);
            } else {
              if (resolver.normalize) {
                arg = resolver.normalize(arg);
                args2[key] = arg;
              }
              if (resolver.assert) {
                const error2 = Common.validateArg(arg, key, resolver);
                Assert(!error2, error2, "or reference");
              }
            }
          }
          if (arg === void 0) {
            delete args2[key];
            continue;
          }
          args2[key] = arg;
        }
      }
      if (!definition.multi) {
        obj._ruleRemove(rule.name, { clone: false });
        obj._singleRules.set(rule.name, rule);
      }
      if (obj.$_temp.ruleset === false) {
        obj.$_temp.ruleset = null;
      }
      if (definition.priority) {
        obj._rules.unshift(rule);
      } else {
        obj._rules.push(rule);
      }
      return obj;
    }
    $_compile(schema, options) {
      return Compile.schema(this.$_root, schema, options);
    }
    $_createError(code, value, local, state2, prefs, options = {}) {
      const flags = options.flags !== false ? this._flags : {};
      const messages2 = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
      return new Errors.Report(code, value, local, flags, messages2, state2, prefs);
    }
    $_getFlag(name) {
      return this._flags[name];
    }
    $_getRule(name) {
      return this._singleRules.get(name);
    }
    $_mapLabels(path) {
      path = Array.isArray(path) ? path : path.split(".");
      return this._ids.labels(path);
    }
    $_match(value, state2, prefs, overrides) {
      prefs = Object.assign({}, prefs);
      prefs.abortEarly = true;
      prefs._externals = false;
      state2.snapshot();
      const result = !Validator.validate(value, this, state2, prefs, overrides).errors;
      state2.restore();
      return result;
    }
    $_modify(options) {
      Common.assertOptions(options, ["each", "once", "ref", "schema"]);
      return Modify.schema(this, options) || this;
    }
    $_mutateRebuild() {
      Assert(!this._inRuleset(), "Cannot add this rule inside a ruleset");
      this._refs.reset();
      this._ids.reset();
      const each = (item, { source, name, path, key }) => {
        const family = this._definition[source][name] && this._definition[source][name].register;
        if (family !== false) {
          this.$_mutateRegister(item, { family, key });
        }
      };
      this.$_modify({ each });
      if (this._definition.rebuild) {
        this._definition.rebuild(this);
      }
      this.$_temp.ruleset = false;
      return this;
    }
    $_mutateRegister(schema, { family, key } = {}) {
      this._refs.register(schema, family);
      this._ids.register(schema, { key });
    }
    $_property(name) {
      return this._definition.properties[name];
    }
    $_reach(path) {
      return this._ids.reach(path);
    }
    $_rootReferences() {
      return this._refs.roots();
    }
    $_setFlag(name, value, options = {}) {
      Assert(name[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
      const flag = this._definition.flags[name] || {};
      if (DeepEqual(value, flag.default)) {
        value = void 0;
      }
      if (DeepEqual(value, this._flags[name])) {
        return this;
      }
      const obj = options.clone !== false ? this.clone() : this;
      if (value !== void 0) {
        obj._flags[name] = value;
        obj.$_mutateRegister(value);
      } else {
        delete obj._flags[name];
      }
      if (name[0] !== "_") {
        obj.$_temp.ruleset = false;
      }
      return obj;
    }
    $_parent(method, ...args2) {
      return this[method][Common.symbols.parent].call(this, ...args2);
    }
    $_validate(value, state2, prefs) {
      return Validator.validate(value, this, state2, prefs);
    }
    // Internals
    _assign(target) {
      target.type = this.type;
      target.$_root = this.$_root;
      target.$_temp = Object.assign({}, this.$_temp);
      target.$_temp.whens = {};
      target._ids = this._ids.clone();
      target._preferences = this._preferences;
      target._valids = this._valids && this._valids.clone();
      target._invalids = this._invalids && this._invalids.clone();
      target._rules = this._rules.slice();
      target._singleRules = Clone(this._singleRules, { shallow: true });
      target._refs = this._refs.clone();
      target._flags = Object.assign({}, this._flags);
      target._cache = null;
      target.$_terms = {};
      for (const key in this.$_terms) {
        target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
      }
      target.$_super = {};
      for (const override in this.$_super) {
        target.$_super[override] = this._super[override].bind(target);
      }
      return target;
    }
    _bare() {
      const obj = this.clone();
      obj._reset();
      const terms = obj._definition.terms;
      for (const name in terms) {
        const term = terms[name];
        obj.$_terms[name] = term.init;
      }
      return obj.$_mutateRebuild();
    }
    _default(flag, value, options = {}) {
      Common.assertOptions(options, "literal");
      Assert(value !== void 0, "Missing", flag, "value");
      Assert(typeof value === "function" || !options.literal, "Only function value supports literal option");
      if (typeof value === "function" && options.literal) {
        value = {
          [Common.symbols.literal]: true,
          literal: value
        };
      }
      const obj = this.$_setFlag(flag, value);
      return obj;
    }
    _generate(value, state2, prefs) {
      if (!this.$_terms.whens) {
        return { schema: this };
      }
      const whens = [];
      const ids = [];
      for (let i = 0; i < this.$_terms.whens.length; ++i) {
        const when = this.$_terms.whens[i];
        if (when.concat) {
          whens.push(when.concat);
          ids.push(`${i}.concat`);
          continue;
        }
        const input = when.ref ? when.ref.resolve(value, state2, prefs) : value;
        const tests = when.is ? [when] : when.switch;
        const before = ids.length;
        for (let j = 0; j < tests.length; ++j) {
          const { is, then, otherwise } = tests[j];
          const baseId = `${i}${when.switch ? "." + j : ""}`;
          if (is.$_match(input, state2.nest(is, `${baseId}.is`), prefs)) {
            if (then) {
              const localState = state2.localize([...state2.path, `${baseId}.then`], state2.ancestors, state2.schemas);
              const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
              break;
            }
          } else if (otherwise) {
            const localState = state2.localize([...state2.path, `${baseId}.otherwise`], state2.ancestors, state2.schemas);
            const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
            whens.push(generated);
            ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
            break;
          }
        }
        if (when.break && ids.length > before) {
          break;
        }
      }
      const id = ids.join(", ");
      state2.mainstay.tracer.debug(state2, "rule", "when", id);
      if (!id) {
        return { schema: this };
      }
      if (!state2.mainstay.tracer.active && this.$_temp.whens[id]) {
        return { schema: this.$_temp.whens[id], id };
      }
      let obj = this;
      if (this._definition.generate) {
        obj = this._definition.generate(this, value, state2, prefs);
      }
      for (const when of whens) {
        obj = obj.concat(when);
      }
      if (this.$_root._tracer) {
        this.$_root._tracer._combine(obj, [this, ...whens]);
      }
      this.$_temp.whens[id] = obj;
      return { schema: obj, id };
    }
    _inner(type2, values2, options = {}) {
      Assert(!this._inRuleset(), `Cannot set ${type2} inside a ruleset`);
      const obj = this.clone();
      if (!obj.$_terms[type2] || options.override) {
        obj.$_terms[type2] = [];
      }
      if (options.single) {
        obj.$_terms[type2].push(values2);
      } else {
        obj.$_terms[type2].push(...values2);
      }
      obj.$_temp.ruleset = false;
      return obj;
    }
    _inRuleset() {
      return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
    }
    _ruleRemove(name, options = {}) {
      if (!this._singleRules.has(name)) {
        return this;
      }
      const obj = options.clone !== false ? this.clone() : this;
      obj._singleRules.delete(name);
      const filtered = [];
      for (let i = 0; i < obj._rules.length; ++i) {
        const test = obj._rules[i];
        if (test.name === name && !test.keep) {
          if (obj._inRuleset() && i < obj.$_temp.ruleset) {
            --obj.$_temp.ruleset;
          }
          continue;
        }
        filtered.push(test);
      }
      obj._rules = filtered;
      return obj;
    }
    _values(values2, key) {
      Common.verifyFlat(values2, key.slice(1, -1));
      const obj = this.clone();
      const override = values2[0] === Common.symbols.override;
      if (override) {
        values2 = values2.slice(1);
      }
      if (!obj[key] && values2.length) {
        obj[key] = new Values();
      } else if (override) {
        obj[key] = values2.length ? new Values() : null;
        obj.$_mutateRebuild();
      }
      if (!obj[key]) {
        return obj;
      }
      if (override) {
        obj[key].override();
      }
      for (const value of values2) {
        Assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
        Assert(value !== Common.symbols.override, "Override must be the first value");
        const other = key === "_invalids" ? "_valids" : "_invalids";
        if (obj[other]) {
          obj[other].remove(value);
          if (!obj[other].length) {
            Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
            obj[other] = null;
          }
        }
        obj[key].add(value, obj._refs);
      }
      return obj;
    }
  };
  internals.Base.prototype[Common.symbols.any] = {
    version: Common.version,
    compile: Compile.compile,
    root: "$_root"
  };
  internals.Base.prototype.isImmutable = true;
  internals.Base.prototype.deny = internals.Base.prototype.invalid;
  internals.Base.prototype.disallow = internals.Base.prototype.invalid;
  internals.Base.prototype.equal = internals.Base.prototype.valid;
  internals.Base.prototype.exist = internals.Base.prototype.required;
  internals.Base.prototype.not = internals.Base.prototype.invalid;
  internals.Base.prototype.options = internals.Base.prototype.prefs;
  internals.Base.prototype.preferences = internals.Base.prototype.prefs;
  base = new internals.Base();
  return base;
}
var any;
var hasRequiredAny;
function requireAny() {
  if (hasRequiredAny) return any;
  hasRequiredAny = 1;
  const Assert = requireAssert();
  const Base = requireBase();
  const Common = requireCommon$1();
  const Messages = requireMessages();
  any = Base.extend({
    type: "any",
    flags: {
      only: { default: false }
    },
    terms: {
      alterations: { init: null },
      examples: { init: null },
      externals: { init: null },
      metas: { init: [] },
      notes: { init: [] },
      shared: { init: null },
      tags: { init: [] },
      whens: { init: null }
    },
    rules: {
      custom: {
        method(method, description) {
          Assert(typeof method === "function", "Method must be a function");
          Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
          return this.$_addRule({ name: "custom", args: { method, description } });
        },
        validate(value, helpers, { method }) {
          try {
            return method(value, helpers);
          } catch (err) {
            return helpers.error("any.custom", { error: err });
          }
        },
        args: ["method", "description"],
        multi: true
      },
      messages: {
        method(messages2) {
          return this.prefs({ messages: messages2 });
        }
      },
      shared: {
        method(schema) {
          Assert(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
          const obj = this.clone();
          obj.$_terms.shared = obj.$_terms.shared || [];
          obj.$_terms.shared.push(schema);
          obj.$_mutateRegister(schema);
          return obj;
        }
      },
      warning: {
        method(code, local) {
          Assert(code && typeof code === "string", "Invalid warning code");
          return this.$_addRule({ name: "warning", args: { code, local }, warn: true });
        },
        validate(value, helpers, { code, local }) {
          return helpers.error(code, local);
        },
        args: ["code", "local"],
        multi: true
      }
    },
    modifiers: {
      keep(rule, enabled = true) {
        rule.keep = enabled;
      },
      message(rule, message) {
        rule.message = Messages.compile(message);
      },
      warn(rule, enabled = true) {
        rule.warn = enabled;
      }
    },
    manifest: {
      build(obj, desc) {
        for (const key in desc) {
          const values2 = desc[key];
          if (["examples", "externals", "metas", "notes", "tags"].includes(key)) {
            for (const value of values2) {
              obj = obj[key.slice(0, -1)](value);
            }
            continue;
          }
          if (key === "alterations") {
            const alter = {};
            for (const { target, adjuster } of values2) {
              alter[target] = adjuster;
            }
            obj = obj.alter(alter);
            continue;
          }
          if (key === "whens") {
            for (const value of values2) {
              const { ref: ref2, is, not: not2, then, otherwise, concat: concat2 } = value;
              if (concat2) {
                obj = obj.concat(concat2);
              } else if (ref2) {
                obj = obj.when(ref2, { is, not: not2, then, otherwise, switch: value.switch, break: value.break });
              } else {
                obj = obj.when(is, { then, otherwise, break: value.break });
              }
            }
            continue;
          }
          if (key === "shared") {
            for (const value of values2) {
              obj = obj.shared(value);
            }
          }
        }
        return obj;
      }
    },
    messages: {
      "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
      "any.default": "{{#label}} threw an error when running default method",
      "any.failover": "{{#label}} threw an error when running failover method",
      "any.invalid": "{{#label}} contains an invalid value",
      "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
      "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
      "any.required": "{{#label}} is required",
      "any.unknown": "{{#label}} is not allowed"
    }
  });
  return any;
}
var alternatives;
var hasRequiredAlternatives;
function requireAlternatives() {
  if (hasRequiredAlternatives) return alternatives;
  hasRequiredAlternatives = 1;
  const Assert = requireAssert();
  const Merge = requireMerge$2();
  const Any = requireAny();
  const Common = requireCommon$1();
  const Compile = requireCompile();
  const Errors = requireErrors$1();
  const Ref = requireRef$1();
  const internals = {};
  alternatives = Any.extend({
    type: "alternatives",
    flags: {
      match: { default: "any" }
      // 'any', 'one', 'all'
    },
    terms: {
      matches: { init: [], register: Ref.toSibling }
    },
    args(schema, ...schemas2) {
      if (schemas2.length === 1) {
        if (Array.isArray(schemas2[0])) {
          return schema.try(...schemas2[0]);
        }
      }
      return schema.try(...schemas2);
    },
    validate(value, helpers) {
      const { schema, error: error2, state: state2, prefs } = helpers;
      if (schema._flags.match) {
        const matched = [];
        const failed = [];
        for (let i = 0; i < schema.$_terms.matches.length; ++i) {
          const item = schema.$_terms.matches[i];
          const localState = state2.nest(item.schema, `match.${i}`);
          localState.snapshot();
          const result = item.schema.$_validate(value, localState, prefs);
          if (!result.errors) {
            matched.push(result.value);
            localState.commit();
          } else {
            failed.push(result.errors);
            localState.restore();
          }
        }
        if (matched.length === 0) {
          const context = {
            details: failed.map((f) => Errors.details(f, { override: false }))
          };
          return { errors: error2("alternatives.any", context) };
        }
        if (schema._flags.match === "one") {
          return matched.length === 1 ? { value: matched[0] } : { errors: error2("alternatives.one") };
        }
        if (matched.length !== schema.$_terms.matches.length) {
          const context = {
            details: failed.map((f) => Errors.details(f, { override: false }))
          };
          return { errors: error2("alternatives.all", context) };
        }
        const isAnyObj = (alternative) => {
          return alternative.$_terms.matches.some((v) => {
            return v.schema.type === "object" || v.schema.type === "alternatives" && isAnyObj(v.schema);
          });
        };
        return isAnyObj(schema) ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };
      }
      const errors2 = [];
      for (let i = 0; i < schema.$_terms.matches.length; ++i) {
        const item = schema.$_terms.matches[i];
        if (item.schema) {
          const localState = state2.nest(item.schema, `match.${i}`);
          localState.snapshot();
          const result = item.schema.$_validate(value, localState, prefs);
          if (!result.errors) {
            localState.commit();
            return result;
          }
          localState.restore();
          errors2.push({ schema: item.schema, reports: result.errors });
          continue;
        }
        const input = item.ref ? item.ref.resolve(value, state2, prefs) : value;
        const tests = item.is ? [item] : item.switch;
        for (let j = 0; j < tests.length; ++j) {
          const test = tests[j];
          const { is, then, otherwise } = test;
          const id = `match.${i}${item.switch ? "." + j : ""}`;
          if (!is.$_match(input, state2.nest(is, `${id}.is`), prefs)) {
            if (otherwise) {
              return otherwise.$_validate(value, state2.nest(otherwise, `${id}.otherwise`), prefs);
            }
          } else if (then) {
            return then.$_validate(value, state2.nest(then, `${id}.then`), prefs);
          }
        }
      }
      return internals.errors(errors2, helpers);
    },
    rules: {
      conditional: {
        method(condition, options) {
          Assert(!this._flags._endedSwitch, "Unreachable condition");
          Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
          Assert(options.break === void 0, "Cannot use break option with alternatives conditional");
          const obj = this.clone();
          const match = Compile.when(obj, condition, options);
          const conditions = match.is ? [match] : match.switch;
          for (const item of conditions) {
            if (item.then && item.otherwise) {
              obj.$_setFlag("_endedSwitch", true, { clone: false });
              break;
            }
          }
          obj.$_terms.matches.push(match);
          return obj.$_mutateRebuild();
        }
      },
      match: {
        method(mode) {
          Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
          if (mode !== "any") {
            for (const match of this.$_terms.matches) {
              Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
            }
          }
          return this.$_setFlag("match", mode);
        }
      },
      try: {
        method(...schemas2) {
          Assert(schemas2.length, "Missing alternative schemas");
          Common.verifyFlat(schemas2, "try");
          Assert(!this._flags._endedSwitch, "Unreachable condition");
          const obj = this.clone();
          for (const schema of schemas2) {
            obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
          }
          return obj.$_mutateRebuild();
        }
      }
    },
    overrides: {
      label(name) {
        const obj = this.$_parent("label", name);
        const each = (item, source) => {
          return source.path[0] !== "is" && typeof item._flags.label !== "string" ? item.label(name) : void 0;
        };
        return obj.$_modify({ each, ref: false });
      }
    },
    rebuild(schema) {
      const each = (item) => {
        if (Common.isSchema(item) && item.type === "array") {
          schema.$_setFlag("_arrayItems", true, { clone: false });
        }
      };
      schema.$_modify({ each });
    },
    manifest: {
      build(obj, desc) {
        if (desc.matches) {
          for (const match of desc.matches) {
            const { schema, ref: ref2, is, not: not2, then, otherwise } = match;
            if (schema) {
              obj = obj.try(schema);
            } else if (ref2) {
              obj = obj.conditional(ref2, { is, then, not: not2, otherwise, switch: match.switch });
            } else {
              obj = obj.conditional(is, { then, otherwise });
            }
          }
        }
        return obj;
      }
    },
    messages: {
      "alternatives.all": "{{#label}} does not match all of the required types",
      "alternatives.any": "{{#label}} does not match any of the allowed types",
      "alternatives.match": "{{#label}} does not match any of the allowed types",
      "alternatives.one": "{{#label}} matches more than one allowed type",
      "alternatives.types": "{{#label}} must be one of {{#types}}"
    }
  });
  internals.errors = function(failures, { error: error2, state: state2 }) {
    if (!failures.length) {
      return { errors: error2("alternatives.any") };
    }
    if (failures.length === 1) {
      return { errors: failures[0].reports };
    }
    const valids = /* @__PURE__ */ new Set();
    const complex = [];
    for (const { reports, schema } of failures) {
      if (reports.length > 1) {
        return internals.unmatched(failures, error2);
      }
      const report = reports[0];
      if (report instanceof Errors.Report === false) {
        return internals.unmatched(failures, error2);
      }
      if (report.state.path.length !== state2.path.length) {
        complex.push({ type: schema.type, report });
        continue;
      }
      if (report.code === "any.only") {
        for (const valid of report.local.valids) {
          valids.add(valid);
        }
        continue;
      }
      const [type2, code] = report.code.split(".");
      if (code !== "base") {
        complex.push({ type: schema.type, report });
      } else if (report.code === "object.base") {
        valids.add(report.local.type);
      } else {
        valids.add(type2);
      }
    }
    if (!complex.length) {
      return { errors: error2("alternatives.types", { types: [...valids] }) };
    }
    if (complex.length === 1) {
      return { errors: complex[0].report };
    }
    return internals.unmatched(failures, error2);
  };
  internals.unmatched = function(failures, error2) {
    const errors2 = [];
    for (const failure of failures) {
      errors2.push(...failure.reports);
    }
    return { errors: error2("alternatives.match", Errors.details(errors2, { override: false })) };
  };
  return alternatives;
}
var array;
var hasRequiredArray;
function requireArray() {
  if (hasRequiredArray) return array;
  hasRequiredArray = 1;
  const Assert = requireAssert();
  const DeepEqual = requireDeepEqual();
  const Reach = requireReach();
  const Any = requireAny();
  const Common = requireCommon$1();
  const Compile = requireCompile();
  const internals = {};
  array = Any.extend({
    type: "array",
    flags: {
      single: { default: false },
      sparse: { default: false }
    },
    terms: {
      items: { init: [], manifest: "schema" },
      ordered: { init: [], manifest: "schema" },
      _exclusions: { init: [] },
      _inclusions: { init: [] },
      _requireds: { init: [] }
    },
    coerce: {
      from: "object",
      method(value, { schema, state: state2, prefs }) {
        if (!Array.isArray(value)) {
          return;
        }
        const sort = schema.$_getRule("sort");
        if (!sort) {
          return;
        }
        return internals.sort(schema, value, sort.args.options, state2, prefs);
      }
    },
    validate(value, { schema, error: error2 }) {
      if (!Array.isArray(value)) {
        if (schema._flags.single) {
          const single2 = [value];
          single2[Common.symbols.arraySingle] = true;
          return { value: single2 };
        }
        return { errors: error2("array.base") };
      }
      if (!schema.$_getRule("items") && !schema.$_terms.externals) {
        return;
      }
      return { value: value.slice() };
    },
    rules: {
      has: {
        method(schema) {
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.$_addRule({ name: "has", args: { schema } });
          obj.$_mutateRegister(schema);
          return obj;
        },
        validate(value, { state: state2, prefs, error: error2 }, { schema: has }) {
          const ancestors = [value, ...state2.ancestors];
          for (let i = 0; i < value.length; ++i) {
            const localState = state2.localize([...state2.path, i], ancestors, has);
            if (has.$_match(value[i], localState, prefs)) {
              return value;
            }
          }
          const patternLabel = has._flags.label;
          if (patternLabel) {
            return error2("array.hasKnown", { patternLabel });
          }
          return error2("array.hasUnknown", null);
        },
        multi: true
      },
      items: {
        method(...schemas2) {
          Common.verifyFlat(schemas2, "items");
          const obj = this.$_addRule("items");
          for (let i = 0; i < schemas2.length; ++i) {
            const type2 = Common.tryWithPath(() => this.$_compile(schemas2[i]), i, { append: true });
            obj.$_terms.items.push(type2);
          }
          return obj.$_mutateRebuild();
        },
        validate(value, { schema, error: error2, state: state2, prefs, errorsArray }) {
          const requireds = schema.$_terms._requireds.slice();
          const ordereds = schema.$_terms.ordered.slice();
          const inclusions = [...schema.$_terms._inclusions, ...requireds];
          const wasArray = !value[Common.symbols.arraySingle];
          delete value[Common.symbols.arraySingle];
          const errors2 = errorsArray();
          let il = value.length;
          for (let i = 0; i < il; ++i) {
            const item = value[i];
            let errored = false;
            let isValid = false;
            const key = wasArray ? i : new Number(i);
            const path = [...state2.path, key];
            if (!schema._flags.sparse && item === void 0) {
              errors2.push(error2("array.sparse", { key, path, pos: i, value: void 0 }, state2.localize(path)));
              if (prefs.abortEarly) {
                return errors2;
              }
              ordereds.shift();
              continue;
            }
            const ancestors = [value, ...state2.ancestors];
            for (const exclusion of schema.$_terms._exclusions) {
              if (!exclusion.$_match(item, state2.localize(path, ancestors, exclusion), prefs, { presence: "ignore" })) {
                continue;
              }
              errors2.push(error2("array.excludes", { pos: i, value: item }, state2.localize(path)));
              if (prefs.abortEarly) {
                return errors2;
              }
              errored = true;
              ordereds.shift();
              break;
            }
            if (errored) {
              continue;
            }
            if (schema.$_terms.ordered.length) {
              if (ordereds.length) {
                const ordered = ordereds.shift();
                const res = ordered.$_validate(item, state2.localize(path, ancestors, ordered), prefs);
                if (!res.errors) {
                  if (ordered._flags.result === "strip") {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                  } else if (!schema._flags.sparse && res.value === void 0) {
                    errors2.push(error2("array.sparse", { key, path, pos: i, value: void 0 }, state2.localize(path)));
                    if (prefs.abortEarly) {
                      return errors2;
                    }
                    continue;
                  } else {
                    value[i] = res.value;
                  }
                } else {
                  errors2.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors2;
                  }
                }
                continue;
              } else if (!schema.$_terms.items.length) {
                errors2.push(error2("array.orderedLength", { pos: i, limit: schema.$_terms.ordered.length }));
                if (prefs.abortEarly) {
                  return errors2;
                }
                break;
              }
            }
            const requiredChecks = [];
            let jl = requireds.length;
            for (let j = 0; j < jl; ++j) {
              const localState = state2.localize(path, ancestors, requireds[j]);
              localState.snapshot();
              const res = requireds[j].$_validate(item, localState, prefs);
              requiredChecks[j] = res;
              if (!res.errors) {
                localState.commit();
                value[i] = res.value;
                isValid = true;
                internals.fastSplice(requireds, j);
                --j;
                --jl;
                if (!schema._flags.sparse && res.value === void 0) {
                  errors2.push(error2("array.sparse", { key, path, pos: i, value: void 0 }, state2.localize(path)));
                  if (prefs.abortEarly) {
                    return errors2;
                  }
                }
                break;
              }
              localState.restore();
            }
            if (isValid) {
              continue;
            }
            const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
            jl = inclusions.length;
            for (const inclusion of inclusions) {
              let res;
              const previousCheck = requireds.indexOf(inclusion);
              if (previousCheck !== -1) {
                res = requiredChecks[previousCheck];
              } else {
                const localState = state2.localize(path, ancestors, inclusion);
                localState.snapshot();
                res = inclusion.$_validate(item, localState, prefs);
                if (!res.errors) {
                  localState.commit();
                  if (inclusion._flags.result === "strip") {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                  } else if (!schema._flags.sparse && res.value === void 0) {
                    errors2.push(error2("array.sparse", { key, path, pos: i, value: void 0 }, state2.localize(path)));
                    errored = true;
                  } else {
                    value[i] = res.value;
                  }
                  isValid = true;
                  break;
                }
                localState.restore();
              }
              if (jl === 1) {
                if (stripUnknown) {
                  internals.fastSplice(value, i);
                  --i;
                  --il;
                  isValid = true;
                  break;
                }
                errors2.push(...res.errors);
                if (prefs.abortEarly) {
                  return errors2;
                }
                errored = true;
                break;
              }
            }
            if (errored) {
              continue;
            }
            if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) && !isValid) {
              if (stripUnknown) {
                internals.fastSplice(value, i);
                --i;
                --il;
                continue;
              }
              errors2.push(error2("array.includes", { pos: i, value: item }, state2.localize(path)));
              if (prefs.abortEarly) {
                return errors2;
              }
            }
          }
          if (requireds.length) {
            internals.fillMissedErrors(schema, errors2, requireds, value, state2, prefs);
          }
          if (ordereds.length) {
            internals.fillOrderedErrors(schema, errors2, ordereds, value, state2, prefs);
            if (!errors2.length) {
              internals.fillDefault(ordereds, value, state2, prefs);
            }
          }
          return errors2.length ? errors2 : value;
        },
        priority: true,
        manifest: false
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args: args2 }) {
          if (Common.compare(value.length, limit, operator)) {
            return value;
          }
          return helpers.error("array." + name, { limit: args2.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      },
      ordered: {
        method(...schemas2) {
          Common.verifyFlat(schemas2, "ordered");
          const obj = this.$_addRule("items");
          for (let i = 0; i < schemas2.length; ++i) {
            const type2 = Common.tryWithPath(() => this.$_compile(schemas2[i]), i, { append: true });
            internals.validateSingle(type2, obj);
            obj.$_mutateRegister(type2);
            obj.$_terms.ordered.push(type2);
          }
          return obj.$_mutateRebuild();
        }
      },
      single: {
        method(enabled) {
          const value = enabled === void 0 ? true : !!enabled;
          Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
          return this.$_setFlag("single", value);
        }
      },
      sort: {
        method(options = {}) {
          Common.assertOptions(options, ["by", "order"]);
          const settings = {
            order: options.order || "ascending"
          };
          if (options.by) {
            settings.by = Compile.ref(options.by, { ancestor: 0 });
            Assert(!settings.by.ancestor, "Cannot sort by ancestor");
          }
          return this.$_addRule({ name: "sort", args: { options: settings } });
        },
        validate(value, { error: error2, state: state2, prefs, schema }, { options }) {
          const { value: sorted, errors: errors2 } = internals.sort(schema, value, options, state2, prefs);
          if (errors2) {
            return errors2;
          }
          for (let i = 0; i < value.length; ++i) {
            if (value[i] !== sorted[i]) {
              return error2("array.sort", { order: options.order, by: options.by ? options.by.key : "value" });
            }
          }
          return value;
        },
        convert: true
      },
      sparse: {
        method(enabled) {
          const value = enabled === void 0 ? true : !!enabled;
          if (this._flags.sparse === value) {
            return this;
          }
          const obj = value ? this.clone() : this.$_addRule("items");
          return obj.$_setFlag("sparse", value, { clone: false });
        }
      },
      unique: {
        method(comparator, options = {}) {
          Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
          Common.assertOptions(options, ["ignoreUndefined", "separator"]);
          const rule = { name: "unique", args: { options, comparator } };
          if (comparator) {
            if (typeof comparator === "string") {
              const separator = Common.default(options.separator, ".");
              rule.path = separator ? comparator.split(separator) : [comparator];
            } else {
              rule.comparator = comparator;
            }
          }
          return this.$_addRule(rule);
        },
        validate(value, { state: state2, error: error2, schema }, { comparator: raw, options }, { comparator, path }) {
          const found = {
            string: /* @__PURE__ */ Object.create(null),
            number: /* @__PURE__ */ Object.create(null),
            undefined: /* @__PURE__ */ Object.create(null),
            boolean: /* @__PURE__ */ Object.create(null),
            bigint: /* @__PURE__ */ Object.create(null),
            object: /* @__PURE__ */ new Map(),
            function: /* @__PURE__ */ new Map(),
            custom: /* @__PURE__ */ new Map()
          };
          const compare = comparator || DeepEqual;
          const ignoreUndefined = options.ignoreUndefined;
          for (let i = 0; i < value.length; ++i) {
            const item = path ? Reach(value[i], path) : value[i];
            const records = comparator ? found.custom : found[typeof item];
            Assert(records, "Failed to find unique map container for type", typeof item);
            if (records instanceof Map) {
              const entries = records.entries();
              let current;
              while (!(current = entries.next()).done) {
                if (compare(current.value[0], item)) {
                  const localState = state2.localize([...state2.path, i], [value, ...state2.ancestors]);
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: current.value[1],
                    dupeValue: value[current.value[1]]
                  };
                  if (path) {
                    context.path = raw;
                  }
                  return error2("array.unique", context, localState);
                }
              }
              records.set(item, i);
            } else {
              if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                const context = {
                  pos: i,
                  value: value[i],
                  dupePos: records[item],
                  dupeValue: value[records[item]]
                };
                if (path) {
                  context.path = raw;
                }
                const localState = state2.localize([...state2.path, i], [value, ...state2.ancestors]);
                return error2("array.unique", context, localState);
              }
              records[item] = i;
            }
          }
          return value;
        },
        args: ["comparator", "options"],
        multi: true
      }
    },
    cast: {
      set: {
        from: Array.isArray,
        to(value, helpers) {
          return new Set(value);
        }
      }
    },
    rebuild(schema) {
      schema.$_terms._inclusions = [];
      schema.$_terms._exclusions = [];
      schema.$_terms._requireds = [];
      for (const type2 of schema.$_terms.items) {
        internals.validateSingle(type2, schema);
        if (type2._flags.presence === "required") {
          schema.$_terms._requireds.push(type2);
        } else if (type2._flags.presence === "forbidden") {
          schema.$_terms._exclusions.push(type2);
        } else {
          schema.$_terms._inclusions.push(type2);
        }
      }
      for (const type2 of schema.$_terms.ordered) {
        internals.validateSingle(type2, schema);
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.items) {
          obj = obj.items(...desc.items);
        }
        if (desc.ordered) {
          obj = obj.ordered(...desc.ordered);
        }
        return obj;
      }
    },
    messages: {
      "array.base": "{{#label}} must be an array",
      "array.excludes": "{{#label}} contains an excluded value",
      "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
      "array.hasUnknown": "{{#label}} does not contain at least one required match",
      "array.includes": "{{#label}} does not match any of the allowed types",
      "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
      "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
      "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
      "array.length": "{{#label}} must contain {{#limit}} items",
      "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
      "array.min": "{{#label}} must contain at least {{#limit}} items",
      "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
      "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
      "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
      "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
      "array.sparse": "{{#label}} must not be a sparse array item",
      "array.unique": "{{#label}} contains a duplicate value"
    }
  });
  internals.fillMissedErrors = function(schema, errors2, requireds, value, state2, prefs) {
    const knownMisses = [];
    let unknownMisses = 0;
    for (const required of requireds) {
      const label = required._flags.label;
      if (label) {
        knownMisses.push(label);
      } else {
        ++unknownMisses;
      }
    }
    if (knownMisses.length) {
      if (unknownMisses) {
        errors2.push(schema.$_createError("array.includesRequiredBoth", value, { knownMisses, unknownMisses }, state2, prefs));
      } else {
        errors2.push(schema.$_createError("array.includesRequiredKnowns", value, { knownMisses }, state2, prefs));
      }
    } else {
      errors2.push(schema.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state2, prefs));
    }
  };
  internals.fillOrderedErrors = function(schema, errors2, ordereds, value, state2, prefs) {
    const requiredOrdereds = [];
    for (const ordered of ordereds) {
      if (ordered._flags.presence === "required") {
        requiredOrdereds.push(ordered);
      }
    }
    if (requiredOrdereds.length) {
      internals.fillMissedErrors(schema, errors2, requiredOrdereds, value, state2, prefs);
    }
  };
  internals.fillDefault = function(ordereds, value, state2, prefs) {
    const overrides = [];
    let trailingUndefined = true;
    for (let i = ordereds.length - 1; i >= 0; --i) {
      const ordered = ordereds[i];
      const ancestors = [value, ...state2.ancestors];
      const override = ordered.$_validate(void 0, state2.localize(state2.path, ancestors, ordered), prefs).value;
      if (trailingUndefined) {
        if (override === void 0) {
          continue;
        }
        trailingUndefined = false;
      }
      overrides.unshift(override);
    }
    if (overrides.length) {
      value.push(...overrides);
    }
  };
  internals.fastSplice = function(arr, i) {
    let pos = i;
    while (pos < arr.length) {
      arr[pos++] = arr[pos];
    }
    --arr.length;
  };
  internals.validateSingle = function(type2, obj) {
    if (type2.type === "array" || type2._flags._arrayItems) {
      Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
      obj.$_setFlag("_arrayItems", true, { clone: false });
    }
  };
  internals.sort = function(schema, value, settings, state2, prefs) {
    const order = settings.order === "ascending" ? 1 : -1;
    const aFirst = -1 * order;
    const bFirst = order;
    const sort = (a, b) => {
      let compare = internals.compare(a, b, aFirst, bFirst);
      if (compare !== null) {
        return compare;
      }
      if (settings.by) {
        a = settings.by.resolve(a, state2, prefs);
        b = settings.by.resolve(b, state2, prefs);
      }
      compare = internals.compare(a, b, aFirst, bFirst);
      if (compare !== null) {
        return compare;
      }
      const type2 = typeof a;
      if (type2 !== typeof b) {
        throw schema.$_createError("array.sort.mismatching", value, null, state2, prefs);
      }
      if (type2 !== "number" && type2 !== "string") {
        throw schema.$_createError("array.sort.unsupported", value, { type: type2 }, state2, prefs);
      }
      if (type2 === "number") {
        return (a - b) * order;
      }
      return a < b ? aFirst : bFirst;
    };
    try {
      return { value: value.slice().sort(sort) };
    } catch (err) {
      return { errors: err };
    }
  };
  internals.compare = function(a, b, aFirst, bFirst) {
    if (a === b) {
      return 0;
    }
    if (a === void 0) {
      return 1;
    }
    if (b === void 0) {
      return -1;
    }
    if (a === null) {
      return bFirst;
    }
    if (b === null) {
      return aFirst;
    }
    return null;
  };
  return array;
}
var boolean;
var hasRequiredBoolean;
function requireBoolean() {
  if (hasRequiredBoolean) return boolean;
  hasRequiredBoolean = 1;
  const Assert = requireAssert();
  const Any = requireAny();
  const Common = requireCommon$1();
  const Values = requireValues();
  const internals = {};
  internals.isBool = function(value) {
    return typeof value === "boolean";
  };
  boolean = Any.extend({
    type: "boolean",
    flags: {
      sensitive: { default: false }
    },
    terms: {
      falsy: {
        init: null,
        manifest: "values"
      },
      truthy: {
        init: null,
        manifest: "values"
      }
    },
    coerce(value, { schema }) {
      if (typeof value === "boolean") {
        return;
      }
      if (typeof value === "string") {
        const normalized = schema._flags.sensitive ? value : value.toLowerCase();
        value = normalized === "true" ? true : normalized === "false" ? false : value;
      }
      if (typeof value !== "boolean") {
        value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
      }
      return { value };
    },
    validate(value, { error: error2 }) {
      if (typeof value !== "boolean") {
        return { value, errors: error2("boolean.base") };
      }
    },
    rules: {
      truthy: {
        method(...values2) {
          Common.verifyFlat(values2, "truthy");
          const obj = this.clone();
          obj.$_terms.truthy = obj.$_terms.truthy || new Values();
          for (let i = 0; i < values2.length; ++i) {
            const value = values2[i];
            Assert(value !== void 0, "Cannot call truthy with undefined");
            obj.$_terms.truthy.add(value);
          }
          return obj;
        }
      },
      falsy: {
        method(...values2) {
          Common.verifyFlat(values2, "falsy");
          const obj = this.clone();
          obj.$_terms.falsy = obj.$_terms.falsy || new Values();
          for (let i = 0; i < values2.length; ++i) {
            const value = values2[i];
            Assert(value !== void 0, "Cannot call falsy with undefined");
            obj.$_terms.falsy.add(value);
          }
          return obj;
        }
      },
      sensitive: {
        method(enabled = true) {
          return this.$_setFlag("sensitive", enabled);
        }
      }
    },
    cast: {
      number: {
        from: internals.isBool,
        to(value, helpers) {
          return value ? 1 : 0;
        }
      },
      string: {
        from: internals.isBool,
        to(value, helpers) {
          return value ? "true" : "false";
        }
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.truthy) {
          obj = obj.truthy(...desc.truthy);
        }
        if (desc.falsy) {
          obj = obj.falsy(...desc.falsy);
        }
        return obj;
      }
    },
    messages: {
      "boolean.base": "{{#label}} must be a boolean"
    }
  });
  return boolean;
}
var date;
var hasRequiredDate;
function requireDate() {
  if (hasRequiredDate) return date;
  hasRequiredDate = 1;
  const Assert = requireAssert();
  const Any = requireAny();
  const Common = requireCommon$1();
  const Template = requireTemplate();
  const internals = {};
  internals.isDate = function(value) {
    return value instanceof Date;
  };
  date = Any.extend({
    type: "date",
    coerce: {
      from: ["number", "string"],
      method(value, { schema }) {
        return { value: internals.parse(value, schema._flags.format) || value };
      }
    },
    validate(value, { schema, error: error2, prefs }) {
      if (value instanceof Date && !isNaN(value.getTime())) {
        return;
      }
      const format = schema._flags.format;
      if (!prefs.convert || !format || typeof value !== "string") {
        return { value, errors: error2("date.base") };
      }
      return { value, errors: error2("date.format", { format }) };
    },
    rules: {
      compare: {
        method: false,
        validate(value, helpers, { date: date2 }, { name, operator, args: args2 }) {
          const to = date2 === "now" ? Date.now() : date2.getTime();
          if (Common.compare(value.getTime(), to, operator)) {
            return value;
          }
          return helpers.error("date." + name, { limit: args2.date, value });
        },
        args: [
          {
            name: "date",
            ref: true,
            normalize: (date2) => {
              return date2 === "now" ? date2 : internals.parse(date2);
            },
            assert: (date2) => date2 !== null,
            message: "must have a valid date format"
          }
        ]
      },
      format: {
        method(format) {
          Assert(["iso", "javascript", "unix"].includes(format), "Unknown date format", format);
          return this.$_setFlag("format", format);
        }
      },
      greater: {
        method(date2) {
          return this.$_addRule({ name: "greater", method: "compare", args: { date: date2 }, operator: ">" });
        }
      },
      iso: {
        method() {
          return this.format("iso");
        }
      },
      less: {
        method(date2) {
          return this.$_addRule({ name: "less", method: "compare", args: { date: date2 }, operator: "<" });
        }
      },
      max: {
        method(date2) {
          return this.$_addRule({ name: "max", method: "compare", args: { date: date2 }, operator: "<=" });
        }
      },
      min: {
        method(date2) {
          return this.$_addRule({ name: "min", method: "compare", args: { date: date2 }, operator: ">=" });
        }
      },
      timestamp: {
        method(type2 = "javascript") {
          Assert(["javascript", "unix"].includes(type2), '"type" must be one of "javascript, unix"');
          return this.format(type2);
        }
      }
    },
    cast: {
      number: {
        from: internals.isDate,
        to(value, helpers) {
          return value.getTime();
        }
      },
      string: {
        from: internals.isDate,
        to(value, { prefs }) {
          return Template.date(value, prefs);
        }
      }
    },
    messages: {
      "date.base": "{{#label}} must be a valid date",
      "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
      "date.greater": "{{#label}} must be greater than {{:#limit}}",
      "date.less": "{{#label}} must be less than {{:#limit}}",
      "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
      "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
      // Messages used in date.format
      "date.format.iso": "ISO 8601 date",
      "date.format.javascript": "timestamp or number of milliseconds",
      "date.format.unix": "timestamp or number of seconds"
    }
  });
  internals.parse = function(value, format) {
    if (value instanceof Date) {
      return value;
    }
    if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
      return null;
    }
    if (/^\s*$/.test(value)) {
      return null;
    }
    if (format === "iso") {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      return internals.date(value.toString());
    }
    const original = value;
    if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
      value = parseFloat(value);
    }
    if (format) {
      if (format === "javascript") {
        return internals.date(1 * value);
      }
      if (format === "unix") {
        return internals.date(1e3 * value);
      }
      if (typeof original === "string") {
        return null;
      }
    }
    return internals.date(value);
  };
  internals.date = function(value) {
    const date2 = new Date(value);
    if (!isNaN(date2.getTime())) {
      return date2;
    }
    return null;
  };
  return date;
}
var applyToDefaults;
var hasRequiredApplyToDefaults;
function requireApplyToDefaults() {
  if (hasRequiredApplyToDefaults) return applyToDefaults;
  hasRequiredApplyToDefaults = 1;
  const Assert = requireAssert();
  const Clone = requireClone();
  const Merge = requireMerge$2();
  const Reach = requireReach();
  const internals = {};
  applyToDefaults = function(defaults, source, options = {}) {
    Assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
    Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
    Assert(typeof options === "object", "Invalid options: must be an object");
    if (!source) {
      return null;
    }
    if (options.shallow) {
      return internals.applyToDefaultsWithShallow(defaults, source, options);
    }
    const copy = Clone(defaults);
    if (source === true) {
      return copy;
    }
    const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.applyToDefaultsWithShallow = function(defaults, source, options) {
    const keys2 = options.shallow;
    Assert(Array.isArray(keys2), "Invalid keys");
    const seen = /* @__PURE__ */ new Map();
    const merge2 = source === true ? null : /* @__PURE__ */ new Set();
    for (let key of keys2) {
      key = Array.isArray(key) ? key : key.split(".");
      const ref2 = Reach(defaults, key);
      if (ref2 && typeof ref2 === "object") {
        seen.set(ref2, merge2 && Reach(source, key) || ref2);
      } else if (merge2) {
        merge2.add(key);
      }
    }
    const copy = Clone(defaults, {}, seen);
    if (!merge2) {
      return copy;
    }
    for (const key of merge2) {
      internals.reachCopy(copy, source, key);
    }
    const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.reachCopy = function(dst, src2, path) {
    for (const segment of path) {
      if (!(segment in src2)) {
        return;
      }
      const val = src2[segment];
      if (typeof val !== "object" || val === null) {
        return;
      }
      src2 = val;
    }
    const value = src2;
    let ref2 = dst;
    for (let i = 0; i < path.length - 1; ++i) {
      const segment = path[i];
      if (typeof ref2[segment] !== "object") {
        ref2[segment] = {};
      }
      ref2 = ref2[segment];
    }
    ref2[path[path.length - 1]] = value;
  };
  return applyToDefaults;
}
var lib$1 = {};
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  const Assert = requireAssert();
  const internals = {};
  lib$1.Sorter = class {
    constructor() {
      this._items = [];
      this.nodes = [];
    }
    add(nodes, options) {
      options = options || {};
      const before = [].concat(options.before || []);
      const after = [].concat(options.after || []);
      const group = options.group || "?";
      const sort = options.sort || 0;
      Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
      Assert(!before.includes("?"), "Item cannot come before unassociated items");
      Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
      Assert(!after.includes("?"), "Item cannot come after unassociated items");
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (const node2 of nodes) {
        const item = {
          seq: this._items.length,
          sort,
          before,
          after,
          group,
          node: node2
        };
        this._items.push(item);
      }
      if (!options.manual) {
        const valid = this._sort();
        Assert(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
      }
      return this.nodes;
    }
    merge(others) {
      if (!Array.isArray(others)) {
        others = [others];
      }
      for (const other of others) {
        if (other) {
          for (const item of other._items) {
            this._items.push(Object.assign({}, item));
          }
        }
      }
      this._items.sort(internals.mergeSort);
      for (let i = 0; i < this._items.length; ++i) {
        this._items[i].seq = i;
      }
      const valid = this._sort();
      Assert(valid, "merge created a dependencies error");
      return this.nodes;
    }
    sort() {
      const valid = this._sort();
      Assert(valid, "sort created a dependencies error");
      return this.nodes;
    }
    _sort() {
      const graph = {};
      const graphAfters = /* @__PURE__ */ Object.create(null);
      const groups = /* @__PURE__ */ Object.create(null);
      for (const item of this._items) {
        const seq = item.seq;
        const group = item.group;
        groups[group] = groups[group] || [];
        groups[group].push(seq);
        graph[seq] = item.before;
        for (const after of item.after) {
          graphAfters[after] = graphAfters[after] || [];
          graphAfters[after].push(seq);
        }
      }
      for (const node2 in graph) {
        const expandedGroups = [];
        for (const graphNodeItem in graph[node2]) {
          const group = graph[node2][graphNodeItem];
          groups[group] = groups[group] || [];
          expandedGroups.push(...groups[group]);
        }
        graph[node2] = expandedGroups;
      }
      for (const group in graphAfters) {
        if (groups[group]) {
          for (const node2 of groups[group]) {
            graph[node2].push(...graphAfters[group]);
          }
        }
      }
      const ancestors = {};
      for (const node2 in graph) {
        const children = graph[node2];
        for (const child of children) {
          ancestors[child] = ancestors[child] || [];
          ancestors[child].push(node2);
        }
      }
      const visited = {};
      const sorted = [];
      for (let i = 0; i < this._items.length; ++i) {
        let next = i;
        if (ancestors[i]) {
          next = null;
          for (let j = 0; j < this._items.length; ++j) {
            if (visited[j] === true) {
              continue;
            }
            if (!ancestors[j]) {
              ancestors[j] = [];
            }
            const shouldSeeCount = ancestors[j].length;
            let seenCount = 0;
            for (let k = 0; k < shouldSeeCount; ++k) {
              if (visited[ancestors[j][k]]) {
                ++seenCount;
              }
            }
            if (seenCount === shouldSeeCount) {
              next = j;
              break;
            }
          }
        }
        if (next !== null) {
          visited[next] = true;
          sorted.push(next);
        }
      }
      if (sorted.length !== this._items.length) {
        return false;
      }
      const seqIndex = {};
      for (const item of this._items) {
        seqIndex[item.seq] = item;
      }
      this._items = [];
      this.nodes = [];
      for (const value of sorted) {
        const sortedItem = seqIndex[value];
        this.nodes.push(sortedItem.node);
        this._items.push(sortedItem);
      }
      return true;
    }
  };
  internals.mergeSort = (a, b) => {
    return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
  };
  return lib$1;
}
var keys;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys;
  hasRequiredKeys = 1;
  const ApplyToDefaults = requireApplyToDefaults();
  const Assert = requireAssert();
  const Clone = requireClone();
  const Topo = requireLib$1();
  const Any = requireAny();
  const Common = requireCommon$1();
  const Compile = requireCompile();
  const Errors = requireErrors$1();
  const Ref = requireRef$1();
  const Template = requireTemplate();
  const internals = {
    renameDefaults: {
      alias: false,
      // Keep old value in place
      multiple: false,
      // Allow renaming multiple keys into the same target
      override: false
      // Overrides an existing key
    }
  };
  keys = Any.extend({
    type: "_keys",
    properties: {
      typeof: "object"
    },
    flags: {
      unknown: { default: void 0 }
    },
    terms: {
      dependencies: { init: null },
      keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } },
      patterns: { init: null },
      renames: { init: null }
    },
    args(schema, keys2) {
      return schema.keys(keys2);
    },
    validate(value, { schema, error: error2, state: state2, prefs }) {
      if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
        return { value, errors: error2("object.base", { type: schema.$_property("typeof") }) };
      }
      if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys
      !schema.$_terms.patterns && !schema.$_terms.externals) {
        return;
      }
      value = internals.clone(value, prefs);
      const errors2 = [];
      if (schema.$_terms.renames && !internals.rename(schema, value, state2, prefs, errors2)) {
        return { value, errors: errors2 };
      }
      if (!schema.$_terms.keys && // null allows any keys
      !schema.$_terms.patterns && !schema.$_terms.dependencies) {
        return { value, errors: errors2 };
      }
      const unprocessed = new Set(Object.keys(value));
      if (schema.$_terms.keys) {
        const ancestors = [value, ...state2.ancestors];
        for (const child of schema.$_terms.keys) {
          const key = child.key;
          const item = value[key];
          unprocessed.delete(key);
          const localState = state2.localize([...state2.path, key], ancestors, child);
          const result = child.schema.$_validate(item, localState, prefs);
          if (result.errors) {
            if (prefs.abortEarly) {
              return { value, errors: result.errors };
            }
            if (result.value !== void 0) {
              value[key] = result.value;
            }
            errors2.push(...result.errors);
          } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
            delete value[key];
          } else if (result.value !== void 0) {
            value[key] = result.value;
          }
        }
      }
      if (unprocessed.size || schema._flags._hasPatternMatch) {
        const early = internals.unknown(schema, value, unprocessed, errors2, state2, prefs);
        if (early) {
          return early;
        }
      }
      if (schema.$_terms.dependencies) {
        for (const dep of schema.$_terms.dependencies) {
          if (dep.key !== null && internals.isPresent(dep.options)(dep.key.resolve(value, state2, prefs, null, { shadow: false })) === false) {
            continue;
          }
          const failed = internals.dependencies[dep.rel](schema, dep, value, state2, prefs);
          if (failed) {
            const report = schema.$_createError(failed.code, value, failed.context, state2, prefs);
            if (prefs.abortEarly) {
              return { value, errors: report };
            }
            errors2.push(report);
          }
        }
      }
      return { value, errors: errors2 };
    },
    rules: {
      and: {
        method(...peers) {
          Common.verifyFlat(peers, "and");
          return internals.dependency(this, "and", null, peers);
        }
      },
      append: {
        method(schema) {
          if (schema === null || schema === void 0 || Object.keys(schema).length === 0) {
            return this;
          }
          return this.keys(schema);
        }
      },
      assert: {
        method(subject, schema, message) {
          if (!Template.isTemplate(subject)) {
            subject = Compile.ref(subject);
          }
          Assert(message === void 0 || typeof message === "string", "Message must be a string");
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.$_addRule({ name: "assert", args: { subject, schema, message } });
          obj.$_mutateRegister(subject);
          obj.$_mutateRegister(schema);
          return obj;
        },
        validate(value, { error: error2, prefs, state: state2 }, { subject, schema, message }) {
          const about = subject.resolve(value, state2, prefs);
          const path = Ref.isRef(subject) ? subject.absolute(state2) : [];
          if (schema.$_match(about, state2.localize(path, [value, ...state2.ancestors], schema), prefs)) {
            return value;
          }
          return error2("object.assert", { subject, message });
        },
        args: ["subject", "schema", "message"],
        multi: true
      },
      instance: {
        method(constructor, name) {
          Assert(typeof constructor === "function", "constructor must be a function");
          name = name || constructor.name;
          return this.$_addRule({ name: "instance", args: { constructor, name } });
        },
        validate(value, helpers, { constructor, name }) {
          if (value instanceof constructor) {
            return value;
          }
          return helpers.error("object.instance", { type: name, value });
        },
        args: ["constructor", "name"]
      },
      keys: {
        method(schema) {
          Assert(schema === void 0 || typeof schema === "object", "Object schema must be a valid object");
          Assert(!Common.isSchema(schema), "Object schema cannot be a joi schema");
          const obj = this.clone();
          if (!schema) {
            obj.$_terms.keys = null;
          } else if (!Object.keys(schema).length) {
            obj.$_terms.keys = new internals.Keys();
          } else {
            obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();
            for (const key in schema) {
              Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
            }
          }
          return obj.$_mutateRebuild();
        }
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args: args2 }) {
          if (Common.compare(Object.keys(value).length, limit, operator)) {
            return value;
          }
          return helpers.error("object." + name, { limit: args2.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      },
      nand: {
        method(...peers) {
          Common.verifyFlat(peers, "nand");
          return internals.dependency(this, "nand", null, peers);
        }
      },
      or: {
        method(...peers) {
          Common.verifyFlat(peers, "or");
          return internals.dependency(this, "or", null, peers);
        }
      },
      oxor: {
        method(...peers) {
          return internals.dependency(this, "oxor", null, peers);
        }
      },
      pattern: {
        method(pattern, schema, options = {}) {
          const isRegExp = pattern instanceof RegExp;
          if (!isRegExp) {
            pattern = this.$_compile(pattern, { appendPath: true });
          }
          Assert(schema !== void 0, "Invalid rule");
          Common.assertOptions(options, ["fallthrough", "matches"]);
          if (isRegExp) {
            Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
          }
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.clone();
          obj.$_terms.patterns = obj.$_terms.patterns || [];
          const config2 = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema };
          if (options.matches) {
            config2.matches = this.$_compile(options.matches);
            if (config2.matches.type !== "array") {
              config2.matches = config2.matches.$_root.array().items(config2.matches);
            }
            obj.$_mutateRegister(config2.matches);
            obj.$_setFlag("_hasPatternMatch", true, { clone: false });
          }
          if (options.fallthrough) {
            config2.fallthrough = true;
          }
          obj.$_terms.patterns.push(config2);
          obj.$_mutateRegister(schema);
          return obj;
        }
      },
      ref: {
        method() {
          return this.$_addRule("ref");
        },
        validate(value, helpers) {
          if (Ref.isRef(value)) {
            return value;
          }
          return helpers.error("object.refType", { value });
        }
      },
      regex: {
        method() {
          return this.$_addRule("regex");
        },
        validate(value, helpers) {
          if (value instanceof RegExp) {
            return value;
          }
          return helpers.error("object.regex", { value });
        }
      },
      rename: {
        method(from2, to, options = {}) {
          Assert(typeof from2 === "string" || from2 instanceof RegExp, "Rename missing the from argument");
          Assert(typeof to === "string" || to instanceof Template, "Invalid rename to argument");
          Assert(to !== from2, "Cannot rename key to same name:", from2);
          Common.assertOptions(options, ["alias", "ignoreUndefined", "override", "multiple"]);
          const obj = this.clone();
          obj.$_terms.renames = obj.$_terms.renames || [];
          for (const rename of obj.$_terms.renames) {
            Assert(rename.from !== from2, "Cannot rename the same key multiple times");
          }
          if (to instanceof Template) {
            obj.$_mutateRegister(to);
          }
          obj.$_terms.renames.push({
            from: from2,
            to,
            options: ApplyToDefaults(internals.renameDefaults, options)
          });
          return obj;
        }
      },
      schema: {
        method(type2 = "any") {
          return this.$_addRule({ name: "schema", args: { type: type2 } });
        },
        validate(value, helpers, { type: type2 }) {
          if (Common.isSchema(value) && (type2 === "any" || value.type === type2)) {
            return value;
          }
          return helpers.error("object.schema", { type: type2 });
        }
      },
      unknown: {
        method(allow) {
          return this.$_setFlag("unknown", allow !== false);
        }
      },
      with: {
        method(key, peers, options = {}) {
          return internals.dependency(this, "with", key, peers, options);
        }
      },
      without: {
        method(key, peers, options = {}) {
          return internals.dependency(this, "without", key, peers, options);
        }
      },
      xor: {
        method(...peers) {
          Common.verifyFlat(peers, "xor");
          return internals.dependency(this, "xor", null, peers);
        }
      }
    },
    overrides: {
      default(value, options) {
        if (value === void 0) {
          value = Common.symbols.deepDefault;
        }
        return this.$_parent("default", value, options);
      }
    },
    rebuild(schema) {
      if (schema.$_terms.keys) {
        const topo = new Topo.Sorter();
        for (const child of schema.$_terms.keys) {
          Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
        }
        schema.$_terms.keys = new internals.Keys(...topo.nodes);
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.keys) {
          obj = obj.keys(desc.keys);
        }
        if (desc.dependencies) {
          for (const { rel, key = null, peers, options } of desc.dependencies) {
            obj = internals.dependency(obj, rel, key, peers, options);
          }
        }
        if (desc.patterns) {
          for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
            obj = obj.pattern(regex || schema, rule, { fallthrough, matches });
          }
        }
        if (desc.renames) {
          for (const { from: from2, to, options } of desc.renames) {
            obj = obj.rename(from2, to, options);
          }
        }
        return obj;
      }
    },
    messages: {
      "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
      "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
      "object.base": "{{#label}} must be of type {{#type}}",
      "object.instance": "{{#label}} must be an instance of {{:#type}}",
      "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
      "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
      "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
      "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
      "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
      "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
      "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
      "object.refType": "{{#label}} must be a Joi reference",
      "object.regex": "{{#label}} must be a RegExp object",
      "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
      "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
      "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
      "object.unknown": "{{#label}} is not allowed",
      "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
      "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
      "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
    }
  });
  internals.clone = function(value, prefs) {
    if (typeof value === "object") {
      if (prefs.nonEnumerables) {
        return Clone(value, { shallow: true });
      }
      const clone3 = Object.create(Object.getPrototypeOf(value));
      Object.assign(clone3, value);
      return clone3;
    }
    const clone2 = function(...args2) {
      return value.apply(this, args2);
    };
    clone2.prototype = Clone(value.prototype);
    Object.defineProperty(clone2, "name", { value: value.name, writable: false });
    Object.defineProperty(clone2, "length", { value: value.length, writable: false });
    Object.assign(clone2, value);
    return clone2;
  };
  internals.dependency = function(schema, rel, key, peers, options) {
    Assert(key === null || typeof key === "string", rel, "key must be a strings");
    if (!options) {
      options = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
    }
    Common.assertOptions(options, ["separator", "isPresent"]);
    peers = [].concat(peers);
    const separator = Common.default(options.separator, ".");
    const paths = [];
    for (const peer of peers) {
      Assert(typeof peer === "string", rel, "peers must be strings");
      paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
    }
    if (key !== null) {
      key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
    }
    const obj = schema.clone();
    obj.$_terms.dependencies = obj.$_terms.dependencies || [];
    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options));
    return obj;
  };
  internals.dependencies = {
    and(schema, dep, value, state2, prefs) {
      const missing = [];
      const present = [];
      const count2 = dep.peers.length;
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state2, prefs, null, { shadow: false })) === false) {
          missing.push(peer.key);
        } else {
          present.push(peer.key);
        }
      }
      if (missing.length !== count2 && present.length !== count2) {
        return {
          code: "object.and",
          context: {
            present,
            presentWithLabels: internals.keysToLabels(schema, present),
            missing,
            missingWithLabels: internals.keysToLabels(schema, missing)
          }
        };
      }
    },
    nand(schema, dep, value, state2, prefs) {
      const present = [];
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state2, prefs, null, { shadow: false }))) {
          present.push(peer.key);
        }
      }
      if (present.length !== dep.peers.length) {
        return;
      }
      const main = dep.paths[0];
      const values2 = dep.paths.slice(1);
      return {
        code: "object.nand",
        context: {
          main,
          mainWithLabel: internals.keysToLabels(schema, main),
          peers: values2,
          peersWithLabels: internals.keysToLabels(schema, values2)
        }
      };
    },
    or(schema, dep, value, state2, prefs) {
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state2, prefs, null, { shadow: false }))) {
          return;
        }
      }
      return {
        code: "object.missing",
        context: {
          peers: dep.paths,
          peersWithLabels: internals.keysToLabels(schema, dep.paths)
        }
      };
    },
    oxor(schema, dep, value, state2, prefs) {
      const present = [];
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state2, prefs, null, { shadow: false }))) {
          present.push(peer.key);
        }
      }
      if (!present.length || present.length === 1) {
        return;
      }
      const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
      context.present = present;
      context.presentWithLabels = internals.keysToLabels(schema, present);
      return { code: "object.oxor", context };
    },
    with(schema, dep, value, state2, prefs) {
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state2, prefs, null, { shadow: false })) === false) {
          return {
            code: "object.with",
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    },
    without(schema, dep, value, state2, prefs) {
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state2, prefs, null, { shadow: false }))) {
          return {
            code: "object.without",
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    },
    xor(schema, dep, value, state2, prefs) {
      const present = [];
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state2, prefs, null, { shadow: false }))) {
          present.push(peer.key);
        }
      }
      if (present.length === 1) {
        return;
      }
      const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
      if (present.length === 0) {
        return { code: "object.missing", context };
      }
      context.present = present;
      context.presentWithLabels = internals.keysToLabels(schema, present);
      return { code: "object.xor", context };
    }
  };
  internals.keysToLabels = function(schema, keys2) {
    if (Array.isArray(keys2)) {
      return keys2.map((key) => schema.$_mapLabels(key));
    }
    return schema.$_mapLabels(keys2);
  };
  internals.isPresent = function(options) {
    return typeof options.isPresent === "function" ? options.isPresent : (resolved) => resolved !== void 0;
  };
  internals.rename = function(schema, value, state2, prefs, errors2) {
    const renamed = {};
    for (const rename of schema.$_terms.renames) {
      const matches = [];
      const pattern = typeof rename.from !== "string";
      if (!pattern) {
        if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
          matches.push(rename);
        }
      } else {
        for (const from2 in value) {
          if (value[from2] === void 0 && rename.options.ignoreUndefined) {
            continue;
          }
          if (from2 === rename.to) {
            continue;
          }
          const match = rename.from.exec(from2);
          if (!match) {
            continue;
          }
          matches.push({ from: from2, to: rename.to, match });
        }
      }
      for (const match of matches) {
        const from2 = match.from;
        let to = match.to;
        if (to instanceof Template) {
          to = to.render(value, state2, prefs, match.match);
        }
        if (from2 === to) {
          continue;
        }
        if (!rename.options.multiple && renamed[to]) {
          errors2.push(schema.$_createError("object.rename.multiple", value, { from: from2, to, pattern }, state2, prefs));
          if (prefs.abortEarly) {
            return false;
          }
        }
        if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
          errors2.push(schema.$_createError("object.rename.override", value, { from: from2, to, pattern }, state2, prefs));
          if (prefs.abortEarly) {
            return false;
          }
        }
        if (value[from2] === void 0) {
          delete value[to];
        } else {
          value[to] = value[from2];
        }
        renamed[to] = true;
        if (!rename.options.alias) {
          delete value[from2];
        }
      }
    }
    return true;
  };
  internals.unknown = function(schema, value, unprocessed, errors2, state2, prefs) {
    if (schema.$_terms.patterns) {
      let hasMatches = false;
      const matches = schema.$_terms.patterns.map((pattern) => {
        if (pattern.matches) {
          hasMatches = true;
          return [];
        }
      });
      const ancestors = [value, ...state2.ancestors];
      for (const key of unprocessed) {
        const item = value[key];
        const path = [...state2.path, key];
        for (let i = 0; i < schema.$_terms.patterns.length; ++i) {
          const pattern = schema.$_terms.patterns[i];
          if (pattern.regex) {
            const match = pattern.regex.test(key);
            state2.mainstay.tracer.debug(state2, "rule", `pattern.${i}`, match ? "pass" : "error");
            if (!match) {
              continue;
            }
          } else {
            if (!pattern.schema.$_match(key, state2.nest(pattern.schema, `pattern.${i}`), prefs)) {
              continue;
            }
          }
          unprocessed.delete(key);
          const localState = state2.localize(path, ancestors, { schema: pattern.rule, key });
          const result = pattern.rule.$_validate(item, localState, prefs);
          if (result.errors) {
            if (prefs.abortEarly) {
              return { value, errors: result.errors };
            }
            errors2.push(...result.errors);
          }
          if (pattern.matches) {
            matches[i].push(key);
          }
          value[key] = result.value;
          if (!pattern.fallthrough) {
            break;
          }
        }
      }
      if (hasMatches) {
        for (let i = 0; i < matches.length; ++i) {
          const match = matches[i];
          if (!match) {
            continue;
          }
          const stpm = schema.$_terms.patterns[i].matches;
          const localState = state2.localize(state2.path, ancestors, stpm);
          const result = stpm.$_validate(match, localState, prefs);
          if (result.errors) {
            const details = Errors.details(result.errors, { override: false });
            details.matches = match;
            const report = schema.$_createError("object.pattern.match", value, details, state2, prefs);
            if (prefs.abortEarly) {
              return { value, errors: report };
            }
            errors2.push(report);
          }
        }
      }
    }
    if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
      return;
    }
    if (prefs.stripUnknown && typeof schema._flags.unknown === "undefined" || prefs.skipFunctions) {
      const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
      for (const key of unprocessed) {
        if (stripUnknown) {
          delete value[key];
          unprocessed.delete(key);
        } else if (typeof value[key] === "function") {
          unprocessed.delete(key);
        }
      }
    }
    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
    if (forbidUnknown) {
      for (const unprocessedKey of unprocessed) {
        const localState = state2.localize([...state2.path, unprocessedKey], []);
        const report = schema.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
        if (prefs.abortEarly) {
          return { value, errors: report };
        }
        errors2.push(report);
      }
    }
  };
  internals.Dependency = class {
    constructor(rel, key, peers, paths, options) {
      this.rel = rel;
      this.key = key;
      this.peers = peers;
      this.paths = paths;
      this.options = options;
    }
    describe() {
      const desc = {
        rel: this.rel,
        peers: this.paths
      };
      if (this.key !== null) {
        desc.key = this.key.key;
      }
      if (this.peers[0].separator !== ".") {
        desc.options = { ...desc.options, separator: this.peers[0].separator };
      }
      if (this.options.isPresent) {
        desc.options = { ...desc.options, isPresent: this.options.isPresent };
      }
      return desc;
    }
  };
  internals.Keys = class extends Array {
    concat(source) {
      const result = this.slice();
      const keys2 = /* @__PURE__ */ new Map();
      for (let i = 0; i < result.length; ++i) {
        keys2.set(result[i].key, i);
      }
      for (const item of source) {
        const key = item.key;
        const pos = keys2.get(key);
        if (pos !== void 0) {
          result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
        } else {
          result.push(item);
        }
      }
      return result;
    }
  };
  return keys;
}
var _function;
var hasRequired_function;
function require_function() {
  if (hasRequired_function) return _function;
  hasRequired_function = 1;
  const Assert = requireAssert();
  const Keys = requireKeys();
  _function = Keys.extend({
    type: "function",
    properties: {
      typeof: "function"
    },
    rules: {
      arity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
          return this.$_addRule({ name: "arity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length === n) {
            return value;
          }
          return helpers.error("function.arity", { n });
        }
      },
      class: {
        method() {
          return this.$_addRule("class");
        },
        validate(value, helpers) {
          if (/^\s*class\s/.test(value.toString())) {
            return value;
          }
          return helpers.error("function.class", { value });
        }
      },
      minArity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
          return this.$_addRule({ name: "minArity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length >= n) {
            return value;
          }
          return helpers.error("function.minArity", { n });
        }
      },
      maxArity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
          return this.$_addRule({ name: "maxArity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length <= n) {
            return value;
          }
          return helpers.error("function.maxArity", { n });
        }
      }
    },
    messages: {
      "function.arity": "{{#label}} must have an arity of {{#n}}",
      "function.class": "{{#label}} must be a class",
      "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
      "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
    }
  });
  return _function;
}
var link;
var hasRequiredLink;
function requireLink() {
  if (hasRequiredLink) return link;
  hasRequiredLink = 1;
  const Assert = requireAssert();
  const Any = requireAny();
  const Common = requireCommon$1();
  const Compile = requireCompile();
  const Errors = requireErrors$1();
  const internals = {};
  link = Any.extend({
    type: "link",
    properties: {
      schemaChain: true
    },
    terms: {
      link: { init: null, manifest: "single", register: false }
    },
    args(schema, ref2) {
      return schema.ref(ref2);
    },
    validate(value, { schema, state: state2, prefs }) {
      Assert(schema.$_terms.link, "Uninitialized link schema");
      const linked = internals.generate(schema, value, state2, prefs);
      const ref2 = schema.$_terms.link[0].ref;
      return linked.$_validate(value, state2.nest(linked, `link:${ref2.display}:${linked.type}`), prefs);
    },
    generate(schema, value, state2, prefs) {
      return internals.generate(schema, value, state2, prefs);
    },
    rules: {
      ref: {
        method(ref2) {
          Assert(!this.$_terms.link, "Cannot reinitialize schema");
          ref2 = Compile.ref(ref2);
          Assert(ref2.type === "value" || ref2.type === "local", "Invalid reference type:", ref2.type);
          Assert(ref2.type === "local" || ref2.ancestor === "root" || ref2.ancestor > 0, "Link cannot reference itself");
          const obj = this.clone();
          obj.$_terms.link = [{ ref: ref2 }];
          return obj;
        }
      },
      relative: {
        method(enabled = true) {
          return this.$_setFlag("relative", enabled);
        }
      }
    },
    overrides: {
      concat(source) {
        Assert(this.$_terms.link, "Uninitialized link schema");
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(source.type !== "link", "Cannot merge type link with another link");
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        obj.$_terms.whens.push({ concat: source });
        return obj.$_mutateRebuild();
      }
    },
    manifest: {
      build(obj, desc) {
        Assert(desc.link, "Invalid link description missing link");
        return obj.ref(desc.link);
      }
    }
  });
  internals.generate = function(schema, value, state2, prefs) {
    let linked = state2.mainstay.links.get(schema);
    if (linked) {
      return linked._generate(value, state2, prefs).schema;
    }
    const ref2 = schema.$_terms.link[0].ref;
    const { perspective, path } = internals.perspective(ref2, state2);
    internals.assert(perspective, "which is outside of schema boundaries", ref2, schema, state2, prefs);
    try {
      linked = path.length ? perspective.$_reach(path) : perspective;
    } catch (ignoreErr) {
      internals.assert(false, "to non-existing schema", ref2, schema, state2, prefs);
    }
    internals.assert(linked.type !== "link", "which is another link", ref2, schema, state2, prefs);
    if (!schema._flags.relative) {
      state2.mainstay.links.set(schema, linked);
    }
    return linked._generate(value, state2, prefs).schema;
  };
  internals.perspective = function(ref2, state2) {
    if (ref2.type === "local") {
      for (const { schema, key } of state2.schemas) {
        const id = schema._flags.id || key;
        if (id === ref2.path[0]) {
          return { perspective: schema, path: ref2.path.slice(1) };
        }
        if (schema.$_terms.shared) {
          for (const shared of schema.$_terms.shared) {
            if (shared._flags.id === ref2.path[0]) {
              return { perspective: shared, path: ref2.path.slice(1) };
            }
          }
        }
      }
      return { perspective: null, path: null };
    }
    if (ref2.ancestor === "root") {
      return { perspective: state2.schemas[state2.schemas.length - 1].schema, path: ref2.path };
    }
    return { perspective: state2.schemas[ref2.ancestor] && state2.schemas[ref2.ancestor].schema, path: ref2.path };
  };
  internals.assert = function(condition, message, ref2, schema, state2, prefs) {
    if (condition) {
      return;
    }
    Assert(false, `"${Errors.label(schema._flags, state2, prefs)}" contains link reference "${ref2.display}" ${message}`);
  };
  return link;
}
var number;
var hasRequiredNumber;
function requireNumber() {
  if (hasRequiredNumber) return number;
  hasRequiredNumber = 1;
  const Assert = requireAssert();
  const Any = requireAny();
  const Common = requireCommon$1();
  const internals = {
    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
    exponentialPartRegex: /[eE][+-]?\d+$/,
    leadingSignAndZerosRegex: /^[+-]?(0*)?/,
    dotRegex: /\./,
    trailingZerosRegex: /0+$/,
    decimalPlaces(value) {
      const str = value.toString();
      const dindex = str.indexOf(".");
      const eindex = str.indexOf("e");
      return (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) + (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))));
    }
  };
  number = Any.extend({
    type: "number",
    flags: {
      unsafe: { default: false }
    },
    coerce: {
      from: "string",
      method(value, { schema, error: error2 }) {
        const matches = value.match(internals.numberRx);
        if (!matches) {
          return;
        }
        value = value.trim();
        const result = { value: parseFloat(value) };
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe) {
          if (value.match(/e/i)) {
            if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {
              result.errors = error2("number.unsafe");
              return result;
            }
          } else {
            const string2 = result.value.toString();
            if (string2.match(/e/i)) {
              return result;
            }
            if (string2 !== internals.normalizeDecimal(value)) {
              result.errors = error2("number.unsafe");
              return result;
            }
          }
        }
        return result;
      }
    },
    validate(value, { schema, error: error2, prefs }) {
      if (value === Infinity || value === -Infinity) {
        return { value, errors: error2("number.infinity") };
      }
      if (!Common.isNumber(value)) {
        return { value, errors: error2("number.base") };
      }
      const result = { value };
      if (prefs.convert) {
        const rule = schema.$_getRule("precision");
        if (rule) {
          const precision = Math.pow(10, rule.args.limit);
          result.value = Math.round(result.value * precision) / precision;
        }
      }
      if (result.value === 0) {
        result.value = 0;
      }
      if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
        result.errors = error2("number.unsafe");
      }
      return result;
    },
    rules: {
      compare: {
        method: false,
        validate(value, helpers, { limit }, { name, operator, args: args2 }) {
          if (Common.compare(value, limit, operator)) {
            return value;
          }
          return helpers.error("number." + name, { limit: args2.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.isNumber,
            message: "must be a number"
          }
        ]
      },
      greater: {
        method(limit) {
          return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
        }
      },
      integer: {
        method() {
          return this.$_addRule("integer");
        },
        validate(value, helpers) {
          if (Math.trunc(value) - value === 0) {
            return value;
          }
          return helpers.error("number.integer");
        }
      },
      less: {
        method(limit) {
          return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
        }
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
        }
      },
      multiple: {
        method(base2) {
          const baseDecimalPlace = typeof base2 === "number" ? internals.decimalPlaces(base2) : null;
          const pfactor = Math.pow(10, baseDecimalPlace);
          return this.$_addRule({
            name: "multiple",
            args: {
              base: base2,
              baseDecimalPlace,
              pfactor
            }
          });
        },
        validate(value, helpers, { base: base2, baseDecimalPlace, pfactor }, options) {
          const valueDecimalPlace = internals.decimalPlaces(value);
          if (valueDecimalPlace > baseDecimalPlace) {
            return helpers.error("number.multiple", { multiple: options.args.base, value });
          }
          return Math.round(pfactor * value) % Math.round(pfactor * base2) === 0 ? value : helpers.error("number.multiple", { multiple: options.args.base, value });
        },
        args: [
          {
            name: "base",
            ref: true,
            assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
            message: "must be a positive number"
          },
          "baseDecimalPlace",
          "pfactor"
        ],
        multi: true
      },
      negative: {
        method() {
          return this.sign("negative");
        }
      },
      port: {
        method() {
          return this.$_addRule("port");
        },
        validate(value, helpers) {
          if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
            return value;
          }
          return helpers.error("number.port");
        }
      },
      positive: {
        method() {
          return this.sign("positive");
        }
      },
      precision: {
        method(limit) {
          Assert(Number.isSafeInteger(limit), "limit must be an integer");
          return this.$_addRule({ name: "precision", args: { limit } });
        },
        validate(value, helpers, { limit }) {
          const places = value.toString().match(internals.precisionRx);
          const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
          if (decimals <= limit) {
            return value;
          }
          return helpers.error("number.precision", { limit, value });
        },
        convert: true
      },
      sign: {
        method(sign2) {
          Assert(["negative", "positive"].includes(sign2), "Invalid sign", sign2);
          return this.$_addRule({ name: "sign", args: { sign: sign2 } });
        },
        validate(value, helpers, { sign: sign2 }) {
          if (sign2 === "negative" && value < 0 || sign2 === "positive" && value > 0) {
            return value;
          }
          return helpers.error(`number.${sign2}`);
        }
      },
      unsafe: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_setFlag("unsafe", enabled);
        }
      }
    },
    cast: {
      string: {
        from: (value) => typeof value === "number",
        to(value, helpers) {
          return value.toString();
        }
      }
    },
    messages: {
      "number.base": "{{#label}} must be a number",
      "number.greater": "{{#label}} must be greater than {{#limit}}",
      "number.infinity": "{{#label}} cannot be infinity",
      "number.integer": "{{#label}} must be an integer",
      "number.less": "{{#label}} must be less than {{#limit}}",
      "number.max": "{{#label}} must be less than or equal to {{#limit}}",
      "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
      "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
      "number.negative": "{{#label}} must be a negative number",
      "number.port": "{{#label}} must be a valid port",
      "number.positive": "{{#label}} must be a positive number",
      "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
      "number.unsafe": "{{#label}} must be a safe number"
    }
  });
  internals.extractSignificantDigits = function(value) {
    return value.replace(internals.exponentialPartRegex, "").replace(internals.dotRegex, "").replace(internals.trailingZerosRegex, "").replace(internals.leadingSignAndZerosRegex, "");
  };
  internals.normalizeDecimal = function(str) {
    str = str.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2");
    if (str.includes(".") && str.endsWith("0")) {
      str = str.replace(/0+$/, "");
    }
    if (str === "-0") {
      return "0";
    }
    return str;
  };
  return number;
}
var object;
var hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  hasRequiredObject = 1;
  const Keys = requireKeys();
  object = Keys.extend({
    type: "object",
    cast: {
      map: {
        from: (value) => value && typeof value === "object",
        to(value, helpers) {
          return new Map(Object.entries(value));
        }
      }
    }
  });
  return object;
}
var domain = {};
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  (function(exports2) {
    exports2.codes = {
      EMPTY_STRING: "Address must be a non-empty string",
      FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
      MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
      MISSING_AT_CHAR: "Address must contain one @ character",
      EMPTY_LOCAL: "Address local part cannot be empty",
      ADDRESS_TOO_LONG: "Address too long",
      LOCAL_TOO_LONG: "Address local part too long",
      EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
      INVALID_LOCAL_CHARS: "Address local part contains invalid character",
      DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
      DOMAIN_TOO_LONG: "Domain too long",
      DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
      DOMAIN_INVALID_CHARS: "Domain contains invalid character",
      DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
      DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
      DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
      DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
      DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
      DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
    };
    exports2.code = function(code) {
      return { code, error: exports2.codes[code] };
    };
  })(errors);
  return errors;
}
var hasRequiredDomain;
function requireDomain() {
  if (hasRequiredDomain) return domain;
  hasRequiredDomain = 1;
  (function(exports2) {
    const Url = require$$0$1;
    const Errors = requireErrors();
    const internals = {
      minDomainSegments: 2,
      nonAsciiRx: /[^\x00-\x7f]/,
      domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
      // Control + space + separators
      tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      URL: Url.URL || URL
      // $lab:coverage:ignore$
    };
    exports2.analyze = function(domain2, options = {}) {
      if (!domain2) {
        return Errors.code("DOMAIN_NON_EMPTY_STRING");
      }
      if (typeof domain2 !== "string") {
        throw new Error("Invalid input: domain must be a string");
      }
      if (domain2.length > 256) {
        return Errors.code("DOMAIN_TOO_LONG");
      }
      const ascii = !internals.nonAsciiRx.test(domain2);
      if (!ascii) {
        if (options.allowUnicode === false) {
          return Errors.code("DOMAIN_INVALID_UNICODE_CHARS");
        }
        domain2 = domain2.normalize("NFC");
      }
      if (internals.domainControlRx.test(domain2)) {
        return Errors.code("DOMAIN_INVALID_CHARS");
      }
      domain2 = internals.punycode(domain2);
      if (options.allowFullyQualified && domain2[domain2.length - 1] === ".") {
        domain2 = domain2.slice(0, -1);
      }
      const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;
      const segments = domain2.split(".");
      if (segments.length < minDomainSegments) {
        return Errors.code("DOMAIN_SEGMENTS_COUNT");
      }
      if (options.maxDomainSegments) {
        if (segments.length > options.maxDomainSegments) {
          return Errors.code("DOMAIN_SEGMENTS_COUNT_MAX");
        }
      }
      const tlds2 = options.tlds;
      if (tlds2) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (tlds2.deny && tlds2.deny.has(tld) || tlds2.allow && !tlds2.allow.has(tld)) {
          return Errors.code("DOMAIN_FORBIDDEN_TLDS");
        }
      }
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (!segment.length) {
          return Errors.code("DOMAIN_EMPTY_SEGMENT");
        }
        if (segment.length > 63) {
          return Errors.code("DOMAIN_LONG_SEGMENT");
        }
        if (i < segments.length - 1) {
          if (!internals.domainSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_CHARS");
          }
        } else {
          if (!internals.tldSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_TLDS_CHARS");
          }
        }
      }
      return null;
    };
    exports2.isValid = function(domain2, options) {
      return !exports2.analyze(domain2, options);
    };
    internals.punycode = function(domain2) {
      if (domain2.includes("%")) {
        domain2 = domain2.replace(/%/g, "%25");
      }
      try {
        return new internals.URL(`http://${domain2}`).host;
      } catch (err) {
        return domain2;
      }
    };
  })(domain);
  return domain;
}
var email = {};
var hasRequiredEmail;
function requireEmail() {
  if (hasRequiredEmail) return email;
  hasRequiredEmail = 1;
  const Util = require$$1;
  const Domain = requireDomain();
  const Errors = requireErrors();
  const internals = {
    nonAsciiRx: /[^\x00-\x7f]/,
    encoder: new (Util.TextEncoder || TextEncoder)()
    // $lab:coverage:ignore$
  };
  email.analyze = function(email2, options) {
    return internals.email(email2, options);
  };
  email.isValid = function(email2, options) {
    return !internals.email(email2, options);
  };
  internals.email = function(email2, options = {}) {
    if (typeof email2 !== "string") {
      throw new Error("Invalid input: email must be a string");
    }
    if (!email2) {
      return Errors.code("EMPTY_STRING");
    }
    const ascii = !internals.nonAsciiRx.test(email2);
    if (!ascii) {
      if (options.allowUnicode === false) {
        return Errors.code("FORBIDDEN_UNICODE");
      }
      email2 = email2.normalize("NFC");
    }
    const parts = email2.split("@");
    if (parts.length !== 2) {
      return parts.length > 2 ? Errors.code("MULTIPLE_AT_CHAR") : Errors.code("MISSING_AT_CHAR");
    }
    const [local, domain2] = parts;
    if (!local) {
      return Errors.code("EMPTY_LOCAL");
    }
    if (!options.ignoreLength) {
      if (email2.length > 254) {
        return Errors.code("ADDRESS_TOO_LONG");
      }
      if (internals.encoder.encode(local).length > 64) {
        return Errors.code("LOCAL_TOO_LONG");
      }
    }
    return internals.local(local, ascii) || Domain.analyze(domain2, options);
  };
  internals.local = function(local, ascii) {
    const segments = local.split(".");
    for (const segment of segments) {
      if (!segment.length) {
        return Errors.code("EMPTY_LOCAL_SEGMENT");
      }
      if (ascii) {
        if (!internals.atextRx.test(segment)) {
          return Errors.code("INVALID_LOCAL_CHARS");
        }
        continue;
      }
      for (const char of segment) {
        if (internals.atextRx.test(char)) {
          continue;
        }
        const binary2 = internals.binary(char);
        if (!internals.atomRx.test(binary2)) {
          return Errors.code("INVALID_LOCAL_CHARS");
        }
      }
    }
  };
  internals.binary = function(char) {
    return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join("");
  };
  internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;
  internals.atomRx = new RegExp([
    //  %xC2-DF UTF8-tail
    "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
    //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
    "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
    //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
    "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"
  ].join("|"));
  return email;
}
var ip = {};
var uri$1 = {};
var escapeRegex;
var hasRequiredEscapeRegex;
function requireEscapeRegex() {
  if (hasRequiredEscapeRegex) return escapeRegex;
  hasRequiredEscapeRegex = 1;
  escapeRegex = function(string2) {
    return string2.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
  };
  return escapeRegex;
}
var hasRequiredUri$1;
function requireUri$1() {
  if (hasRequiredUri$1) return uri$1;
  hasRequiredUri$1 = 1;
  const Assert = requireAssert();
  const EscapeRegex = requireEscapeRegex();
  const internals = {};
  internals.generate = function() {
    const rfc3986 = {};
    const hexDigit = "\\dA-Fa-f";
    const hexDigitOnly = "[" + hexDigit + "]";
    const unreserved = "\\w-\\.~";
    const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
    const pctEncoded = "%" + hexDigit;
    const pchar = unreserved + pctEncoded + subDelims + ":@";
    const pcharOnly = "[" + pchar + "]";
    const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
    rfc3986.ipv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
    const h16 = hexDigitOnly + "{1,4}";
    const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4address + ")";
    const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
    const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
    const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
    const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
    const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
    const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
    const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
    const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
    const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
    rfc3986.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
    rfc3986.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
    rfc3986.ipv6address = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
    rfc3986.ipvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
    rfc3986.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*";
    rfc3986.schemeRegex = new RegExp(rfc3986.scheme);
    const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
    const IPLiteral = "\\[(?:" + rfc3986.ipv6address + "|" + rfc3986.ipvFuture + ")\\]";
    const regName = "[" + unreserved + pctEncoded + subDelims + "]{1,255}";
    const host = "(?:" + IPLiteral + "|" + rfc3986.ipv4address + "|" + regName + ")";
    const port = "\\d*";
    const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
    const authorityCapture = "(?:" + userinfo + "@)?(" + host + ")(?::" + port + ")?";
    const segment = pcharOnly + "*";
    const segmentNz = pcharOnly + "+";
    const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
    const pathEmpty = "";
    const pathAbEmpty = "(?:\\/" + segment + ")*";
    const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;
    const pathAbNoAuthority = "(?:\\/\\/\\/" + segment + pathAbEmpty + ")";
    rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + "|" + pathAbNoAuthority + ")";
    rfc3986.hierPartCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + ")";
    rfc3986.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
    rfc3986.relativeRefCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
    rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
    rfc3986.queryWithSquareBrackets = "[" + pchar + "\\[\\]\\/\\?]*(?=#|$)";
    rfc3986.fragment = "[" + pchar + "\\/\\?]*";
    return rfc3986;
  };
  internals.rfc3986 = internals.generate();
  uri$1.ip = {
    v4Cidr: internals.rfc3986.ipv4Cidr,
    v6Cidr: internals.rfc3986.ipv6Cidr,
    ipv4: internals.rfc3986.ipv4address,
    ipv6: internals.rfc3986.ipv6address,
    ipvfuture: internals.rfc3986.ipvFuture
  };
  internals.createRegex = function(options) {
    const rfc = internals.rfc3986;
    const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
    const suffix = "(?:\\?" + query + ")?(?:#" + rfc.fragment + ")?";
    const relative = options.domain ? rfc.relativeRefCapture : rfc.relativeRef;
    if (options.relativeOnly) {
      return internals.wrap(relative + suffix);
    }
    let customScheme = "";
    if (options.scheme) {
      Assert(options.scheme instanceof RegExp || typeof options.scheme === "string" || Array.isArray(options.scheme), "scheme must be a RegExp, String, or Array");
      const schemes = [].concat(options.scheme);
      Assert(schemes.length >= 1, "scheme must have at least 1 scheme specified");
      const selections = [];
      for (let i = 0; i < schemes.length; ++i) {
        const scheme2 = schemes[i];
        Assert(scheme2 instanceof RegExp || typeof scheme2 === "string", "scheme at position " + i + " must be a RegExp or String");
        if (scheme2 instanceof RegExp) {
          selections.push(scheme2.source.toString());
        } else {
          Assert(rfc.schemeRegex.test(scheme2), "scheme at position " + i + " must be a valid scheme");
          selections.push(EscapeRegex(scheme2));
        }
      }
      customScheme = selections.join("|");
    }
    const scheme = customScheme ? "(?:" + customScheme + ")" : rfc.scheme;
    const absolute = "(?:" + scheme + ":" + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ")";
    const prefix = options.allowRelative ? "(?:" + absolute + "|" + relative + ")" : absolute;
    return internals.wrap(prefix + suffix, customScheme);
  };
  internals.wrap = function(raw, scheme) {
    raw = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${raw}`;
    return {
      raw,
      regex: new RegExp(`^${raw}$`),
      scheme
    };
  };
  internals.uriRegex = internals.createRegex({});
  uri$1.regex = function(options = {}) {
    if (options.scheme || options.allowRelative || options.relativeOnly || options.allowQuerySquareBrackets || options.domain) {
      return internals.createRegex(options);
    }
    return internals.uriRegex;
  };
  return uri$1;
}
var hasRequiredIp;
function requireIp() {
  if (hasRequiredIp) return ip;
  hasRequiredIp = 1;
  const Assert = requireAssert();
  const Uri = requireUri$1();
  ip.regex = function(options = {}) {
    Assert(options.cidr === void 0 || typeof options.cidr === "string", "options.cidr must be a string");
    const cidr = options.cidr ? options.cidr.toLowerCase() : "optional";
    Assert(["required", "optional", "forbidden"].includes(cidr), "options.cidr must be one of required, optional, forbidden");
    Assert(options.version === void 0 || typeof options.version === "string" || Array.isArray(options.version), "options.version must be a string or an array of string");
    let versions = options.version || ["ipv4", "ipv6", "ipvfuture"];
    if (!Array.isArray(versions)) {
      versions = [versions];
    }
    Assert(versions.length >= 1, "options.version must have at least 1 version specified");
    for (let i = 0; i < versions.length; ++i) {
      Assert(typeof versions[i] === "string", "options.version must only contain strings");
      versions[i] = versions[i].toLowerCase();
      Assert(["ipv4", "ipv6", "ipvfuture"].includes(versions[i]), "options.version contains unknown version " + versions[i] + " - must be one of ipv4, ipv6, ipvfuture");
    }
    versions = Array.from(new Set(versions));
    const parts = versions.map((version2) => {
      if (cidr === "forbidden") {
        return Uri.ip[version2];
      }
      const cidrpart = `\\/${version2 === "ipv4" ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;
      if (cidr === "required") {
        return `${Uri.ip[version2]}${cidrpart}`;
      }
      return `${Uri.ip[version2]}(?:${cidrpart})?`;
    });
    const raw = `(?:${parts.join("|")})`;
    const regex = new RegExp(`^${raw}$`);
    return { cidr, versions, regex, raw };
  };
  return ip;
}
var tlds;
var hasRequiredTlds;
function requireTlds() {
  if (hasRequiredTlds) return tlds;
  hasRequiredTlds = 1;
  const internals = {};
  internals.tlds = [
    "AAA",
    "AARP",
    "ABB",
    "ABBOTT",
    "ABBVIE",
    "ABC",
    "ABLE",
    "ABOGADO",
    "ABUDHABI",
    "AC",
    "ACADEMY",
    "ACCENTURE",
    "ACCOUNTANT",
    "ACCOUNTANTS",
    "ACO",
    "ACTOR",
    "AD",
    "ADS",
    "ADULT",
    "AE",
    "AEG",
    "AERO",
    "AETNA",
    "AF",
    "AFL",
    "AFRICA",
    "AG",
    "AGAKHAN",
    "AGENCY",
    "AI",
    "AIG",
    "AIRBUS",
    "AIRFORCE",
    "AIRTEL",
    "AKDN",
    "AL",
    "ALIBABA",
    "ALIPAY",
    "ALLFINANZ",
    "ALLSTATE",
    "ALLY",
    "ALSACE",
    "ALSTOM",
    "AM",
    "AMAZON",
    "AMERICANEXPRESS",
    "AMERICANFAMILY",
    "AMEX",
    "AMFAM",
    "AMICA",
    "AMSTERDAM",
    "ANALYTICS",
    "ANDROID",
    "ANQUAN",
    "ANZ",
    "AO",
    "AOL",
    "APARTMENTS",
    "APP",
    "APPLE",
    "AQ",
    "AQUARELLE",
    "AR",
    "ARAB",
    "ARAMCO",
    "ARCHI",
    "ARMY",
    "ARPA",
    "ART",
    "ARTE",
    "AS",
    "ASDA",
    "ASIA",
    "ASSOCIATES",
    "AT",
    "ATHLETA",
    "ATTORNEY",
    "AU",
    "AUCTION",
    "AUDI",
    "AUDIBLE",
    "AUDIO",
    "AUSPOST",
    "AUTHOR",
    "AUTO",
    "AUTOS",
    "AVIANCA",
    "AW",
    "AWS",
    "AX",
    "AXA",
    "AZ",
    "AZURE",
    "BA",
    "BABY",
    "BAIDU",
    "BANAMEX",
    "BAND",
    "BANK",
    "BAR",
    "BARCELONA",
    "BARCLAYCARD",
    "BARCLAYS",
    "BAREFOOT",
    "BARGAINS",
    "BASEBALL",
    "BASKETBALL",
    "BAUHAUS",
    "BAYERN",
    "BB",
    "BBC",
    "BBT",
    "BBVA",
    "BCG",
    "BCN",
    "BD",
    "BE",
    "BEATS",
    "BEAUTY",
    "BEER",
    "BENTLEY",
    "BERLIN",
    "BEST",
    "BESTBUY",
    "BET",
    "BF",
    "BG",
    "BH",
    "BHARTI",
    "BI",
    "BIBLE",
    "BID",
    "BIKE",
    "BING",
    "BINGO",
    "BIO",
    "BIZ",
    "BJ",
    "BLACK",
    "BLACKFRIDAY",
    "BLOCKBUSTER",
    "BLOG",
    "BLOOMBERG",
    "BLUE",
    "BM",
    "BMS",
    "BMW",
    "BN",
    "BNPPARIBAS",
    "BO",
    "BOATS",
    "BOEHRINGER",
    "BOFA",
    "BOM",
    "BOND",
    "BOO",
    "BOOK",
    "BOOKING",
    "BOSCH",
    "BOSTIK",
    "BOSTON",
    "BOT",
    "BOUTIQUE",
    "BOX",
    "BR",
    "BRADESCO",
    "BRIDGESTONE",
    "BROADWAY",
    "BROKER",
    "BROTHER",
    "BRUSSELS",
    "BS",
    "BT",
    "BUILD",
    "BUILDERS",
    "BUSINESS",
    "BUY",
    "BUZZ",
    "BV",
    "BW",
    "BY",
    "BZ",
    "BZH",
    "CA",
    "CAB",
    "CAFE",
    "CAL",
    "CALL",
    "CALVINKLEIN",
    "CAM",
    "CAMERA",
    "CAMP",
    "CANON",
    "CAPETOWN",
    "CAPITAL",
    "CAPITALONE",
    "CAR",
    "CARAVAN",
    "CARDS",
    "CARE",
    "CAREER",
    "CAREERS",
    "CARS",
    "CASA",
    "CASE",
    "CASH",
    "CASINO",
    "CAT",
    "CATERING",
    "CATHOLIC",
    "CBA",
    "CBN",
    "CBRE",
    "CC",
    "CD",
    "CENTER",
    "CEO",
    "CERN",
    "CF",
    "CFA",
    "CFD",
    "CG",
    "CH",
    "CHANEL",
    "CHANNEL",
    "CHARITY",
    "CHASE",
    "CHAT",
    "CHEAP",
    "CHINTAI",
    "CHRISTMAS",
    "CHROME",
    "CHURCH",
    "CI",
    "CIPRIANI",
    "CIRCLE",
    "CISCO",
    "CITADEL",
    "CITI",
    "CITIC",
    "CITY",
    "CK",
    "CL",
    "CLAIMS",
    "CLEANING",
    "CLICK",
    "CLINIC",
    "CLINIQUE",
    "CLOTHING",
    "CLOUD",
    "CLUB",
    "CLUBMED",
    "CM",
    "CN",
    "CO",
    "COACH",
    "CODES",
    "COFFEE",
    "COLLEGE",
    "COLOGNE",
    "COM",
    "COMCAST",
    "COMMBANK",
    "COMMUNITY",
    "COMPANY",
    "COMPARE",
    "COMPUTER",
    "COMSEC",
    "CONDOS",
    "CONSTRUCTION",
    "CONSULTING",
    "CONTACT",
    "CONTRACTORS",
    "COOKING",
    "COOL",
    "COOP",
    "CORSICA",
    "COUNTRY",
    "COUPON",
    "COUPONS",
    "COURSES",
    "CPA",
    "CR",
    "CREDIT",
    "CREDITCARD",
    "CREDITUNION",
    "CRICKET",
    "CROWN",
    "CRS",
    "CRUISE",
    "CRUISES",
    "CU",
    "CUISINELLA",
    "CV",
    "CW",
    "CX",
    "CY",
    "CYMRU",
    "CYOU",
    "CZ",
    "DABUR",
    "DAD",
    "DANCE",
    "DATA",
    "DATE",
    "DATING",
    "DATSUN",
    "DAY",
    "DCLK",
    "DDS",
    "DE",
    "DEAL",
    "DEALER",
    "DEALS",
    "DEGREE",
    "DELIVERY",
    "DELL",
    "DELOITTE",
    "DELTA",
    "DEMOCRAT",
    "DENTAL",
    "DENTIST",
    "DESI",
    "DESIGN",
    "DEV",
    "DHL",
    "DIAMONDS",
    "DIET",
    "DIGITAL",
    "DIRECT",
    "DIRECTORY",
    "DISCOUNT",
    "DISCOVER",
    "DISH",
    "DIY",
    "DJ",
    "DK",
    "DM",
    "DNP",
    "DO",
    "DOCS",
    "DOCTOR",
    "DOG",
    "DOMAINS",
    "DOT",
    "DOWNLOAD",
    "DRIVE",
    "DTV",
    "DUBAI",
    "DUNLOP",
    "DUPONT",
    "DURBAN",
    "DVAG",
    "DVR",
    "DZ",
    "EARTH",
    "EAT",
    "EC",
    "ECO",
    "EDEKA",
    "EDU",
    "EDUCATION",
    "EE",
    "EG",
    "EMAIL",
    "EMERCK",
    "ENERGY",
    "ENGINEER",
    "ENGINEERING",
    "ENTERPRISES",
    "EPSON",
    "EQUIPMENT",
    "ER",
    "ERICSSON",
    "ERNI",
    "ES",
    "ESQ",
    "ESTATE",
    "ET",
    "EU",
    "EUROVISION",
    "EUS",
    "EVENTS",
    "EXCHANGE",
    "EXPERT",
    "EXPOSED",
    "EXPRESS",
    "EXTRASPACE",
    "FAGE",
    "FAIL",
    "FAIRWINDS",
    "FAITH",
    "FAMILY",
    "FAN",
    "FANS",
    "FARM",
    "FARMERS",
    "FASHION",
    "FAST",
    "FEDEX",
    "FEEDBACK",
    "FERRARI",
    "FERRERO",
    "FI",
    "FIDELITY",
    "FIDO",
    "FILM",
    "FINAL",
    "FINANCE",
    "FINANCIAL",
    "FIRE",
    "FIRESTONE",
    "FIRMDALE",
    "FISH",
    "FISHING",
    "FIT",
    "FITNESS",
    "FJ",
    "FK",
    "FLICKR",
    "FLIGHTS",
    "FLIR",
    "FLORIST",
    "FLOWERS",
    "FLY",
    "FM",
    "FO",
    "FOO",
    "FOOD",
    "FOOTBALL",
    "FORD",
    "FOREX",
    "FORSALE",
    "FORUM",
    "FOUNDATION",
    "FOX",
    "FR",
    "FREE",
    "FRESENIUS",
    "FRL",
    "FROGANS",
    "FRONTIER",
    "FTR",
    "FUJITSU",
    "FUN",
    "FUND",
    "FURNITURE",
    "FUTBOL",
    "FYI",
    "GA",
    "GAL",
    "GALLERY",
    "GALLO",
    "GALLUP",
    "GAME",
    "GAMES",
    "GAP",
    "GARDEN",
    "GAY",
    "GB",
    "GBIZ",
    "GD",
    "GDN",
    "GE",
    "GEA",
    "GENT",
    "GENTING",
    "GEORGE",
    "GF",
    "GG",
    "GGEE",
    "GH",
    "GI",
    "GIFT",
    "GIFTS",
    "GIVES",
    "GIVING",
    "GL",
    "GLASS",
    "GLE",
    "GLOBAL",
    "GLOBO",
    "GM",
    "GMAIL",
    "GMBH",
    "GMO",
    "GMX",
    "GN",
    "GODADDY",
    "GOLD",
    "GOLDPOINT",
    "GOLF",
    "GOO",
    "GOODYEAR",
    "GOOG",
    "GOOGLE",
    "GOP",
    "GOT",
    "GOV",
    "GP",
    "GQ",
    "GR",
    "GRAINGER",
    "GRAPHICS",
    "GRATIS",
    "GREEN",
    "GRIPE",
    "GROCERY",
    "GROUP",
    "GS",
    "GT",
    "GU",
    "GUARDIAN",
    "GUCCI",
    "GUGE",
    "GUIDE",
    "GUITARS",
    "GURU",
    "GW",
    "GY",
    "HAIR",
    "HAMBURG",
    "HANGOUT",
    "HAUS",
    "HBO",
    "HDFC",
    "HDFCBANK",
    "HEALTH",
    "HEALTHCARE",
    "HELP",
    "HELSINKI",
    "HERE",
    "HERMES",
    "HIPHOP",
    "HISAMITSU",
    "HITACHI",
    "HIV",
    "HK",
    "HKT",
    "HM",
    "HN",
    "HOCKEY",
    "HOLDINGS",
    "HOLIDAY",
    "HOMEDEPOT",
    "HOMEGOODS",
    "HOMES",
    "HOMESENSE",
    "HONDA",
    "HORSE",
    "HOSPITAL",
    "HOST",
    "HOSTING",
    "HOT",
    "HOTELS",
    "HOTMAIL",
    "HOUSE",
    "HOW",
    "HR",
    "HSBC",
    "HT",
    "HU",
    "HUGHES",
    "HYATT",
    "HYUNDAI",
    "IBM",
    "ICBC",
    "ICE",
    "ICU",
    "ID",
    "IE",
    "IEEE",
    "IFM",
    "IKANO",
    "IL",
    "IM",
    "IMAMAT",
    "IMDB",
    "IMMO",
    "IMMOBILIEN",
    "IN",
    "INC",
    "INDUSTRIES",
    "INFINITI",
    "INFO",
    "ING",
    "INK",
    "INSTITUTE",
    "INSURANCE",
    "INSURE",
    "INT",
    "INTERNATIONAL",
    "INTUIT",
    "INVESTMENTS",
    "IO",
    "IPIRANGA",
    "IQ",
    "IR",
    "IRISH",
    "IS",
    "ISMAILI",
    "IST",
    "ISTANBUL",
    "IT",
    "ITAU",
    "ITV",
    "JAGUAR",
    "JAVA",
    "JCB",
    "JE",
    "JEEP",
    "JETZT",
    "JEWELRY",
    "JIO",
    "JLL",
    "JM",
    "JMP",
    "JNJ",
    "JO",
    "JOBS",
    "JOBURG",
    "JOT",
    "JOY",
    "JP",
    "JPMORGAN",
    "JPRS",
    "JUEGOS",
    "JUNIPER",
    "KAUFEN",
    "KDDI",
    "KE",
    "KERRYHOTELS",
    "KERRYLOGISTICS",
    "KERRYPROPERTIES",
    "KFH",
    "KG",
    "KH",
    "KI",
    "KIA",
    "KIDS",
    "KIM",
    "KINDLE",
    "KITCHEN",
    "KIWI",
    "KM",
    "KN",
    "KOELN",
    "KOMATSU",
    "KOSHER",
    "KP",
    "KPMG",
    "KPN",
    "KR",
    "KRD",
    "KRED",
    "KUOKGROUP",
    "KW",
    "KY",
    "KYOTO",
    "KZ",
    "LA",
    "LACAIXA",
    "LAMBORGHINI",
    "LAMER",
    "LANCASTER",
    "LAND",
    "LANDROVER",
    "LANXESS",
    "LASALLE",
    "LAT",
    "LATINO",
    "LATROBE",
    "LAW",
    "LAWYER",
    "LB",
    "LC",
    "LDS",
    "LEASE",
    "LECLERC",
    "LEFRAK",
    "LEGAL",
    "LEGO",
    "LEXUS",
    "LGBT",
    "LI",
    "LIDL",
    "LIFE",
    "LIFEINSURANCE",
    "LIFESTYLE",
    "LIGHTING",
    "LIKE",
    "LILLY",
    "LIMITED",
    "LIMO",
    "LINCOLN",
    "LINK",
    "LIPSY",
    "LIVE",
    "LIVING",
    "LK",
    "LLC",
    "LLP",
    "LOAN",
    "LOANS",
    "LOCKER",
    "LOCUS",
    "LOL",
    "LONDON",
    "LOTTE",
    "LOTTO",
    "LOVE",
    "LPL",
    "LPLFINANCIAL",
    "LR",
    "LS",
    "LT",
    "LTD",
    "LTDA",
    "LU",
    "LUNDBECK",
    "LUXE",
    "LUXURY",
    "LV",
    "LY",
    "MA",
    "MADRID",
    "MAIF",
    "MAISON",
    "MAKEUP",
    "MAN",
    "MANAGEMENT",
    "MANGO",
    "MAP",
    "MARKET",
    "MARKETING",
    "MARKETS",
    "MARRIOTT",
    "MARSHALLS",
    "MATTEL",
    "MBA",
    "MC",
    "MCKINSEY",
    "MD",
    "ME",
    "MED",
    "MEDIA",
    "MEET",
    "MELBOURNE",
    "MEME",
    "MEMORIAL",
    "MEN",
    "MENU",
    "MERCKMSD",
    "MG",
    "MH",
    "MIAMI",
    "MICROSOFT",
    "MIL",
    "MINI",
    "MINT",
    "MIT",
    "MITSUBISHI",
    "MK",
    "ML",
    "MLB",
    "MLS",
    "MM",
    "MMA",
    "MN",
    "MO",
    "MOBI",
    "MOBILE",
    "MODA",
    "MOE",
    "MOI",
    "MOM",
    "MONASH",
    "MONEY",
    "MONSTER",
    "MORMON",
    "MORTGAGE",
    "MOSCOW",
    "MOTO",
    "MOTORCYCLES",
    "MOV",
    "MOVIE",
    "MP",
    "MQ",
    "MR",
    "MS",
    "MSD",
    "MT",
    "MTN",
    "MTR",
    "MU",
    "MUSEUM",
    "MUSIC",
    "MV",
    "MW",
    "MX",
    "MY",
    "MZ",
    "NA",
    "NAB",
    "NAGOYA",
    "NAME",
    "NATURA",
    "NAVY",
    "NBA",
    "NC",
    "NE",
    "NEC",
    "NET",
    "NETBANK",
    "NETFLIX",
    "NETWORK",
    "NEUSTAR",
    "NEW",
    "NEWS",
    "NEXT",
    "NEXTDIRECT",
    "NEXUS",
    "NF",
    "NFL",
    "NG",
    "NGO",
    "NHK",
    "NI",
    "NICO",
    "NIKE",
    "NIKON",
    "NINJA",
    "NISSAN",
    "NISSAY",
    "NL",
    "NO",
    "NOKIA",
    "NORTON",
    "NOW",
    "NOWRUZ",
    "NOWTV",
    "NP",
    "NR",
    "NRA",
    "NRW",
    "NTT",
    "NU",
    "NYC",
    "NZ",
    "OBI",
    "OBSERVER",
    "OFFICE",
    "OKINAWA",
    "OLAYAN",
    "OLAYANGROUP",
    "OLLO",
    "OM",
    "OMEGA",
    "ONE",
    "ONG",
    "ONL",
    "ONLINE",
    "OOO",
    "OPEN",
    "ORACLE",
    "ORANGE",
    "ORG",
    "ORGANIC",
    "ORIGINS",
    "OSAKA",
    "OTSUKA",
    "OTT",
    "OVH",
    "PA",
    "PAGE",
    "PANASONIC",
    "PARIS",
    "PARS",
    "PARTNERS",
    "PARTS",
    "PARTY",
    "PAY",
    "PCCW",
    "PE",
    "PET",
    "PF",
    "PFIZER",
    "PG",
    "PH",
    "PHARMACY",
    "PHD",
    "PHILIPS",
    "PHONE",
    "PHOTO",
    "PHOTOGRAPHY",
    "PHOTOS",
    "PHYSIO",
    "PICS",
    "PICTET",
    "PICTURES",
    "PID",
    "PIN",
    "PING",
    "PINK",
    "PIONEER",
    "PIZZA",
    "PK",
    "PL",
    "PLACE",
    "PLAY",
    "PLAYSTATION",
    "PLUMBING",
    "PLUS",
    "PM",
    "PN",
    "PNC",
    "POHL",
    "POKER",
    "POLITIE",
    "PORN",
    "POST",
    "PR",
    "PRAMERICA",
    "PRAXI",
    "PRESS",
    "PRIME",
    "PRO",
    "PROD",
    "PRODUCTIONS",
    "PROF",
    "PROGRESSIVE",
    "PROMO",
    "PROPERTIES",
    "PROPERTY",
    "PROTECTION",
    "PRU",
    "PRUDENTIAL",
    "PS",
    "PT",
    "PUB",
    "PW",
    "PWC",
    "PY",
    "QA",
    "QPON",
    "QUEBEC",
    "QUEST",
    "RACING",
    "RADIO",
    "RE",
    "READ",
    "REALESTATE",
    "REALTOR",
    "REALTY",
    "RECIPES",
    "RED",
    "REDSTONE",
    "REDUMBRELLA",
    "REHAB",
    "REISE",
    "REISEN",
    "REIT",
    "RELIANCE",
    "REN",
    "RENT",
    "RENTALS",
    "REPAIR",
    "REPORT",
    "REPUBLICAN",
    "REST",
    "RESTAURANT",
    "REVIEW",
    "REVIEWS",
    "REXROTH",
    "RICH",
    "RICHARDLI",
    "RICOH",
    "RIL",
    "RIO",
    "RIP",
    "RO",
    "ROCKS",
    "RODEO",
    "ROGERS",
    "ROOM",
    "RS",
    "RSVP",
    "RU",
    "RUGBY",
    "RUHR",
    "RUN",
    "RW",
    "RWE",
    "RYUKYU",
    "SA",
    "SAARLAND",
    "SAFE",
    "SAFETY",
    "SAKURA",
    "SALE",
    "SALON",
    "SAMSCLUB",
    "SAMSUNG",
    "SANDVIK",
    "SANDVIKCOROMANT",
    "SANOFI",
    "SAP",
    "SARL",
    "SAS",
    "SAVE",
    "SAXO",
    "SB",
    "SBI",
    "SBS",
    "SC",
    "SCB",
    "SCHAEFFLER",
    "SCHMIDT",
    "SCHOLARSHIPS",
    "SCHOOL",
    "SCHULE",
    "SCHWARZ",
    "SCIENCE",
    "SCOT",
    "SD",
    "SE",
    "SEARCH",
    "SEAT",
    "SECURE",
    "SECURITY",
    "SEEK",
    "SELECT",
    "SENER",
    "SERVICES",
    "SEVEN",
    "SEW",
    "SEX",
    "SEXY",
    "SFR",
    "SG",
    "SH",
    "SHANGRILA",
    "SHARP",
    "SHAW",
    "SHELL",
    "SHIA",
    "SHIKSHA",
    "SHOES",
    "SHOP",
    "SHOPPING",
    "SHOUJI",
    "SHOW",
    "SI",
    "SILK",
    "SINA",
    "SINGLES",
    "SITE",
    "SJ",
    "SK",
    "SKI",
    "SKIN",
    "SKY",
    "SKYPE",
    "SL",
    "SLING",
    "SM",
    "SMART",
    "SMILE",
    "SN",
    "SNCF",
    "SO",
    "SOCCER",
    "SOCIAL",
    "SOFTBANK",
    "SOFTWARE",
    "SOHU",
    "SOLAR",
    "SOLUTIONS",
    "SONG",
    "SONY",
    "SOY",
    "SPA",
    "SPACE",
    "SPORT",
    "SPOT",
    "SR",
    "SRL",
    "SS",
    "ST",
    "STADA",
    "STAPLES",
    "STAR",
    "STATEBANK",
    "STATEFARM",
    "STC",
    "STCGROUP",
    "STOCKHOLM",
    "STORAGE",
    "STORE",
    "STREAM",
    "STUDIO",
    "STUDY",
    "STYLE",
    "SU",
    "SUCKS",
    "SUPPLIES",
    "SUPPLY",
    "SUPPORT",
    "SURF",
    "SURGERY",
    "SUZUKI",
    "SV",
    "SWATCH",
    "SWISS",
    "SX",
    "SY",
    "SYDNEY",
    "SYSTEMS",
    "SZ",
    "TAB",
    "TAIPEI",
    "TALK",
    "TAOBAO",
    "TARGET",
    "TATAMOTORS",
    "TATAR",
    "TATTOO",
    "TAX",
    "TAXI",
    "TC",
    "TCI",
    "TD",
    "TDK",
    "TEAM",
    "TECH",
    "TECHNOLOGY",
    "TEL",
    "TEMASEK",
    "TENNIS",
    "TEVA",
    "TF",
    "TG",
    "TH",
    "THD",
    "THEATER",
    "THEATRE",
    "TIAA",
    "TICKETS",
    "TIENDA",
    "TIPS",
    "TIRES",
    "TIROL",
    "TJ",
    "TJMAXX",
    "TJX",
    "TK",
    "TKMAXX",
    "TL",
    "TM",
    "TMALL",
    "TN",
    "TO",
    "TODAY",
    "TOKYO",
    "TOOLS",
    "TOP",
    "TORAY",
    "TOSHIBA",
    "TOTAL",
    "TOURS",
    "TOWN",
    "TOYOTA",
    "TOYS",
    "TR",
    "TRADE",
    "TRADING",
    "TRAINING",
    "TRAVEL",
    "TRAVELERS",
    "TRAVELERSINSURANCE",
    "TRUST",
    "TRV",
    "TT",
    "TUBE",
    "TUI",
    "TUNES",
    "TUSHU",
    "TV",
    "TVS",
    "TW",
    "TZ",
    "UA",
    "UBANK",
    "UBS",
    "UG",
    "UK",
    "UNICOM",
    "UNIVERSITY",
    "UNO",
    "UOL",
    "UPS",
    "US",
    "UY",
    "UZ",
    "VA",
    "VACATIONS",
    "VANA",
    "VANGUARD",
    "VC",
    "VE",
    "VEGAS",
    "VENTURES",
    "VERISIGN",
    "VERSICHERUNG",
    "VET",
    "VG",
    "VI",
    "VIAJES",
    "VIDEO",
    "VIG",
    "VIKING",
    "VILLAS",
    "VIN",
    "VIP",
    "VIRGIN",
    "VISA",
    "VISION",
    "VIVA",
    "VIVO",
    "VLAANDEREN",
    "VN",
    "VODKA",
    "VOLVO",
    "VOTE",
    "VOTING",
    "VOTO",
    "VOYAGE",
    "VU",
    "WALES",
    "WALMART",
    "WALTER",
    "WANG",
    "WANGGOU",
    "WATCH",
    "WATCHES",
    "WEATHER",
    "WEATHERCHANNEL",
    "WEBCAM",
    "WEBER",
    "WEBSITE",
    "WED",
    "WEDDING",
    "WEIBO",
    "WEIR",
    "WF",
    "WHOSWHO",
    "WIEN",
    "WIKI",
    "WILLIAMHILL",
    "WIN",
    "WINDOWS",
    "WINE",
    "WINNERS",
    "WME",
    "WOLTERSKLUWER",
    "WOODSIDE",
    "WORK",
    "WORKS",
    "WORLD",
    "WOW",
    "WS",
    "WTC",
    "WTF",
    "XBOX",
    "XEROX",
    "XFINITY",
    "XIHUAN",
    "XIN",
    "XN--11B4C3D",
    "XN--1CK2E1B",
    "XN--1QQW23A",
    "XN--2SCRJ9C",
    "XN--30RR7Y",
    "XN--3BST00M",
    "XN--3DS443G",
    "XN--3E0B707E",
    "XN--3HCRJ9C",
    "XN--3PXU8K",
    "XN--42C2D9A",
    "XN--45BR5CYL",
    "XN--45BRJ9C",
    "XN--45Q11C",
    "XN--4DBRK0CE",
    "XN--4GBRIM",
    "XN--54B7FTA0CC",
    "XN--55QW42G",
    "XN--55QX5D",
    "XN--5SU34J936BGSG",
    "XN--5TZM5G",
    "XN--6FRZ82G",
    "XN--6QQ986B3XL",
    "XN--80ADXHKS",
    "XN--80AO21A",
    "XN--80AQECDR1A",
    "XN--80ASEHDB",
    "XN--80ASWG",
    "XN--8Y0A063A",
    "XN--90A3AC",
    "XN--90AE",
    "XN--90AIS",
    "XN--9DBQ2A",
    "XN--9ET52U",
    "XN--9KRT00A",
    "XN--B4W605FERD",
    "XN--BCK1B9A5DRE4C",
    "XN--C1AVG",
    "XN--C2BR7G",
    "XN--CCK2B3B",
    "XN--CCKWCXETD",
    "XN--CG4BKI",
    "XN--CLCHC0EA0B2G2A9GCD",
    "XN--CZR694B",
    "XN--CZRS0T",
    "XN--CZRU2D",
    "XN--D1ACJ3B",
    "XN--D1ALF",
    "XN--E1A4C",
    "XN--ECKVDTC9D",
    "XN--EFVY88H",
    "XN--FCT429K",
    "XN--FHBEI",
    "XN--FIQ228C5HS",
    "XN--FIQ64B",
    "XN--FIQS8S",
    "XN--FIQZ9S",
    "XN--FJQ720A",
    "XN--FLW351E",
    "XN--FPCRJ9C3D",
    "XN--FZC2C9E2C",
    "XN--FZYS8D69UVGM",
    "XN--G2XX48C",
    "XN--GCKR3F0F",
    "XN--GECRJ9C",
    "XN--GK3AT1E",
    "XN--H2BREG3EVE",
    "XN--H2BRJ9C",
    "XN--H2BRJ9C8C",
    "XN--HXT814E",
    "XN--I1B6B1A6A2E",
    "XN--IMR513N",
    "XN--IO0A7I",
    "XN--J1AEF",
    "XN--J1AMH",
    "XN--J6W193G",
    "XN--JLQ480N2RG",
    "XN--JVR189M",
    "XN--KCRX77D1X4A",
    "XN--KPRW13D",
    "XN--KPRY57D",
    "XN--KPUT3I",
    "XN--L1ACC",
    "XN--LGBBAT1AD8J",
    "XN--MGB9AWBF",
    "XN--MGBA3A3EJT",
    "XN--MGBA3A4F16A",
    "XN--MGBA7C0BBN0A",
    "XN--MGBAAM7A8H",
    "XN--MGBAB2BD",
    "XN--MGBAH1A3HJKRD",
    "XN--MGBAI9AZGQP6J",
    "XN--MGBAYH7GPA",
    "XN--MGBBH1A",
    "XN--MGBBH1A71E",
    "XN--MGBC0A9AZCG",
    "XN--MGBCA7DZDO",
    "XN--MGBCPQ6GPA1A",
    "XN--MGBERP4A5D4AR",
    "XN--MGBGU82A",
    "XN--MGBI4ECEXP",
    "XN--MGBPL2FH",
    "XN--MGBT3DHD",
    "XN--MGBTX2B",
    "XN--MGBX4CD0AB",
    "XN--MIX891F",
    "XN--MK1BU44C",
    "XN--MXTQ1M",
    "XN--NGBC5AZD",
    "XN--NGBE9E0A",
    "XN--NGBRX",
    "XN--NODE",
    "XN--NQV7F",
    "XN--NQV7FS00EMA",
    "XN--NYQY26A",
    "XN--O3CW4H",
    "XN--OGBPF8FL",
    "XN--OTU796D",
    "XN--P1ACF",
    "XN--P1AI",
    "XN--PGBS0DH",
    "XN--PSSY2U",
    "XN--Q7CE6A",
    "XN--Q9JYB4C",
    "XN--QCKA1PMC",
    "XN--QXA6A",
    "XN--QXAM",
    "XN--RHQV96G",
    "XN--ROVU88B",
    "XN--RVC1E0AM3E",
    "XN--S9BRJ9C",
    "XN--SES554G",
    "XN--T60B56A",
    "XN--TCKWE",
    "XN--TIQ49XQYJ",
    "XN--UNUP4Y",
    "XN--VERMGENSBERATER-CTB",
    "XN--VERMGENSBERATUNG-PWB",
    "XN--VHQUV",
    "XN--VUQ861B",
    "XN--W4R85EL8FHU5DNRA",
    "XN--W4RS40L",
    "XN--WGBH1C",
    "XN--WGBL6A",
    "XN--XHQ521B",
    "XN--XKC2AL3HYE2A",
    "XN--XKC2DL3A5EE0H",
    "XN--Y9A3AQ",
    "XN--YFRO4I67O",
    "XN--YGBI2AMMX",
    "XN--ZFR164B",
    "XXX",
    "XYZ",
    "YACHTS",
    "YAHOO",
    "YAMAXUN",
    "YANDEX",
    "YE",
    "YODOBASHI",
    "YOGA",
    "YOKOHAMA",
    "YOU",
    "YOUTUBE",
    "YT",
    "YUN",
    "ZA",
    "ZAPPOS",
    "ZARA",
    "ZERO",
    "ZIP",
    "ZM",
    "ZONE",
    "ZUERICH",
    "ZW"
  ];
  tlds = new Set(internals.tlds.map((tld) => tld.toLowerCase()));
  return tlds;
}
var string;
var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  const Assert = requireAssert();
  const Domain = requireDomain();
  const Email = requireEmail();
  const Ip = requireIp();
  const EscapeRegex = requireEscapeRegex();
  const Tlds = requireTlds();
  const Uri = requireUri$1();
  const Any = requireAny();
  const Common = requireCommon$1();
  const internals = {
    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,
    // $lab:coverage:ignore$
    base64Regex: {
      // paddingRequired
      true: {
        // urlSafe
        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
        false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
      },
      false: {
        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
        false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
      }
    },
    dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
    hexRegex: {
      withPrefix: /^0x[0-9a-f]+$/i,
      withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,
      withoutPrefix: /^[0-9a-f]+$/i
    },
    ipRegex: Ip.regex({ cidr: "forbidden" }).regex,
    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
    guidBrackets: {
      "{": "}",
      "[": "]",
      "(": ")",
      "": ""
    },
    guidVersions: {
      uuidv1: "1",
      uuidv2: "2",
      uuidv3: "3",
      uuidv4: "4",
      uuidv5: "5",
      uuidv6: "6",
      uuidv7: "7",
      uuidv8: "8"
    },
    guidSeparators: /* @__PURE__ */ new Set([void 0, true, false, "-", ":"]),
    normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
  };
  string = Any.extend({
    type: "string",
    flags: {
      insensitive: { default: false },
      truncate: { default: false }
    },
    terms: {
      replacements: { init: null }
    },
    coerce: {
      from: "string",
      method(value, { schema, state: state2, prefs }) {
        const normalize = schema.$_getRule("normalize");
        if (normalize) {
          value = value.normalize(normalize.args.form);
        }
        const casing = schema.$_getRule("case");
        if (casing) {
          value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
        }
        const trim = schema.$_getRule("trim");
        if (trim && trim.args.enabled) {
          value = value.trim();
        }
        if (schema.$_terms.replacements) {
          for (const replacement of schema.$_terms.replacements) {
            value = value.replace(replacement.pattern, replacement.replacement);
          }
        }
        const hex = schema.$_getRule("hex");
        if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
          value = `0${value}`;
        }
        if (schema.$_getRule("isoDate")) {
          const iso = internals.isoDate(value);
          if (iso) {
            value = iso;
          }
        }
        if (schema._flags.truncate) {
          const rule = schema.$_getRule("max");
          if (rule) {
            let limit = rule.args.limit;
            if (Common.isResolvable(limit)) {
              limit = limit.resolve(value, state2, prefs);
              if (!Common.limit(limit)) {
                return { value, errors: schema.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state2, prefs) };
              }
            }
            value = value.slice(0, limit);
          }
        }
        return { value };
      }
    },
    validate(value, { schema, error: error2 }) {
      if (typeof value !== "string") {
        return { value, errors: error2("string.base") };
      }
      if (value === "") {
        const min2 = schema.$_getRule("min");
        if (min2 && min2.args.limit === 0) {
          return;
        }
        return { value, errors: error2("string.empty") };
      }
    },
    rules: {
      alphanum: {
        method() {
          return this.$_addRule("alphanum");
        },
        validate(value, helpers) {
          if (/^[a-zA-Z0-9]+$/.test(value)) {
            return value;
          }
          return helpers.error("string.alphanum");
        }
      },
      base64: {
        method(options = {}) {
          Common.assertOptions(options, ["paddingRequired", "urlSafe"]);
          options = { urlSafe: false, paddingRequired: true, ...options };
          Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
          Assert(typeof options.urlSafe === "boolean", "urlSafe must be boolean");
          return this.$_addRule({ name: "base64", args: { options } });
        },
        validate(value, helpers, { options }) {
          const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
          if (regex.test(value)) {
            return value;
          }
          return helpers.error("string.base64");
        }
      },
      case: {
        method(direction) {
          Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
          return this.$_addRule({ name: "case", args: { direction } });
        },
        validate(value, helpers, { direction }) {
          if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
            return value;
          }
          return helpers.error(`string.${direction}case`);
        },
        convert: true
      },
      creditCard: {
        method() {
          return this.$_addRule("creditCard");
        },
        validate(value, helpers) {
          let i = value.length;
          let sum = 0;
          let mul = 1;
          while (i--) {
            const char = value.charAt(i) * mul;
            sum = sum + (char - (char > 9) * 9);
            mul = mul ^ 3;
          }
          if (sum > 0 && sum % 10 === 0) {
            return value;
          }
          return helpers.error("string.creditCard");
        }
      },
      dataUri: {
        method(options = {}) {
          Common.assertOptions(options, ["paddingRequired"]);
          options = { paddingRequired: true, ...options };
          Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
          return this.$_addRule({ name: "dataUri", args: { options } });
        },
        validate(value, helpers, { options }) {
          const matches = value.match(internals.dataUriRegex);
          if (matches) {
            if (!matches[2]) {
              return value;
            }
            if (matches[2] !== "base64") {
              return value;
            }
            const base64regex = internals.base64Regex[options.paddingRequired].false;
            if (base64regex.test(matches[3])) {
              return value;
            }
          }
          return helpers.error("string.dataUri");
        }
      },
      domain: {
        method(options) {
          if (options) {
            Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          }
          const address = internals.addressOptions(options);
          return this.$_addRule({ name: "domain", args: { options }, address });
        },
        validate(value, helpers, args2, { address }) {
          if (Domain.isValid(value, address)) {
            return value;
          }
          return helpers.error("string.domain");
        }
      },
      email: {
        method(options = {}) {
          Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]);
          Assert(options.multiple === void 0 || typeof options.multiple === "boolean", "multiple option must be an boolean");
          const address = internals.addressOptions(options);
          const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ","}]\\s*`);
          return this.$_addRule({ name: "email", args: { options }, regex, address });
        },
        validate(value, helpers, { options }, { regex, address }) {
          const emails = options.multiple ? value.split(regex) : [value];
          const invalids = [];
          for (const email2 of emails) {
            if (!Email.isValid(email2, address)) {
              invalids.push(email2);
            }
          }
          if (!invalids.length) {
            return value;
          }
          return helpers.error("string.email", { value, invalids });
        }
      },
      guid: {
        alias: "uuid",
        method(options = {}) {
          Common.assertOptions(options, ["version", "separator"]);
          let versionNumbers = "";
          if (options.version) {
            const versions = [].concat(options.version);
            Assert(versions.length >= 1, "version must have at least 1 valid version specified");
            const set = /* @__PURE__ */ new Set();
            for (let i = 0; i < versions.length; ++i) {
              const version2 = versions[i];
              Assert(typeof version2 === "string", "version at position " + i + " must be a string");
              const versionNumber = internals.guidVersions[version2.toLowerCase()];
              Assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
              Assert(!set.has(versionNumber), "version at position " + i + " must not be a duplicate");
              versionNumbers += versionNumber;
              set.add(versionNumber);
            }
          }
          Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
          const separator = options.separator === void 0 ? "[:-]?" : options.separator === true ? "[:-]" : options.separator === false ? "[]?" : `\\${options.separator}`;
          const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
          return this.$_addRule({ name: "guid", args: { options }, regex });
        },
        validate(value, helpers, args2, { regex }) {
          const results = regex.exec(value);
          if (!results) {
            return helpers.error("string.guid");
          }
          if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
            return helpers.error("string.guid");
          }
          return value;
        }
      },
      hex: {
        method(options = {}) {
          Common.assertOptions(options, ["byteAligned", "prefix"]);
          options = { byteAligned: false, prefix: false, ...options };
          Assert(typeof options.byteAligned === "boolean", "byteAligned must be boolean");
          Assert(typeof options.prefix === "boolean" || options.prefix === "optional", 'prefix must be boolean or "optional"');
          return this.$_addRule({ name: "hex", args: { options } });
        },
        validate(value, helpers, { options }) {
          const re = options.prefix === "optional" ? internals.hexRegex.withOptionalPrefix : options.prefix === true ? internals.hexRegex.withPrefix : internals.hexRegex.withoutPrefix;
          if (!re.test(value)) {
            return helpers.error("string.hex");
          }
          if (options.byteAligned && value.length % 2 !== 0) {
            return helpers.error("string.hexAlign");
          }
          return value;
        }
      },
      hostname: {
        method() {
          return this.$_addRule("hostname");
        },
        validate(value, helpers) {
          if (Domain.isValid(value, { minDomainSegments: 1 }) || internals.ipRegex.test(value)) {
            return value;
          }
          return helpers.error("string.hostname");
        }
      },
      insensitive: {
        method() {
          return this.$_setFlag("insensitive", true);
        }
      },
      ip: {
        method(options = {}) {
          Common.assertOptions(options, ["cidr", "version"]);
          const { cidr, versions, regex } = Ip.regex(options);
          const version2 = options.version ? versions : void 0;
          return this.$_addRule({ name: "ip", args: { options: { cidr, version: version2 } }, regex });
        },
        validate(value, helpers, { options }, { regex }) {
          if (regex.test(value)) {
            return value;
          }
          if (options.version) {
            return helpers.error("string.ipVersion", { value, cidr: options.cidr, version: options.version });
          }
          return helpers.error("string.ip", { value, cidr: options.cidr });
        }
      },
      isoDate: {
        method() {
          return this.$_addRule("isoDate");
        },
        validate(value, { error: error2 }) {
          if (internals.isoDate(value)) {
            return value;
          }
          return error2("string.isoDate");
        }
      },
      isoDuration: {
        method() {
          return this.$_addRule("isoDuration");
        },
        validate(value, helpers) {
          if (internals.isoDurationRegex.test(value)) {
            return value;
          }
          return helpers.error("string.isoDuration");
        }
      },
      length: {
        method(limit, encoding) {
          return internals.length(this, "length", limit, "=", encoding);
        },
        validate(value, helpers, { limit, encoding }, { name, operator, args: args2 }) {
          const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
          if (Common.compare(length, limit, operator)) {
            return value;
          }
          return helpers.error("string." + name, { limit: args2.limit, value, encoding });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          },
          "encoding"
        ]
      },
      lowercase: {
        method() {
          return this.case("lower");
        }
      },
      max: {
        method(limit, encoding) {
          return internals.length(this, "max", limit, "<=", encoding);
        },
        args: ["limit", "encoding"]
      },
      min: {
        method(limit, encoding) {
          return internals.length(this, "min", limit, ">=", encoding);
        },
        args: ["limit", "encoding"]
      },
      normalize: {
        method(form = "NFC") {
          Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
          return this.$_addRule({ name: "normalize", args: { form } });
        },
        validate(value, { error: error2 }, { form }) {
          if (value === value.normalize(form)) {
            return value;
          }
          return error2("string.normalize", { value, form });
        },
        convert: true
      },
      pattern: {
        alias: "regex",
        method(regex, options = {}) {
          Assert(regex instanceof RegExp, "regex must be a RegExp");
          Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
          if (typeof options === "string") {
            options = { name: options };
          }
          Common.assertOptions(options, ["invert", "name"]);
          const errorCode = ["string.pattern", options.invert ? ".invert" : "", options.name ? ".name" : ".base"].join("");
          return this.$_addRule({ name: "pattern", args: { regex, options }, errorCode });
        },
        validate(value, helpers, { regex, options }, { errorCode }) {
          const patternMatch = regex.test(value);
          if (patternMatch ^ options.invert) {
            return value;
          }
          return helpers.error(errorCode, { name: options.name, regex, value });
        },
        args: ["regex", "options"],
        multi: true
      },
      replace: {
        method(pattern, replacement) {
          if (typeof pattern === "string") {
            pattern = new RegExp(EscapeRegex(pattern), "g");
          }
          Assert(pattern instanceof RegExp, "pattern must be a RegExp");
          Assert(typeof replacement === "string", "replacement must be a String");
          const obj = this.clone();
          if (!obj.$_terms.replacements) {
            obj.$_terms.replacements = [];
          }
          obj.$_terms.replacements.push({ pattern, replacement });
          return obj;
        }
      },
      token: {
        method() {
          return this.$_addRule("token");
        },
        validate(value, helpers) {
          if (/^\w+$/.test(value)) {
            return value;
          }
          return helpers.error("string.token");
        }
      },
      trim: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_addRule({ name: "trim", args: { enabled } });
        },
        validate(value, helpers, { enabled }) {
          if (!enabled || value === value.trim()) {
            return value;
          }
          return helpers.error("string.trim");
        },
        convert: true
      },
      truncate: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_setFlag("truncate", enabled);
        }
      },
      uppercase: {
        method() {
          return this.case("upper");
        }
      },
      uri: {
        method(options = {}) {
          Common.assertOptions(options, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme", "encodeUri"]);
          if (options.domain) {
            Common.assertOptions(options.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          }
          const { regex, scheme } = Uri.regex(options);
          const domain2 = options.domain ? internals.addressOptions(options.domain) : null;
          return this.$_addRule({ name: "uri", args: { options }, regex, domain: domain2, scheme });
        },
        validate(value, helpers, { options }, { regex, domain: domain2, scheme }) {
          if (["http:/", "https:/"].includes(value)) {
            return helpers.error("string.uri");
          }
          let match = regex.exec(value);
          if (!match && helpers.prefs.convert && options.encodeUri) {
            const encoded = encodeURI(value);
            match = regex.exec(encoded);
            if (match) {
              value = encoded;
            }
          }
          if (match) {
            const matched = match[1] || match[2];
            if (domain2 && (!options.allowRelative || matched) && !Domain.isValid(matched, domain2)) {
              return helpers.error("string.domain", { value: matched });
            }
            return value;
          }
          if (options.relativeOnly) {
            return helpers.error("string.uriRelativeOnly");
          }
          if (options.scheme) {
            return helpers.error("string.uriCustomScheme", { scheme, value });
          }
          return helpers.error("string.uri");
        }
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.replacements) {
          for (const { pattern, replacement } of desc.replacements) {
            obj = obj.replace(pattern, replacement);
          }
        }
        return obj;
      }
    },
    messages: {
      "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
      "string.base": "{{#label}} must be a string",
      "string.base64": "{{#label}} must be a valid base64 string",
      "string.creditCard": "{{#label}} must be a credit card",
      "string.dataUri": "{{#label}} must be a valid dataUri string",
      "string.domain": "{{#label}} must contain a valid domain name",
      "string.email": "{{#label}} must be a valid email",
      "string.empty": "{{#label}} is not allowed to be empty",
      "string.guid": "{{#label}} must be a valid GUID",
      "string.hex": "{{#label}} must only contain hexadecimal characters",
      "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
      "string.hostname": "{{#label}} must be a valid hostname",
      "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
      "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
      "string.isoDate": "{{#label}} must be in iso format",
      "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
      "string.length": "{{#label}} length must be {{#limit}} characters long",
      "string.lowercase": "{{#label}} must only contain lowercase characters",
      "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
      "string.min": "{{#label}} length must be at least {{#limit}} characters long",
      "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
      "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
      "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
      "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
      "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
      "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
      "string.trim": "{{#label}} must not have leading or trailing whitespace",
      "string.uri": "{{#label}} must be a valid uri",
      "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
      "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
      "string.uppercase": "{{#label}} must only contain uppercase characters"
    }
  });
  internals.addressOptions = function(options) {
    if (!options) {
      return internals.tlds || options;
    }
    Assert(options.minDomainSegments === void 0 || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, "minDomainSegments must be a positive integer");
    Assert(options.maxDomainSegments === void 0 || Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, "maxDomainSegments must be a positive integer");
    if (options.tlds === false) {
      return options;
    }
    if (options.tlds === true || options.tlds === void 0) {
      Assert(internals.tlds, "Built-in TLD list disabled");
      return Object.assign({}, options, internals.tlds);
    }
    Assert(typeof options.tlds === "object", "tlds must be true, false, or an object");
    const deny = options.tlds.deny;
    if (deny) {
      if (Array.isArray(deny)) {
        options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
      }
      Assert(options.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean");
      Assert(!options.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists");
      internals.validateTlds(options.tlds.deny, "tlds.deny");
      return options;
    }
    const allow = options.tlds.allow;
    if (!allow) {
      return options;
    }
    if (allow === true) {
      Assert(internals.tlds, "Built-in TLD list disabled");
      return Object.assign({}, options, internals.tlds);
    }
    if (Array.isArray(allow)) {
      options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
    }
    Assert(options.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean");
    internals.validateTlds(options.tlds.allow, "tlds.allow");
    return options;
  };
  internals.validateTlds = function(set, source) {
    for (const tld of set) {
      Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);
    }
  };
  internals.isoDate = function(value) {
    if (!Common.isIsoDate(value)) {
      return null;
    }
    if (/.*T.*[+-]\d\d$/.test(value)) {
      value += "00";
    }
    const date2 = new Date(value);
    if (isNaN(date2.getTime())) {
      return null;
    }
    return date2.toISOString();
  };
  internals.length = function(schema, name, limit, operator, encoding) {
    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
    return schema.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
  };
  return string;
}
var symbol;
var hasRequiredSymbol;
function requireSymbol() {
  if (hasRequiredSymbol) return symbol;
  hasRequiredSymbol = 1;
  const Assert = requireAssert();
  const Any = requireAny();
  const internals = {};
  internals.Map = class extends Map {
    slice() {
      return new internals.Map(this);
    }
  };
  symbol = Any.extend({
    type: "symbol",
    terms: {
      map: { init: new internals.Map() }
    },
    coerce: {
      method(value, { schema, error: error2 }) {
        const lookup = schema.$_terms.map.get(value);
        if (lookup) {
          value = lookup;
        }
        if (!schema._flags.only || typeof value === "symbol") {
          return { value };
        }
        return { value, errors: error2("symbol.map", { map: schema.$_terms.map }) };
      }
    },
    validate(value, { error: error2 }) {
      if (typeof value !== "symbol") {
        return { value, errors: error2("symbol.base") };
      }
    },
    rules: {
      map: {
        method(iterable) {
          if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
            iterable = Object.entries(iterable);
          }
          Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
          const obj = this.clone();
          const symbols = [];
          for (const entry of iterable) {
            Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
            const [key, value] = entry;
            Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
            Assert(typeof value === "symbol", "Value must be a Symbol");
            obj.$_terms.map.set(key, value);
            symbols.push(value);
          }
          return obj.valid(...symbols);
        }
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.map) {
          obj = obj.map(desc.map);
        }
        return obj;
      }
    },
    messages: {
      "symbol.base": "{{#label}} must be a symbol",
      "symbol.map": "{{#label}} must be one of {{#map}}"
    }
  });
  return symbol;
}
var binary;
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary;
  hasRequiredBinary = 1;
  const Assert = requireAssert();
  const Any = requireAny();
  const Common = requireCommon$1();
  binary = Any.extend({
    type: "binary",
    coerce: {
      from: ["string", "object"],
      method(value, { schema }) {
        if (typeof value === "string" || value !== null && value.type === "Buffer") {
          try {
            return { value: Buffer.from(value, schema._flags.encoding) };
          } catch (ignoreErr) {
          }
        }
      }
    },
    validate(value, { error: error2 }) {
      if (!Buffer.isBuffer(value)) {
        return { value, errors: error2("binary.base") };
      }
    },
    rules: {
      encoding: {
        method(encoding) {
          Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
          return this.$_setFlag("encoding", encoding);
        }
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args: args2 }) {
          if (Common.compare(value.length, limit, operator)) {
            return value;
          }
          return helpers.error("binary." + name, { limit: args2.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      }
    },
    cast: {
      string: {
        from: (value) => Buffer.isBuffer(value),
        to(value, helpers) {
          return value.toString();
        }
      }
    },
    messages: {
      "binary.base": "{{#label}} must be a buffer or a string",
      "binary.length": "{{#label}} must be {{#limit}} bytes",
      "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
      "binary.min": "{{#label}} must be at least {{#limit}} bytes"
    }
  });
  return binary;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  const Assert = requireAssert();
  const Clone = requireClone();
  const Cache = requireCache();
  const Common = requireCommon$1();
  const Compile = requireCompile();
  const Errors = requireErrors$1();
  const Extend = requireExtend();
  const Manifest = requireManifest();
  const Ref = requireRef$1();
  const Template = requireTemplate();
  const Trace = requireTrace();
  let Schemas;
  const internals = {
    types: {
      alternatives: requireAlternatives(),
      any: requireAny(),
      array: requireArray(),
      boolean: requireBoolean(),
      date: requireDate(),
      function: require_function(),
      link: requireLink(),
      number: requireNumber(),
      object: requireObject(),
      string: requireString(),
      symbol: requireSymbol()
    },
    aliases: {
      alt: "alternatives",
      bool: "boolean",
      func: "function"
    }
  };
  if (Buffer) {
    internals.types.binary = requireBinary();
  }
  internals.root = function() {
    const root = {
      _types: new Set(Object.keys(internals.types))
    };
    for (const type2 of root._types) {
      root[type2] = function(...args2) {
        Assert(!args2.length || ["alternatives", "link", "object"].includes(type2), "The", type2, "type does not allow arguments");
        return internals.generate(this, internals.types[type2], args2);
      };
    }
    for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
      root[method] = function(...args2) {
        return this.any()[method](...args2);
      };
    }
    Object.assign(root, internals.methods);
    for (const alias in internals.aliases) {
      const target = internals.aliases[alias];
      root[alias] = root[target];
    }
    root.x = root.expression;
    if (Trace.setup) {
      Trace.setup(root);
    }
    return root;
  };
  internals.methods = {
    ValidationError: Errors.ValidationError,
    version: Common.version,
    cache: Cache.provider,
    assert(value, schema, ...args2) {
      internals.assert(value, schema, true, args2);
    },
    attempt(value, schema, ...args2) {
      return internals.assert(value, schema, false, args2);
    },
    build(desc) {
      Assert(typeof Manifest.build === "function", "Manifest functionality disabled");
      return Manifest.build(this, desc);
    },
    checkPreferences(prefs) {
      Common.checkPreferences(prefs);
    },
    compile(schema, options) {
      return Compile.compile(this, schema, options);
    },
    defaults(modifier) {
      Assert(typeof modifier === "function", "modifier must be a function");
      const joi = Object.assign({}, this);
      for (const type2 of joi._types) {
        const schema = modifier(joi[type2]());
        Assert(Common.isSchema(schema), "modifier must return a valid schema object");
        joi[type2] = function(...args2) {
          return internals.generate(this, schema, args2);
        };
      }
      return joi;
    },
    expression(...args2) {
      return new Template(...args2);
    },
    extend(...extensions) {
      Common.verifyFlat(extensions, "extend");
      Schemas = Schemas || requireSchemas();
      Assert(extensions.length, "You need to provide at least one extension");
      this.assert(extensions, Schemas.extensions);
      const joi = Object.assign({}, this);
      joi._types = new Set(joi._types);
      for (let extension of extensions) {
        if (typeof extension === "function") {
          extension = extension(joi);
        }
        this.assert(extension, Schemas.extension);
        const expanded = internals.expandExtension(extension, joi);
        for (const item of expanded) {
          Assert(joi[item.type] === void 0 || joi._types.has(item.type), "Cannot override name", item.type);
          const base2 = item.base || this.any();
          const schema = Extend.type(base2, item);
          joi._types.add(item.type);
          joi[item.type] = function(...args2) {
            return internals.generate(this, schema, args2);
          };
        }
      }
      return joi;
    },
    isError: Errors.ValidationError.isError,
    isExpression: Template.isTemplate,
    isRef: Ref.isRef,
    isSchema: Common.isSchema,
    in(...args2) {
      return Ref.in(...args2);
    },
    override: Common.symbols.override,
    ref(...args2) {
      return Ref.create(...args2);
    },
    types() {
      const types2 = {};
      for (const type2 of this._types) {
        types2[type2] = this[type2]();
      }
      for (const target in internals.aliases) {
        types2[target] = this[target]();
      }
      return types2;
    }
  };
  internals.assert = function(value, schema, annotate2, args2) {
    const message = args2[0] instanceof Error || typeof args2[0] === "string" ? args2[0] : null;
    const options = message !== null ? args2[1] : args2[0];
    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));
    let error2 = result.error;
    if (!error2) {
      return result.value;
    }
    if (message instanceof Error) {
      throw message;
    }
    const display = annotate2 && typeof error2.annotate === "function" ? error2.annotate() : error2.message;
    if (error2 instanceof Errors.ValidationError === false) {
      error2 = Clone(error2);
    }
    error2.message = message ? `${message} ${display}` : display;
    throw error2;
  };
  internals.generate = function(root, schema, args2) {
    Assert(root, "Must be invoked on a Joi instance.");
    schema.$_root = root;
    if (!schema._definition.args || !args2.length) {
      return schema;
    }
    return schema._definition.args(schema, ...args2);
  };
  internals.expandExtension = function(extension, joi) {
    if (typeof extension.type === "string") {
      return [extension];
    }
    const extended = [];
    for (const type2 of joi._types) {
      if (extension.type.test(type2)) {
        const item = Object.assign({}, extension);
        item.type = type2;
        item.base = joi[type2]();
        extended.push(item);
      }
    }
    return extended;
  };
  lib = internals.root();
  return lib;
}
var delayed_stream;
var hasRequiredDelayed_stream;
function requireDelayed_stream() {
  if (hasRequiredDelayed_stream) return delayed_stream;
  hasRequiredDelayed_stream = 1;
  var Stream = require$$0$2.Stream;
  var util = require$$1;
  delayed_stream = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {
    });
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args2) {
      this.emit.apply(this, args2);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args2) {
    if (this._released) {
      this.emit.apply(this, args2);
      return;
    }
    if (args2[0] === "data") {
      this.dataSize += args2[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args2);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
  return delayed_stream;
}
var combined_stream;
var hasRequiredCombined_stream;
function requireCombined_stream() {
  if (hasRequiredCombined_stream) return combined_stream;
  hasRequiredCombined_stream = 1;
  var util = require$$1;
  var Stream = require$$0$2.Stream;
  var DelayedStream = requireDelayed_stream();
  combined_stream = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
  return combined_stream;
}
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana" },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/ecmascript": { "source": "iana", "compressible": true, "extensions": ["es", "ecma"] },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "apache", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": false, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["asc", "sig"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "iana" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "iana" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana" },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "iana" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "iana" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.frogans.fnc": { "source": "iana", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "iana", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.geo+json": { "source": "iana", "compressible": true },
  "application/vnd.geocube+xml": { "source": "iana", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.slides": { "source": "iana" },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "iana", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hl7cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "iana" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "iana", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "iana" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "iana", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "iana", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.youtube.yt": { "source": "iana" },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana" },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "iana" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/hsj2": { "source": "iana", "extensions": ["hsj2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpeg", "jpg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "apache", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/news": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime"] },
  "message/s-http": { "source": "iana" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "iana" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/step": { "source": "iana" },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana" },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "iana" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "compressible": true },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["markdown", "md"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "iana" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "iana" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  mimeDb = require$$0;
  return mimeDb;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes;
  hasRequiredMimeTypes = 1;
  (function(exports2) {
    var db = requireMimeDb();
    var extname = require$$1$1.extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types2[extension2]) {
            var from2 = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from2 > to || from2 === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type2;
        }
      });
    }
  })(mimeTypes);
  return mimeTypes;
}
var defer_1;
var hasRequiredDefer$1;
function requireDefer$1() {
  if (hasRequiredDefer$1) return defer_1;
  hasRequiredDefer$1 = 1;
  defer_1 = defer2;
  function defer2(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
  return defer_1;
}
var async_1;
var hasRequiredAsync$1;
function requireAsync$1() {
  if (hasRequiredAsync$1) return async_1;
  hasRequiredAsync$1 = 1;
  var defer2 = requireDefer$1();
  async_1 = async2;
  function async2(callback) {
    var isAsync = false;
    defer2(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer2(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
  return async_1;
}
var abort_1;
var hasRequiredAbort;
function requireAbort() {
  if (hasRequiredAbort) return abort_1;
  hasRequiredAbort = 1;
  abort_1 = abort;
  function abort(state2) {
    Object.keys(state2.jobs).forEach(clean.bind(state2));
    state2.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
  return abort_1;
}
var iterate_1;
var hasRequiredIterate;
function requireIterate() {
  if (hasRequiredIterate) return iterate_1;
  hasRequiredIterate = 1;
  var async2 = requireAsync$1(), abort = requireAbort();
  iterate_1 = iterate;
  function iterate(list, iterator2, state2, callback) {
    var key = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
    state2.jobs[key] = runJob(iterator2, key, list[key], function(error2, output) {
      if (!(key in state2.jobs)) {
        return;
      }
      delete state2.jobs[key];
      if (error2) {
        abort(state2);
      } else {
        state2.results[key] = output;
      }
      callback(error2, state2.results);
    });
  }
  function runJob(iterator2, key, item, callback) {
    var aborter;
    if (iterator2.length == 2) {
      aborter = iterator2(item, async2(callback));
    } else {
      aborter = iterator2(item, key, async2(callback));
    }
    return aborter;
  }
  return iterate_1;
}
var state_1;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state_1;
  hasRequiredState = 1;
  state_1 = state2;
  function state2(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
  return state_1;
}
var terminator_1;
var hasRequiredTerminator;
function requireTerminator() {
  if (hasRequiredTerminator) return terminator_1;
  hasRequiredTerminator = 1;
  var abort = requireAbort(), async2 = requireAsync$1();
  terminator_1 = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async2(callback)(null, this.results);
  }
  return terminator_1;
}
var parallel_1;
var hasRequiredParallel;
function requireParallel() {
  if (hasRequiredParallel) return parallel_1;
  hasRequiredParallel = 1;
  var iterate = requireIterate(), initState = requireState(), terminator = requireTerminator();
  parallel_1 = parallel;
  function parallel(list, iterator2, callback) {
    var state2 = initState(list);
    while (state2.index < (state2["keyedList"] || list).length) {
      iterate(list, iterator2, state2, function(error2, result) {
        if (error2) {
          callback(error2, result);
          return;
        }
        if (Object.keys(state2.jobs).length === 0) {
          callback(null, state2.results);
          return;
        }
      });
      state2.index++;
    }
    return terminator.bind(state2, callback);
  }
  return parallel_1;
}
var serialOrdered = { exports: {} };
var hasRequiredSerialOrdered;
function requireSerialOrdered() {
  if (hasRequiredSerialOrdered) return serialOrdered.exports;
  hasRequiredSerialOrdered = 1;
  var iterate = requireIterate(), initState = requireState(), terminator = requireTerminator();
  serialOrdered.exports = serialOrdered$1;
  serialOrdered.exports.ascending = ascending;
  serialOrdered.exports.descending = descending;
  function serialOrdered$1(list, iterator2, sortMethod, callback) {
    var state2 = initState(list, sortMethod);
    iterate(list, iterator2, state2, function iteratorHandler(error2, result) {
      if (error2) {
        callback(error2, result);
        return;
      }
      state2.index++;
      if (state2.index < (state2["keyedList"] || list).length) {
        iterate(list, iterator2, state2, iteratorHandler);
        return;
      }
      callback(null, state2.results);
    });
    return terminator.bind(state2, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
  return serialOrdered.exports;
}
var serial_1;
var hasRequiredSerial;
function requireSerial() {
  if (hasRequiredSerial) return serial_1;
  hasRequiredSerial = 1;
  var serialOrdered2 = requireSerialOrdered();
  serial_1 = serial;
  function serial(list, iterator2, callback) {
    return serialOrdered2(list, iterator2, null, callback);
  }
  return serial_1;
}
var asynckit;
var hasRequiredAsynckit;
function requireAsynckit() {
  if (hasRequiredAsynckit) return asynckit;
  hasRequiredAsynckit = 1;
  asynckit = {
    parallel: requireParallel(),
    serial: requireSerial(),
    serialOrdered: requireSerialOrdered()
  };
  return asynckit;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range$1;
var hasRequiredRange$1;
function requireRange$1() {
  if (hasRequiredRange$1) return range$1;
  hasRequiredRange$1 = 1;
  range$1 = RangeError;
  return range$1;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max$1;
var hasRequiredMax$1;
function requireMax$1() {
  if (hasRequiredMax$1) return max$1;
  hasRequiredMax$1 = 1;
  max$1 = Math.max;
  return max$1;
}
var min$1;
var hasRequiredMin$1;
function requireMin$1() {
  if (hasRequiredMin$1) return min$1;
  hasRequiredMin$1 = 1;
  min$1 = Math.min;
  return min$1;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number2) {
    if ($isNaN(number2) || number2 === 0) {
      return number2;
    }
    return number2 < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args2 = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args2, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args2, arguments)
      );
    };
    var boundLength = max2(0, target.length - args2.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args2) {
    if (args2.length < 1 || typeof args2[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args2);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();
  hasown = bind.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange$1();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax$1();
  var min2 = /* @__PURE__ */ requireMin$1();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string2) {
    var first2 = $strSlice(string2, 0, 1);
    var last2 = $strSlice(string2, -1);
    if (first2 === "%" && last2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last2 === "%" && first2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string2, rePropName, function(match, number2, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first2 = $strSlice(part, 0, 1);
      var last2 = $strSlice(part, -1);
      if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var esSetTostringtag;
var hasRequiredEsSetTostringtag;
function requireEsSetTostringtag() {
  if (hasRequiredEsSetTostringtag) return esSetTostringtag;
  hasRequiredEsSetTostringtag = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasToStringTag = requireShams()();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $TypeError = /* @__PURE__ */ requireType();
  var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
  esSetTostringtag = function setToStringTag(object2, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
      throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
    }
    if (toStringTag && (overrideIfSet || !hasOwn(object2, toStringTag))) {
      if ($defineProperty) {
        $defineProperty(object2, toStringTag, {
          configurable: !nonConfigurable,
          enumerable: false,
          value,
          writable: false
        });
      } else {
        object2[toStringTag] = value;
      }
    }
  };
  return esSetTostringtag;
}
var populate;
var hasRequiredPopulate;
function requirePopulate() {
  if (hasRequiredPopulate) return populate;
  hasRequiredPopulate = 1;
  populate = function(dst, src2) {
    Object.keys(src2).forEach(function(prop) {
      dst[prop] = dst[prop] || src2[prop];
    });
    return dst;
  };
  return populate;
}
var form_data;
var hasRequiredForm_data;
function requireForm_data() {
  if (hasRequiredForm_data) return form_data;
  hasRequiredForm_data = 1;
  var CombinedStream = requireCombined_stream();
  var util = require$$1;
  var path = require$$1$1;
  var http = require$$3;
  var https = require$$4;
  var parseUrl = require$$0$1.parse;
  var fs = require$$6;
  var Stream = require$$0$2.Stream;
  var mime = requireMimeTypes();
  var asynckit2 = requireAsynckit();
  var setToStringTag = /* @__PURE__ */ requireEsSetTostringtag();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var populate2 = requirePopulate();
  function FormData2(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  util.inherits(FormData2, CombinedStream);
  FormData2.LINE_BREAK = "\r\n";
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options === "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value === "number" || value == null) {
      value = String(value);
    }
    if (Array.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += Number(options.knownLength);
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (hasOwn(value, "fd")) {
      if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          if (err) {
            callback(err);
            return;
          }
          var fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (hasOwn(value, "httpVersion")) {
      callback(null, Number(value.headers["content-length"]));
    } else if (hasOwn(value, "httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, Number(response.headers["content-length"]));
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header === "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      // add custom disposition as third element or keep it two elements if not
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      // if no content type. allow it to be empty array
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header === "object") {
      populate2(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (hasOwn(headers, prop)) {
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value && (value.name || value.path)) {
      filename = path.basename(options.filename || value && (value.name || value.path));
    } else if (value && value.readable && hasOwn(value, "httpVersion")) {
      filename = path.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      return 'filename="' + filename + '"';
    }
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && value && typeof value === "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (hasOwn(userHeaders, header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    if (typeof boundary !== "string") {
      throw new TypeError("FormData boundary must be a string");
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length; i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0; i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit2.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values2) {
      if (err) {
        cb(err);
        return;
      }
      values2.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request;
    var options;
    var defaults = { method: "post" };
    if (typeof params === "string") {
      params = parseUrl(params);
      options = populate2({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate2(params, defaults);
      if (!options.port) {
        options.port = options.protocol === "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol === "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error2, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error2, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
  setToStringTag(FormData2, "FormData");
  form_data = FormData2;
  return form_data;
}
var proxyFromEnv = {};
var hasRequiredProxyFromEnv;
function requireProxyFromEnv() {
  if (hasRequiredProxyFromEnv) return proxyFromEnv;
  hasRequiredProxyFromEnv = 1;
  var parseUrl = require$$0$1.parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url) {
    var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  proxyFromEnv.getProxyForUrl = getProxyForUrl;
  return proxyFromEnv;
}
var followRedirects = { exports: {} };
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args2) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template2) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template2.length && (template2[templateIndex] === search[searchIndex] || template2[templateIndex] === "*")) {
          if (template2[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template2.length && template2[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template2.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip2 of createDebug.skips) {
        if (matchesTemplate(name, skip2)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module2, exports2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = requireCommon()(exports2);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$0$3;
  const tty = require$$1$2;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function(module2, exports2) {
    const tty = require$$1$2;
    const util = require$$1;
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args2) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = getDate() + name + " " + args2[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args2) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args2) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys2 = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
      }
    }
    module2.exports = requireCommon()(exports2);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    src.exports = requireBrowser();
  } else {
    src.exports = requireNode();
  }
  return src.exports;
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  var debug;
  debug_1 = function() {
    if (!debug) {
      try {
        debug = requireSrc()("follow-redirects");
      } catch (error2) {
      }
      if (typeof debug !== "function") {
        debug = function() {
        };
      }
    }
    debug.apply(null, arguments);
  };
  return debug_1;
}
var hasRequiredFollowRedirects;
function requireFollowRedirects() {
  if (hasRequiredFollowRedirects) return followRedirects.exports;
  hasRequiredFollowRedirects = 1;
  var url = require$$0$1;
  var URL2 = url.URL;
  var http = require$$3;
  var https = require$$4;
  var Writable = require$$0$2.Writable;
  var assert2 = require$$4$1;
  var debug = requireDebug();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction2(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert2(new URL2(""));
  } catch (error2) {
    useNativeURL = error2.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = /* @__PURE__ */ Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType(
    "ERR_INVALID_URL",
    "Invalid URL",
    TypeError
  );
  var RedirectionError = createErrorType(
    "ERR_FR_REDIRECTION_FAILURE",
    "Redirected request failed"
  );
  var TooManyRedirectsError = createErrorType(
    "ERR_FR_TOO_MANY_REDIRECTS",
    "Maximum number of redirects exceeded",
    RedirectionError
  );
  var MaxBodyLengthExceededError = createErrorType(
    "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
    "Request body larger than maxBodyLength limit"
  );
  var WriteAfterEndError = createErrorType(
    "ERR_STREAM_WRITE_AFTER_END",
    "write after end"
  );
  var destroy = Writable.prototype.destroy || noop2;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      try {
        self2._processResponse(response);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error2) {
    destroyRequest(this._currentRequest, error2);
    destroy.call(this, error2);
    return this;
  };
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError();
    }
    if (!isString(data) && !isBuffer(data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({ data, encoding });
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError());
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (isFunction2(data)) {
      callback = data;
      data = encoding = null;
    } else if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events) {
      request.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
      // When making a request to a proxy, []
      // a client MUST send the target URI in absolute-form [].
      this._options.path
    );
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error2) {
        if (request === self2._currentRequest) {
          if (error2) {
            self2.emit("error", error2);
          } else if (i < buffers.length) {
            var buffer2 = buffers[i++];
            if (!request.finished) {
              request.write(buffer2.data, buffer2.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError();
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        // The Host header was set by nativeProtocol.request
        Host: response.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource []
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) []
    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction2(beforeRedirect)) {
      var responseDetails = {
        headers: response.headers,
        statusCode
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap(protocols) {
    var exports2 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction2(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports2.maxRedirects,
          maxBodyLength: exports2.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString(options.host) && !isString(options.hostname)) {
          options.hostname = "::1";
        }
        assert2.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get2(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request, configurable: true, enumerable: true, writable: true },
        get: { value: get2, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports2;
  }
  function noop2() {
  }
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url.parse(input));
      if (!isString(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base2) {
    return useNativeURL ? new URL2(relative, base2) : parseUrl(url.resolve(base2, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields) {
      spread[key] = urlObject[key];
    }
    if (spread.hostname.startsWith("[")) {
      spread.hostname = spread.hostname.slice(1, -1);
    }
    if (spread.port !== "") {
      spread.port = Number(spread.port);
    }
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
  }
  function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
  }
  function createErrorType(code, message, baseClass) {
    function CustomError(properties) {
      if (isFunction2(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request, error2) {
    for (var event of events) {
      request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop2);
    request.destroy(error2);
  }
  function isSubdomain(subdomain, domain2) {
    assert2(isString(subdomain) && isString(domain2));
    var dot = subdomain.length - domain2.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain2);
  }
  function isString(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function isBuffer(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  followRedirects.exports = wrap({ http, https });
  followRedirects.exports.wrap = wrap;
  return followRedirects.exports;
}
/*! Axios v1.10.0 Copyright (c) 2025 Matt Zabriskie and contributors */
var axios_1;
var hasRequiredAxios;
function requireAxios() {
  if (hasRequiredAxios) return axios_1;
  hasRequiredAxios = 1;
  const FormData$1 = requireForm_data();
  const crypto = require$$1$3;
  const url = require$$0$1;
  const proxyFromEnv2 = requireProxyFromEnv();
  const http = require$$3;
  const https = require$$4;
  const util = require$$1;
  const followRedirects2 = requireFollowRedirects();
  const zlib = require$$8;
  const stream = require$$0$2;
  const events = require$$10;
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  const FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
  const crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto);
  const url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
  const proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv2);
  const http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
  const https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
  const util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
  const followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects2);
  const zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
  const stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const { iterator: iterator2, toStringTag } = Symbol;
  const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
    const str = toString.call(thing);
    return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type2) => {
    type2 = type2.toLowerCase();
    return (thing) => kindOf(thing) === type2;
  };
  const typeOfTest = (type2) => (thing) => typeof thing === type2;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction2 = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator2 in val);
  };
  const isDate2 = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction2(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction2(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys2 = Object.keys(obj);
    let i = keys2.length;
    let _key;
    while (i-- > 0) {
      _key = keys2[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : commonjsGlobal;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge2() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge2(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge2({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  const extend2 = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(b, (val, key) => {
      if (thisArg && isFunction2(val)) {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray2 = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[iterator2];
    const _iterator = generator.call(obj);
    let result;
    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction2(value)) return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  };
  const noop2 = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction2(thing.append) && thing[toStringTag] === "FormData" && thing[iterator2]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction2(thing)) && isFunction2(thing.then) && isFunction2(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction2(_global.postMessage)
  );
  const asap2 = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const isIterable2 = (thing) => thing != null && isFunction2(thing[iterator2]);
  const utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate: isDate2,
    isFile,
    isBlob,
    isRegExp,
    isFunction: isFunction2,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge: merge2,
    extend: extend2,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray: toArray2,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop2,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap: asap2,
    isIterable: isIterable2
  };
  function AxiosError(message, code, config2, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config2 && (this.config = config2);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$1.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error2, code, config2, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error2, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error2.message, code, config2, request, response);
    axiosError.cause = error2;
    axiosError.name = error2.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new (FormData__default["default"] || FormData)();
    options = utils$1.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (utils$1.isBoolean(value)) {
        return value.toString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils$1.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils$1.forEach(value, function each(el, key) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$1.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url2, params, options) {
    if (!params) {
      return url2;
    }
    const _encode = options && options.encode || encode;
    if (utils$1.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }
  const InterceptorManager$1 = InterceptorManager;
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams = url__default["default"].URLSearchParams;
  const ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT = "0123456789";
  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length } = alphabet;
    const randomValues = new Uint32Array(size);
    crypto__default["default"].randomFillSync(randomValues);
    for (let i = 0; i < size; i++) {
      str += alphabet[randomValues[i] % length];
    }
    return str;
  };
  const platform$1 = {
    isNode: true,
    classes: {
      URLSearchParams,
      FormData: FormData__default["default"],
      Blob: typeof Blob !== "undefined" && Blob || null
    },
    ALPHABET,
    generateString,
    protocols: ["http", "https", "file", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  const utils2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    hasStandardBrowserEnv,
    navigator: _navigator,
    origin
  });
  const platform = {
    ...utils2,
    ...platform$1
  };
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform.isNode && utils$1.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  function parsePropPath(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i;
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  const defaults$1 = defaults;
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
      i = line.indexOf(":");
      key = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils$1.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value)) return;
    if (utils$1.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils$1.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils$1.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
        let obj = {}, dest, key;
        for (const entry of header) {
          if (!utils$1.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils$1.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i = keys2.length;
      let deleted = false;
      while (i--) {
        const key = keys2[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key = utils$1.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first2, ...targets) {
      const computed = new this(first2);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders);
  const AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config2 = this || defaults$1;
    const context = response || config2;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config2, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function isAbsoluteURL(url2) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const VERSION = "1.10.0";
  function parseProtocol(url2) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
    return match && match[1] || "";
  }
  const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
  function fromDataURI(uri2, asBlob, options) {
    const _Blob = options && options.Blob || platform.classes.Blob;
    const protocol = parseProtocol(uri2);
    if (asBlob === void 0 && _Blob) {
      asBlob = true;
    }
    if (protocol === "data") {
      uri2 = protocol.length ? uri2.slice(protocol.length + 1) : uri2;
      const match = DATA_URL_PATTERN.exec(uri2);
      if (!match) {
        throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
      }
      const mime = match[1];
      const isBase64 = match[2];
      const body = match[3];
      const buffer2 = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
      if (asBlob) {
        if (!_Blob) {
          throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
        }
        return new _Blob([buffer2], { type: mime });
      }
      return buffer2;
    }
    throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
  }
  const kInternals = Symbol("internals");
  class AxiosTransformStream extends stream__default["default"].Transform {
    constructor(options) {
      options = utils$1.toFlatObject(options, {
        maxRate: 0,
        chunkSize: 64 * 1024,
        minChunkSize: 100,
        timeWindow: 500,
        ticksRate: 2,
        samplesCount: 15
      }, null, (prop, source) => {
        return !utils$1.isUndefined(source[prop]);
      });
      super({
        readableHighWaterMark: options.chunkSize
      });
      const internals = this[kInternals] = {
        timeWindow: options.timeWindow,
        chunkSize: options.chunkSize,
        maxRate: options.maxRate,
        minChunkSize: options.minChunkSize,
        bytesSeen: 0,
        isCaptured: false,
        notifiedBytesLoaded: 0,
        ts: Date.now(),
        bytes: 0,
        onReadCallback: null
      };
      this.on("newListener", (event) => {
        if (event === "progress") {
          if (!internals.isCaptured) {
            internals.isCaptured = true;
          }
        }
      });
    }
    _read(size) {
      const internals = this[kInternals];
      if (internals.onReadCallback) {
        internals.onReadCallback();
      }
      return super._read(size);
    }
    _transform(chunk, encoding, callback) {
      const internals = this[kInternals];
      const maxRate = internals.maxRate;
      const readableHighWaterMark = this.readableHighWaterMark;
      const timeWindow = internals.timeWindow;
      const divider = 1e3 / timeWindow;
      const bytesThreshold = maxRate / divider;
      const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
      const pushChunk = (_chunk, _callback) => {
        const bytes = Buffer.byteLength(_chunk);
        internals.bytesSeen += bytes;
        internals.bytes += bytes;
        internals.isCaptured && this.emit("progress", internals.bytesSeen);
        if (this.push(_chunk)) {
          process.nextTick(_callback);
        } else {
          internals.onReadCallback = () => {
            internals.onReadCallback = null;
            process.nextTick(_callback);
          };
        }
      };
      const transformChunk = (_chunk, _callback) => {
        const chunkSize = Buffer.byteLength(_chunk);
        let chunkRemainder = null;
        let maxChunkSize = readableHighWaterMark;
        let bytesLeft;
        let passed = 0;
        if (maxRate) {
          const now = Date.now();
          if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
            internals.ts = now;
            bytesLeft = bytesThreshold - internals.bytes;
            internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
            passed = 0;
          }
          bytesLeft = bytesThreshold - internals.bytes;
        }
        if (maxRate) {
          if (bytesLeft <= 0) {
            return setTimeout(() => {
              _callback(null, _chunk);
            }, timeWindow - passed);
          }
          if (bytesLeft < maxChunkSize) {
            maxChunkSize = bytesLeft;
          }
        }
        if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
          chunkRemainder = _chunk.subarray(maxChunkSize);
          _chunk = _chunk.subarray(0, maxChunkSize);
        }
        pushChunk(_chunk, chunkRemainder ? () => {
          process.nextTick(_callback, null, chunkRemainder);
        } : _callback);
      };
      transformChunk(chunk, function transformNextChunk(err, _chunk) {
        if (err) {
          return callback(err);
        }
        if (_chunk) {
          transformChunk(_chunk, transformNextChunk);
        } else {
          callback(null);
        }
      });
    }
  }
  const AxiosTransformStream$1 = AxiosTransformStream;
  const { asyncIterator } = Symbol;
  const readBlob = async function* (blob) {
    if (blob.stream) {
      yield* blob.stream();
    } else if (blob.arrayBuffer) {
      yield await blob.arrayBuffer();
    } else if (blob[asyncIterator]) {
      yield* blob[asyncIterator]();
    } else {
      yield blob;
    }
  };
  const readBlob$1 = readBlob;
  const BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
  const textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util__default["default"].TextEncoder();
  const CRLF = "\r\n";
  const CRLF_BYTES = textEncoder.encode(CRLF);
  const CRLF_BYTES_COUNT = 2;
  class FormDataPart {
    constructor(name, value) {
      const { escapeName } = this.constructor;
      const isStringValue = utils$1.isString(value);
      let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
      if (isStringValue) {
        value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
      } else {
        headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
      }
      this.headers = textEncoder.encode(headers + CRLF);
      this.contentLength = isStringValue ? value.byteLength : value.size;
      this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
      this.name = name;
      this.value = value;
    }
    async *encode() {
      yield this.headers;
      const { value } = this;
      if (utils$1.isTypedArray(value)) {
        yield value;
      } else {
        yield* readBlob$1(value);
      }
      yield CRLF_BYTES;
    }
    static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        "\r": "%0D",
        "\n": "%0A",
        '"': "%22"
      })[match]);
    }
  }
  const formDataToStream = (form, headersHandler, options) => {
    const {
      tag = "form-data-boundary",
      size = 25,
      boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
    } = options || {};
    if (!utils$1.isFormData(form)) {
      throw TypeError("FormData instance required");
    }
    if (boundary.length < 1 || boundary.length > 70) {
      throw Error("boundary must be 10-70 characters long");
    }
    const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
    const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
    let contentLength = footerBytes.byteLength;
    const parts = Array.from(form.entries()).map(([name, value]) => {
      const part = new FormDataPart(name, value);
      contentLength += part.size;
      return part;
    });
    contentLength += boundaryBytes.byteLength * parts.length;
    contentLength = utils$1.toFiniteNumber(contentLength);
    const computedHeaders = {
      "Content-Type": `multipart/form-data; boundary=${boundary}`
    };
    if (Number.isFinite(contentLength)) {
      computedHeaders["Content-Length"] = contentLength;
    }
    headersHandler && headersHandler(computedHeaders);
    return stream.Readable.from(async function* () {
      for (const part of parts) {
        yield boundaryBytes;
        yield* part.encode();
      }
      yield footerBytes;
    }());
  };
  const formDataToStream$1 = formDataToStream;
  class ZlibHeaderTransformStream extends stream__default["default"].Transform {
    __transform(chunk, encoding, callback) {
      this.push(chunk);
      callback();
    }
    _transform(chunk, encoding, callback) {
      if (chunk.length !== 0) {
        this._transform = this.__transform;
        if (chunk[0] !== 120) {
          const header = Buffer.alloc(2);
          header[0] = 120;
          header[1] = 156;
          this.push(header, encoding);
        }
      }
      this.__transform(chunk, encoding, callback);
    }
  }
  const ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
  const callbackify = (fn, reducer) => {
    return utils$1.isAsyncFn(fn) ? function(...args2) {
      const cb = args2.pop();
      fn.apply(this, args2).then((value) => {
        try {
          reducer ? cb(null, ...reducer(value)) : cb(null, value);
        } catch (err) {
          cb(err);
        }
      }, cb);
    } : fn;
  };
  const callbackify$1 = callbackify;
  function speedometer(samplesCount, min2) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min2 = min2 !== void 0 ? min2 : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min2) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle2(fn, freq) {
    let timestamp2 = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer2;
    const invoke = (args2, now = Date.now()) => {
      timestamp2 = now;
      lastArgs = null;
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      fn.apply(null, args2);
    };
    const throttled = (...args2) => {
      const now = Date.now();
      const passed = now - timestamp2;
      if (passed >= threshold) {
        invoke(args2, now);
      } else {
        lastArgs = args2;
        if (!timer2) {
          timer2 = setTimeout(() => {
            timer2 = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle2((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn) => (...args2) => utils$1.asap(() => fn(...args2));
  const zlibOptions = {
    flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
    finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
  };
  const brotliOptions = {
    flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
    finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
  };
  const isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
  const { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
  const isHttps = /https:?/;
  const supportedProtocols = platform.protocols.map((protocol) => {
    return protocol + ":";
  });
  const flushOnFinish = (stream2, [throttled, flush]) => {
    stream2.on("end", flush).on("error", flush);
    return throttled;
  };
  function dispatchBeforeRedirect(options, responseDetails) {
    if (options.beforeRedirects.proxy) {
      options.beforeRedirects.proxy(options);
    }
    if (options.beforeRedirects.config) {
      options.beforeRedirects.config(options, responseDetails);
    }
  }
  function setProxy(options, configProxy, location) {
    let proxy = configProxy;
    if (!proxy && proxy !== false) {
      const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
      if (proxyUrl) {
        proxy = new URL(proxyUrl);
      }
    }
    if (proxy) {
      if (proxy.username) {
        proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
      }
      if (proxy.auth) {
        if (proxy.auth.username || proxy.auth.password) {
          proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
        }
        const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
      const proxyHost = proxy.hostname || proxy.host;
      options.hostname = proxyHost;
      options.host = proxyHost;
      options.port = proxy.port;
      options.path = location;
      if (proxy.protocol) {
        options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
      }
    }
    options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
      setProxy(redirectOptions, configProxy, redirectOptions.href);
    };
  }
  const isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
  const wrapAsync = (asyncExecutor) => {
    return new Promise((resolve, reject) => {
      let onDone;
      let isDone;
      const done = (value, isRejected) => {
        if (isDone) return;
        isDone = true;
        onDone && onDone(value, isRejected);
      };
      const _resolve = (value) => {
        done(value);
        resolve(value);
      };
      const _reject = (reason) => {
        done(reason, true);
        reject(reason);
      };
      asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
    });
  };
  const resolveFamily = ({ address, family }) => {
    if (!utils$1.isString(address)) {
      throw TypeError("address must be a string");
    }
    return {
      address,
      family: family || (address.indexOf(".") < 0 ? 6 : 4)
    };
  };
  const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
  const httpAdapter = isHttpAdapterSupported && function httpAdapter2(config2) {
    return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
      let { data, lookup, family } = config2;
      const { responseType, responseEncoding } = config2;
      const method = config2.method.toUpperCase();
      let isDone;
      let rejected = false;
      let req;
      if (lookup) {
        const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
        lookup = (hostname, opt, cb) => {
          _lookup(hostname, opt, (err, arg0, arg1) => {
            if (err) {
              return cb(err);
            }
            const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
            opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
          });
        };
      }
      const emitter = new events.EventEmitter();
      const onFinished = () => {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(abort);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", abort);
        }
        emitter.removeAllListeners();
      };
      onDone((value, isRejected) => {
        isDone = true;
        if (isRejected) {
          rejected = true;
          onFinished();
        }
      });
      function abort(reason) {
        emitter.emit("abort", !reason || reason.type ? new CanceledError(null, config2, req) : reason);
      }
      emitter.once("abort", reject);
      if (config2.cancelToken || config2.signal) {
        config2.cancelToken && config2.cancelToken.subscribe(abort);
        if (config2.signal) {
          config2.signal.aborted ? abort() : config2.signal.addEventListener("abort", abort);
        }
      }
      const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
      const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
      const protocol = parsed.protocol || supportedProtocols[0];
      if (protocol === "data:") {
        let convertedData;
        if (method !== "GET") {
          return settle(resolve, reject, {
            status: 405,
            statusText: "method not allowed",
            headers: {},
            config: config2
          });
        }
        try {
          convertedData = fromDataURI(config2.url, responseType === "blob", {
            Blob: config2.env && config2.env.Blob
          });
        } catch (err) {
          throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config2);
        }
        if (responseType === "text") {
          convertedData = convertedData.toString(responseEncoding);
          if (!responseEncoding || responseEncoding === "utf8") {
            convertedData = utils$1.stripBOM(convertedData);
          }
        } else if (responseType === "stream") {
          convertedData = stream__default["default"].Readable.from(convertedData);
        }
        return settle(resolve, reject, {
          data: convertedData,
          status: 200,
          statusText: "OK",
          headers: new AxiosHeaders$1(),
          config: config2
        });
      }
      if (supportedProtocols.indexOf(protocol) === -1) {
        return reject(new AxiosError(
          "Unsupported protocol " + protocol,
          AxiosError.ERR_BAD_REQUEST,
          config2
        ));
      }
      const headers = AxiosHeaders$1.from(config2.headers).normalize();
      headers.set("User-Agent", "axios/" + VERSION, false);
      const { onUploadProgress, onDownloadProgress } = config2;
      const maxRate = config2.maxRate;
      let maxUploadRate = void 0;
      let maxDownloadRate = void 0;
      if (utils$1.isSpecCompliantForm(data)) {
        const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
        data = formDataToStream$1(data, (formHeaders) => {
          headers.set(formHeaders);
        }, {
          tag: `axios-${VERSION}-boundary`,
          boundary: userBoundary && userBoundary[1] || void 0
        });
      } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
        headers.set(data.getHeaders());
        if (!headers.hasContentLength()) {
          try {
            const knownLength = await util__default["default"].promisify(data.getLength).call(data);
            Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          } catch (e) {
          }
        }
      } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
        data.size && headers.setContentType(data.type || "application/octet-stream");
        headers.setContentLength(data.size || 0);
        data = stream__default["default"].Readable.from(readBlob$1(data));
      } else if (data && !utils$1.isStream(data)) {
        if (Buffer.isBuffer(data)) ;
        else if (utils$1.isArrayBuffer(data)) {
          data = Buffer.from(new Uint8Array(data));
        } else if (utils$1.isString(data)) {
          data = Buffer.from(data, "utf-8");
        } else {
          return reject(new AxiosError(
            "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
            AxiosError.ERR_BAD_REQUEST,
            config2
          ));
        }
        headers.setContentLength(data.length, false);
        if (config2.maxBodyLength > -1 && data.length > config2.maxBodyLength) {
          return reject(new AxiosError(
            "Request body larger than maxBodyLength limit",
            AxiosError.ERR_BAD_REQUEST,
            config2
          ));
        }
      }
      const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
      if (utils$1.isArray(maxRate)) {
        maxUploadRate = maxRate[0];
        maxDownloadRate = maxRate[1];
      } else {
        maxUploadRate = maxDownloadRate = maxRate;
      }
      if (data && (onUploadProgress || maxUploadRate)) {
        if (!utils$1.isStream(data)) {
          data = stream__default["default"].Readable.from(data, { objectMode: false });
        }
        data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
          maxRate: utils$1.toFiniteNumber(maxUploadRate)
        })], utils$1.noop);
        onUploadProgress && data.on("progress", flushOnFinish(
          data,
          progressEventDecorator(
            contentLength,
            progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
          )
        ));
      }
      let auth = void 0;
      if (config2.auth) {
        const username = config2.auth.username || "";
        const password = config2.auth.password || "";
        auth = username + ":" + password;
      }
      if (!auth && parsed.username) {
        const urlUsername = parsed.username;
        const urlPassword = parsed.password;
        auth = urlUsername + ":" + urlPassword;
      }
      auth && headers.delete("authorization");
      let path;
      try {
        path = buildURL(
          parsed.pathname + parsed.search,
          config2.params,
          config2.paramsSerializer
        ).replace(/^\?/, "");
      } catch (err) {
        const customErr = new Error(err.message);
        customErr.config = config2;
        customErr.url = config2.url;
        customErr.exists = true;
        return reject(customErr);
      }
      headers.set(
        "Accept-Encoding",
        "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
        false
      );
      const options = {
        path,
        method,
        headers: headers.toJSON(),
        agents: { http: config2.httpAgent, https: config2.httpsAgent },
        auth,
        protocol,
        family,
        beforeRedirect: dispatchBeforeRedirect,
        beforeRedirects: {}
      };
      !utils$1.isUndefined(lookup) && (options.lookup = lookup);
      if (config2.socketPath) {
        options.socketPath = config2.socketPath;
      } else {
        options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
        options.port = parsed.port;
        setProxy(options, config2.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
      }
      let transport;
      const isHttpsRequest = isHttps.test(options.protocol);
      options.agent = isHttpsRequest ? config2.httpsAgent : config2.httpAgent;
      if (config2.transport) {
        transport = config2.transport;
      } else if (config2.maxRedirects === 0) {
        transport = isHttpsRequest ? https__default["default"] : http__default["default"];
      } else {
        if (config2.maxRedirects) {
          options.maxRedirects = config2.maxRedirects;
        }
        if (config2.beforeRedirect) {
          options.beforeRedirects.config = config2.beforeRedirect;
        }
        transport = isHttpsRequest ? httpsFollow : httpFollow;
      }
      if (config2.maxBodyLength > -1) {
        options.maxBodyLength = config2.maxBodyLength;
      } else {
        options.maxBodyLength = Infinity;
      }
      if (config2.insecureHTTPParser) {
        options.insecureHTTPParser = config2.insecureHTTPParser;
      }
      req = transport.request(options, function handleResponse(res) {
        if (req.destroyed) return;
        const streams = [res];
        const responseLength = +res.headers["content-length"];
        if (onDownloadProgress || maxDownloadRate) {
          const transformStream = new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxDownloadRate)
          });
          onDownloadProgress && transformStream.on("progress", flushOnFinish(
            transformStream,
            progressEventDecorator(
              responseLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
            )
          ));
          streams.push(transformStream);
        }
        let responseStream = res;
        const lastRequest = res.req || req;
        if (config2.decompress !== false && res.headers["content-encoding"]) {
          if (method === "HEAD" || res.statusCode === 204) {
            delete res.headers["content-encoding"];
          }
          switch ((res.headers["content-encoding"] || "").toLowerCase()) {
            /*eslint default-case:0*/
            case "gzip":
            case "x-gzip":
            case "compress":
            case "x-compress":
              streams.push(zlib__default["default"].createUnzip(zlibOptions));
              delete res.headers["content-encoding"];
              break;
            case "deflate":
              streams.push(new ZlibHeaderTransformStream$1());
              streams.push(zlib__default["default"].createUnzip(zlibOptions));
              delete res.headers["content-encoding"];
              break;
            case "br":
              if (isBrotliSupported) {
                streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                delete res.headers["content-encoding"];
              }
          }
        }
        responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
        const offListeners = stream__default["default"].finished(responseStream, () => {
          offListeners();
          onFinished();
        });
        const response = {
          status: res.statusCode,
          statusText: res.statusMessage,
          headers: new AxiosHeaders$1(res.headers),
          config: config2,
          request: lastRequest
        };
        if (responseType === "stream") {
          response.data = responseStream;
          settle(resolve, reject, response);
        } else {
          const responseBuffer = [];
          let totalResponseBytes = 0;
          responseStream.on("data", function handleStreamData(chunk) {
            responseBuffer.push(chunk);
            totalResponseBytes += chunk.length;
            if (config2.maxContentLength > -1 && totalResponseBytes > config2.maxContentLength) {
              rejected = true;
              responseStream.destroy();
              reject(new AxiosError(
                "maxContentLength size of " + config2.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config2,
                lastRequest
              ));
            }
          });
          responseStream.on("aborted", function handlerStreamAborted() {
            if (rejected) {
              return;
            }
            const err = new AxiosError(
              "stream has been aborted",
              AxiosError.ERR_BAD_RESPONSE,
              config2,
              lastRequest
            );
            responseStream.destroy(err);
            reject(err);
          });
          responseStream.on("error", function handleStreamError(err) {
            if (req.destroyed) return;
            reject(AxiosError.from(err, null, config2, lastRequest));
          });
          responseStream.on("end", function handleStreamEnd() {
            try {
              let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
              if (responseType !== "arraybuffer") {
                responseData = responseData.toString(responseEncoding);
                if (!responseEncoding || responseEncoding === "utf8") {
                  responseData = utils$1.stripBOM(responseData);
                }
              }
              response.data = responseData;
            } catch (err) {
              return reject(AxiosError.from(err, null, config2, response.request, response));
            }
            settle(resolve, reject, response);
          });
        }
        emitter.once("abort", (err) => {
          if (!responseStream.destroyed) {
            responseStream.emit("error", err);
            responseStream.destroy();
          }
        });
      });
      emitter.once("abort", (err) => {
        reject(err);
        req.destroy(err);
      });
      req.on("error", function handleRequestError(err) {
        reject(AxiosError.from(err, null, config2, req));
      });
      req.on("socket", function handleRequestSocket(socket) {
        socket.setKeepAlive(true, 1e3 * 60);
      });
      if (config2.timeout) {
        const timeout2 = parseInt(config2.timeout, 10);
        if (Number.isNaN(timeout2)) {
          reject(new AxiosError(
            "error trying to parse `config.timeout` to int",
            AxiosError.ERR_BAD_OPTION_VALUE,
            config2,
            req
          ));
          return;
        }
        req.setTimeout(timeout2, function handleRequestTimeout() {
          if (isDone) return;
          let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config2.transitional || transitionalDefaults;
          if (config2.timeoutErrorMessage) {
            timeoutErrorMessage = config2.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config2,
            req
          ));
          abort();
        });
      }
      if (utils$1.isStream(data)) {
        let ended = false;
        let errored = false;
        data.on("end", () => {
          ended = true;
        });
        data.once("error", (err) => {
          errored = true;
          req.destroy(err);
        });
        data.on("close", () => {
          if (!ended && !errored) {
            abort(new CanceledError("Request stream has been aborted", config2, req));
          }
        });
        data.pipe(req);
      } else {
        req.end(data);
      }
    });
  };
  const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
    url2 = new URL(url2, platform.origin);
    return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
  })(
    new URL(platform.origin),
    platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
  ) : () => true;
  const cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain2, secure) {
        const cookie = [name + "=" + encodeURIComponent(value)];
        utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils$1.isString(path) && cookie.push("path=" + path);
        utils$1.isString(domain2) && cookie.push("domain=" + domain2);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config3 = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap2 = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge3 = mergeMap2[prop] || mergeDeepProperties;
      const configValue = merge3(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
    });
    return config3;
  }
  const resolveConfig = (config2) => {
    const newConfig = mergeConfig({}, config2);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type2, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        headers.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config2);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config2,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config2,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout2) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout2 || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
        }
      };
      let timer2 = timeout2 && setTimeout(() => {
        timer2 = null;
        onabort(new AxiosError(`timeout ${timeout2} of ms exceeded`, AxiosError.ETIMEDOUT));
      }, timeout2);
      const unsubscribe = () => {
        if (signals) {
          timer2 && clearTimeout(timer2);
          timer2 = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$1.asap(unsubscribe);
      return signal;
    }
  };
  const composeSignals$1 = composeSignals;
  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
      end = pos + chunkSize;
      yield chunk.slice(pos, end);
      pos = end;
    }
  };
  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  const readStream = async function* (stream2) {
    if (stream2[Symbol.asyncIterator]) {
      yield* stream2;
      return;
    }
    const reader = stream2.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader.cancel();
    }
  };
  const trackStream = (stream2, chunkSize, onProgress, onFinish) => {
    const iterator3 = readBytes(stream2, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator3.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator3.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  const test = (fn, ...args2) => {
    try {
      return !!fn(...args2);
    } catch (e) {
      return false;
    }
  };
  const supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
      !resolvers[type2] && (resolvers[type2] = utils$1.isFunction(res[type2]) ? (res2) => res2[type2]() : (_, config2) => {
        throw new AxiosError(`Response type '${type2}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
      });
    });
  })(new Response());
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$1.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  const fetchAdapter = isFetchSupported && (async (config2) => {
    let {
      url: url2,
      method,
      data,
      signal,
      cancelToken,
      timeout: timeout2,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config2);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout2);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url2, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      });
      let response = await fetch(request, fetchOptions);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config: config2,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError.from(err, err && err.code, config2, request);
    }
  });
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state2]) => `adapter ${id} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
    if (config2.signal && config2.signal.aborted) {
      throw new CanceledError(null, config2);
    }
  }
  function dispatchRequest(config2) {
    throwIfCancellationRequested(config2);
    config2.headers = AxiosHeaders$1.from(config2.headers);
    config2.data = transformData.call(
      config2,
      config2.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
      config2.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
    return adapter(config2).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config2);
      response.data = transformData.call(
        config2,
        config2.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config2);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config2,
            config2.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
    validators$1[type2] = function validator3(thing) {
      return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator3, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator3 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator3 ? validator3(value, opt, opts) : true;
    };
  };
  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options);
    let i = keys2.length;
    while (i-- > 0) {
      const opt = keys2[i];
      const validator3 = schema[opt];
      if (validator3) {
        const value = options[opt];
        const result = value === void 0 || validator3(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  const validator2 = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator2.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config2) {
      try {
        return await this._request(configOrUrl, config2);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      const { transitional, paramsSerializer, headers } = config2;
      if (transitional !== void 0) {
        validator2.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config2.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator2.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      if (config2.allowAbsoluteUrls !== void 0) ;
      else if (this.defaults.allowAbsoluteUrls !== void 0) {
        config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config2.allowAbsoluteUrls = true;
      }
      validator2.assertOptions(config2, {
        baseUrl: validators.spelling("baseURL"),
        withXsrfToken: validators.spelling("withXSRFToken")
      }, true);
      config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config2.method]
      );
      headers && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config2);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config2;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error2) {
          onRejected.call(this, error2);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error2) {
        return Promise.reject(error2);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
      return buildURL(fullPath, config2.params, config2.paramsSerializer);
    }
  }
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url2, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        url: url2,
        data: (config2 || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url2, data, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: url2,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  const Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config2, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config2, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  }
  const CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  const HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);
    utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  axios_1 = axios;
  return axios_1;
}
var lodash_min$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash_min = lodash_min$1.exports;
var hasRequiredLodash_min;
function requireLodash_min() {
  if (hasRequiredLodash_min) return lodash_min$1.exports;
  hasRequiredLodash_min = 1;
  (function(module2, exports2) {
    (function() {
      function n(n2, t2, r2) {
        switch (r2.length) {
          case 0:
            return n2.call(t2);
          case 1:
            return n2.call(t2, r2[0]);
          case 2:
            return n2.call(t2, r2[0], r2[1]);
          case 3:
            return n2.call(t2, r2[0], r2[1], r2[2]);
        }
        return n2.apply(t2, r2);
      }
      function t(n2, t2, r2, e2) {
        for (var u2 = -1, i2 = null == n2 ? 0 : n2.length; ++u2 < i2; ) {
          var o2 = n2[u2];
          t2(e2, o2, r2(o2), n2);
        }
        return e2;
      }
      function r(n2, t2) {
        for (var r2 = -1, e2 = null == n2 ? 0 : n2.length; ++r2 < e2 && t2(n2[r2], r2, n2) !== false; ) ;
        return n2;
      }
      function e(n2, t2) {
        for (var r2 = null == n2 ? 0 : n2.length; r2-- && t2(n2[r2], r2, n2) !== false; ) ;
        return n2;
      }
      function u(n2, t2) {
        for (var r2 = -1, e2 = null == n2 ? 0 : n2.length; ++r2 < e2; ) if (!t2(n2[r2], r2, n2)) return false;
        return true;
      }
      function i(n2, t2) {
        for (var r2 = -1, e2 = null == n2 ? 0 : n2.length, u2 = 0, i2 = []; ++r2 < e2; ) {
          var o2 = n2[r2];
          t2(o2, r2, n2) && (i2[u2++] = o2);
        }
        return i2;
      }
      function o(n2, t2) {
        return !!(null == n2 ? 0 : n2.length) && y(n2, t2, 0) > -1;
      }
      function f(n2, t2, r2) {
        for (var e2 = -1, u2 = null == n2 ? 0 : n2.length; ++e2 < u2; ) if (r2(t2, n2[e2])) return true;
        return false;
      }
      function c(n2, t2) {
        for (var r2 = -1, e2 = null == n2 ? 0 : n2.length, u2 = Array(e2); ++r2 < e2; ) u2[r2] = t2(n2[r2], r2, n2);
        return u2;
      }
      function a(n2, t2) {
        for (var r2 = -1, e2 = t2.length, u2 = n2.length; ++r2 < e2; ) n2[u2 + r2] = t2[r2];
        return n2;
      }
      function l(n2, t2, r2, e2) {
        var u2 = -1, i2 = null == n2 ? 0 : n2.length;
        for (e2 && i2 && (r2 = n2[++u2]); ++u2 < i2; ) r2 = t2(r2, n2[u2], u2, n2);
        return r2;
      }
      function s(n2, t2, r2, e2) {
        var u2 = null == n2 ? 0 : n2.length;
        for (e2 && u2 && (r2 = n2[--u2]); u2--; ) r2 = t2(r2, n2[u2], u2, n2);
        return r2;
      }
      function h(n2, t2) {
        for (var r2 = -1, e2 = null == n2 ? 0 : n2.length; ++r2 < e2; ) if (t2(n2[r2], r2, n2)) return true;
        return false;
      }
      function p(n2) {
        return n2.split("");
      }
      function _(n2) {
        return n2.match($t) || [];
      }
      function v(n2, t2, r2) {
        var e2;
        return r2(n2, function(n3, r3, u2) {
          if (t2(n3, r3, u2)) return e2 = r3, false;
        }), e2;
      }
      function g(n2, t2, r2, e2) {
        for (var u2 = n2.length, i2 = r2 + (e2 ? 1 : -1); e2 ? i2-- : ++i2 < u2; ) if (t2(n2[i2], i2, n2)) return i2;
        return -1;
      }
      function y(n2, t2, r2) {
        return t2 === t2 ? Z(n2, t2, r2) : g(n2, b, r2);
      }
      function d(n2, t2, r2, e2) {
        for (var u2 = r2 - 1, i2 = n2.length; ++u2 < i2; ) if (e2(n2[u2], t2)) return u2;
        return -1;
      }
      function b(n2) {
        return n2 !== n2;
      }
      function w(n2, t2) {
        var r2 = null == n2 ? 0 : n2.length;
        return r2 ? k(n2, t2) / r2 : Cn;
      }
      function m(n2) {
        return function(t2) {
          return null == t2 ? X : t2[n2];
        };
      }
      function x(n2) {
        return function(t2) {
          return null == n2 ? X : n2[t2];
        };
      }
      function j(n2, t2, r2, e2, u2) {
        return u2(n2, function(n3, u3, i2) {
          r2 = e2 ? (e2 = false, n3) : t2(r2, n3, u3, i2);
        }), r2;
      }
      function A(n2, t2) {
        var r2 = n2.length;
        for (n2.sort(t2); r2--; ) n2[r2] = n2[r2].value;
        return n2;
      }
      function k(n2, t2) {
        for (var r2, e2 = -1, u2 = n2.length; ++e2 < u2; ) {
          var i2 = t2(n2[e2]);
          i2 !== X && (r2 = r2 === X ? i2 : r2 + i2);
        }
        return r2;
      }
      function O(n2, t2) {
        for (var r2 = -1, e2 = Array(n2); ++r2 < n2; ) e2[r2] = t2(r2);
        return e2;
      }
      function I(n2, t2) {
        return c(t2, function(t3) {
          return [t3, n2[t3]];
        });
      }
      function R(n2) {
        return n2 ? n2.slice(0, H(n2) + 1).replace(Lt, "") : n2;
      }
      function z(n2) {
        return function(t2) {
          return n2(t2);
        };
      }
      function E(n2, t2) {
        return c(t2, function(t3) {
          return n2[t3];
        });
      }
      function S(n2, t2) {
        return n2.has(t2);
      }
      function W(n2, t2) {
        for (var r2 = -1, e2 = n2.length; ++r2 < e2 && y(t2, n2[r2], 0) > -1; ) ;
        return r2;
      }
      function L(n2, t2) {
        for (var r2 = n2.length; r2-- && y(t2, n2[r2], 0) > -1; ) ;
        return r2;
      }
      function C(n2, t2) {
        for (var r2 = n2.length, e2 = 0; r2--; ) n2[r2] === t2 && ++e2;
        return e2;
      }
      function U(n2) {
        return "\\" + Yr[n2];
      }
      function B(n2, t2) {
        return null == n2 ? X : n2[t2];
      }
      function T(n2) {
        return Nr.test(n2);
      }
      function $(n2) {
        return Pr.test(n2);
      }
      function D(n2) {
        for (var t2, r2 = []; !(t2 = n2.next()).done; ) r2.push(t2.value);
        return r2;
      }
      function M(n2) {
        var t2 = -1, r2 = Array(n2.size);
        return n2.forEach(function(n3, e2) {
          r2[++t2] = [e2, n3];
        }), r2;
      }
      function F(n2, t2) {
        return function(r2) {
          return n2(t2(r2));
        };
      }
      function N(n2, t2) {
        for (var r2 = -1, e2 = n2.length, u2 = 0, i2 = []; ++r2 < e2; ) {
          var o2 = n2[r2];
          o2 !== t2 && o2 !== cn || (n2[r2] = cn, i2[u2++] = r2);
        }
        return i2;
      }
      function P(n2) {
        var t2 = -1, r2 = Array(n2.size);
        return n2.forEach(function(n3) {
          r2[++t2] = n3;
        }), r2;
      }
      function q(n2) {
        var t2 = -1, r2 = Array(n2.size);
        return n2.forEach(function(n3) {
          r2[++t2] = [n3, n3];
        }), r2;
      }
      function Z(n2, t2, r2) {
        for (var e2 = r2 - 1, u2 = n2.length; ++e2 < u2; ) if (n2[e2] === t2) return e2;
        return -1;
      }
      function K(n2, t2, r2) {
        for (var e2 = r2 + 1; e2--; ) if (n2[e2] === t2) return e2;
        return e2;
      }
      function V(n2) {
        return T(n2) ? J(n2) : _e(n2);
      }
      function G(n2) {
        return T(n2) ? Y(n2) : p(n2);
      }
      function H(n2) {
        for (var t2 = n2.length; t2-- && Ct.test(n2.charAt(t2)); ) ;
        return t2;
      }
      function J(n2) {
        for (var t2 = Mr.lastIndex = 0; Mr.test(n2); ) ++t2;
        return t2;
      }
      function Y(n2) {
        return n2.match(Mr) || [];
      }
      function Q(n2) {
        return n2.match(Fr) || [];
      }
      var X, nn = "4.17.21", tn = 200, rn = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", en = "Expected a function", un = "Invalid `variable` option passed into `_.template`", on = "__lodash_hash_undefined__", fn = 500, cn = "__lodash_placeholder__", an = 1, ln = 2, sn = 4, hn = 1, pn = 2, _n = 1, vn = 2, gn = 4, yn = 8, dn = 16, bn = 32, wn = 64, mn = 128, xn = 256, jn = 512, An = 30, kn = "...", On = 800, In = 16, Rn = 1, zn = 2, En = 3, Sn = 1 / 0, Wn = 9007199254740991, Ln = 17976931348623157e292, Cn = NaN, Un = 4294967295, Bn = Un - 1, Tn = Un >>> 1, $n = [["ary", mn], ["bind", _n], ["bindKey", vn], ["curry", yn], ["curryRight", dn], ["flip", jn], ["partial", bn], ["partialRight", wn], ["rearg", xn]], Dn = "[object Arguments]", Mn = "[object Array]", Fn = "[object AsyncFunction]", Nn = "[object Boolean]", Pn = "[object Date]", qn = "[object DOMException]", Zn = "[object Error]", Kn = "[object Function]", Vn = "[object GeneratorFunction]", Gn = "[object Map]", Hn = "[object Number]", Jn = "[object Null]", Yn = "[object Object]", Qn = "[object Promise]", Xn = "[object Proxy]", nt = "[object RegExp]", tt = "[object Set]", rt = "[object String]", et = "[object Symbol]", ut = "[object Undefined]", it = "[object WeakMap]", ot = "[object WeakSet]", ft = "[object ArrayBuffer]", ct = "[object DataView]", at = "[object Float32Array]", lt = "[object Float64Array]", st = "[object Int8Array]", ht = "[object Int16Array]", pt = "[object Int32Array]", _t = "[object Uint8Array]", vt = "[object Uint8ClampedArray]", gt = "[object Uint16Array]", yt = "[object Uint32Array]", dt = /\b__p \+= '';/g, bt = /\b(__p \+=) '' \+/g, wt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, mt = /&(?:amp|lt|gt|quot|#39);/g, xt = /[&<>"']/g, jt = RegExp(mt.source), At = RegExp(xt.source), kt = /<%-([\s\S]+?)%>/g, Ot = /<%([\s\S]+?)%>/g, It = /<%=([\s\S]+?)%>/g, Rt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, zt = /^\w*$/, Et = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, St = /[\\^$.*+?()[\]{}|]/g, Wt = RegExp(St.source), Lt = /^\s+/, Ct = /\s/, Ut = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Bt = /\{\n\/\* \[wrapped with (.+)\] \*/, Tt = /,? & /, $t = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Dt = /[()=,{}\[\]\/\s]/, Mt = /\\(\\)?/g, Ft = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Nt = /\w*$/, Pt = /^[-+]0x[0-9a-f]+$/i, qt = /^0b[01]+$/i, Zt = /^\[object .+?Constructor\]$/, Kt = /^0o[0-7]+$/i, Vt = /^(?:0|[1-9]\d*)$/, Gt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ht = /($^)/, Jt = /['\n\r\u2028\u2029\\]/g, Yt = "\\ud800-\\udfff", Qt = "\\u0300-\\u036f", Xt = "\\ufe20-\\ufe2f", nr = "\\u20d0-\\u20ff", tr = Qt + Xt + nr, rr = "\\u2700-\\u27bf", er = "a-z\\xdf-\\xf6\\xf8-\\xff", ur = "\\xac\\xb1\\xd7\\xf7", ir = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", or = "\\u2000-\\u206f", fr = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", cr = "A-Z\\xc0-\\xd6\\xd8-\\xde", ar = "\\ufe0e\\ufe0f", lr = ur + ir + or + fr, sr = "[']", hr = "[" + Yt + "]", pr = "[" + lr + "]", _r = "[" + tr + "]", vr = "\\d+", gr = "[" + rr + "]", yr = "[" + er + "]", dr = "[^" + Yt + lr + vr + rr + er + cr + "]", br = "\\ud83c[\\udffb-\\udfff]", wr = "(?:" + _r + "|" + br + ")", mr = "[^" + Yt + "]", xr = "(?:\\ud83c[\\udde6-\\uddff]){2}", jr = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ar = "[" + cr + "]", kr = "\\u200d", Or = "(?:" + yr + "|" + dr + ")", Ir = "(?:" + Ar + "|" + dr + ")", Rr = "(?:" + sr + "(?:d|ll|m|re|s|t|ve))?", zr = "(?:" + sr + "(?:D|LL|M|RE|S|T|VE))?", Er = wr + "?", Sr = "[" + ar + "]?", Wr = "(?:" + kr + "(?:" + [mr, xr, jr].join("|") + ")" + Sr + Er + ")*", Lr = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Cr = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Ur = Sr + Er + Wr, Br = "(?:" + [gr, xr, jr].join("|") + ")" + Ur, Tr = "(?:" + [mr + _r + "?", _r, xr, jr, hr].join("|") + ")", $r = RegExp(sr, "g"), Dr = RegExp(_r, "g"), Mr = RegExp(br + "(?=" + br + ")|" + Tr + Ur, "g"), Fr = RegExp([Ar + "?" + yr + "+" + Rr + "(?=" + [pr, Ar, "$"].join("|") + ")", Ir + "+" + zr + "(?=" + [pr, Ar + Or, "$"].join("|") + ")", Ar + "?" + Or + "+" + Rr, Ar + "+" + zr, Cr, Lr, vr, Br].join("|"), "g"), Nr = RegExp("[" + kr + Yt + tr + ar + "]"), Pr = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, qr = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Zr = -1, Kr = {};
      Kr[at] = Kr[lt] = Kr[st] = Kr[ht] = Kr[pt] = Kr[_t] = Kr[vt] = Kr[gt] = Kr[yt] = true, Kr[Dn] = Kr[Mn] = Kr[ft] = Kr[Nn] = Kr[ct] = Kr[Pn] = Kr[Zn] = Kr[Kn] = Kr[Gn] = Kr[Hn] = Kr[Yn] = Kr[nt] = Kr[tt] = Kr[rt] = Kr[it] = false;
      var Vr = {};
      Vr[Dn] = Vr[Mn] = Vr[ft] = Vr[ct] = Vr[Nn] = Vr[Pn] = Vr[at] = Vr[lt] = Vr[st] = Vr[ht] = Vr[pt] = Vr[Gn] = Vr[Hn] = Vr[Yn] = Vr[nt] = Vr[tt] = Vr[rt] = Vr[et] = Vr[_t] = Vr[vt] = Vr[gt] = Vr[yt] = true, Vr[Zn] = Vr[Kn] = Vr[it] = false;
      var Gr = {
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
      }, Hr = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Jr = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Yr = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Qr = parseFloat, Xr = parseInt, ne = "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, te = "object" == typeof self && self && self.Object === Object && self, re = ne || te || Function("return this")(), ee = exports2 && !exports2.nodeType && exports2, ue = ee && true && module2 && !module2.nodeType && module2, ie = ue && ue.exports === ee, oe = ie && ne.process, fe = function() {
        try {
          var n2 = ue && ue.require && ue.require("util").types;
          return n2 ? n2 : oe && oe.binding && oe.binding("util");
        } catch (n3) {
        }
      }(), ce = fe && fe.isArrayBuffer, ae = fe && fe.isDate, le = fe && fe.isMap, se = fe && fe.isRegExp, he = fe && fe.isSet, pe = fe && fe.isTypedArray, _e = m("length"), ve = x(Gr), ge = x(Hr), ye = x(Jr), de = function p2(x2) {
        function Z2(n2) {
          if (cc(n2) && !bh(n2) && !(n2 instanceof Ct2)) {
            if (n2 instanceof Y2) return n2;
            if (bl.call(n2, "__wrapped__")) return eo(n2);
          }
          return new Y2(n2);
        }
        function J2() {
        }
        function Y2(n2, t2) {
          this.__wrapped__ = n2, this.__actions__ = [], this.__chain__ = !!t2, this.__index__ = 0, this.__values__ = X;
        }
        function Ct2(n2) {
          this.__wrapped__ = n2, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Un, this.__views__ = [];
        }
        function $t2() {
          var n2 = new Ct2(this.__wrapped__);
          return n2.__actions__ = Tu(this.__actions__), n2.__dir__ = this.__dir__, n2.__filtered__ = this.__filtered__, n2.__iteratees__ = Tu(this.__iteratees__), n2.__takeCount__ = this.__takeCount__, n2.__views__ = Tu(this.__views__), n2;
        }
        function Yt2() {
          if (this.__filtered__) {
            var n2 = new Ct2(this);
            n2.__dir__ = -1, n2.__filtered__ = true;
          } else n2 = this.clone(), n2.__dir__ *= -1;
          return n2;
        }
        function Qt2() {
          var n2 = this.__wrapped__.value(), t2 = this.__dir__, r2 = bh(n2), e2 = t2 < 0, u2 = r2 ? n2.length : 0, i2 = Oi(0, u2, this.__views__), o2 = i2.start, f2 = i2.end, c2 = f2 - o2, a2 = e2 ? f2 : o2 - 1, l2 = this.__iteratees__, s2 = l2.length, h2 = 0, p3 = Hl(c2, this.__takeCount__);
          if (!r2 || !e2 && u2 == c2 && p3 == c2) return wu(n2, this.__actions__);
          var _2 = [];
          n: for (; c2-- && h2 < p3; ) {
            a2 += t2;
            for (var v2 = -1, g2 = n2[a2]; ++v2 < s2; ) {
              var y2 = l2[v2], d2 = y2.iteratee, b2 = y2.type, w2 = d2(g2);
              if (b2 == zn) g2 = w2;
              else if (!w2) {
                if (b2 == Rn) continue n;
                break n;
              }
            }
            _2[h2++] = g2;
          }
          return _2;
        }
        function Xt2(n2) {
          var t2 = -1, r2 = null == n2 ? 0 : n2.length;
          for (this.clear(); ++t2 < r2; ) {
            var e2 = n2[t2];
            this.set(e2[0], e2[1]);
          }
        }
        function nr2() {
          this.__data__ = is ? is(null) : {}, this.size = 0;
        }
        function tr2(n2) {
          var t2 = this.has(n2) && delete this.__data__[n2];
          return this.size -= t2 ? 1 : 0, t2;
        }
        function rr2(n2) {
          var t2 = this.__data__;
          if (is) {
            var r2 = t2[n2];
            return r2 === on ? X : r2;
          }
          return bl.call(t2, n2) ? t2[n2] : X;
        }
        function er2(n2) {
          var t2 = this.__data__;
          return is ? t2[n2] !== X : bl.call(t2, n2);
        }
        function ur2(n2, t2) {
          var r2 = this.__data__;
          return this.size += this.has(n2) ? 0 : 1, r2[n2] = is && t2 === X ? on : t2, this;
        }
        function ir2(n2) {
          var t2 = -1, r2 = null == n2 ? 0 : n2.length;
          for (this.clear(); ++t2 < r2; ) {
            var e2 = n2[t2];
            this.set(e2[0], e2[1]);
          }
        }
        function or2() {
          this.__data__ = [], this.size = 0;
        }
        function fr2(n2) {
          var t2 = this.__data__, r2 = Wr2(t2, n2);
          return !(r2 < 0) && (r2 == t2.length - 1 ? t2.pop() : Ll.call(t2, r2, 1), --this.size, true);
        }
        function cr2(n2) {
          var t2 = this.__data__, r2 = Wr2(t2, n2);
          return r2 < 0 ? X : t2[r2][1];
        }
        function ar2(n2) {
          return Wr2(this.__data__, n2) > -1;
        }
        function lr2(n2, t2) {
          var r2 = this.__data__, e2 = Wr2(r2, n2);
          return e2 < 0 ? (++this.size, r2.push([n2, t2])) : r2[e2][1] = t2, this;
        }
        function sr2(n2) {
          var t2 = -1, r2 = null == n2 ? 0 : n2.length;
          for (this.clear(); ++t2 < r2; ) {
            var e2 = n2[t2];
            this.set(e2[0], e2[1]);
          }
        }
        function hr2() {
          this.size = 0, this.__data__ = { hash: new Xt2(), map: new (ts || ir2)(), string: new Xt2() };
        }
        function pr2(n2) {
          var t2 = xi(this, n2).delete(n2);
          return this.size -= t2 ? 1 : 0, t2;
        }
        function _r2(n2) {
          return xi(this, n2).get(n2);
        }
        function vr2(n2) {
          return xi(this, n2).has(n2);
        }
        function gr2(n2, t2) {
          var r2 = xi(this, n2), e2 = r2.size;
          return r2.set(n2, t2), this.size += r2.size == e2 ? 0 : 1, this;
        }
        function yr2(n2) {
          var t2 = -1, r2 = null == n2 ? 0 : n2.length;
          for (this.__data__ = new sr2(); ++t2 < r2; ) this.add(n2[t2]);
        }
        function dr2(n2) {
          return this.__data__.set(n2, on), this;
        }
        function br2(n2) {
          return this.__data__.has(n2);
        }
        function wr2(n2) {
          this.size = (this.__data__ = new ir2(n2)).size;
        }
        function mr2() {
          this.__data__ = new ir2(), this.size = 0;
        }
        function xr2(n2) {
          var t2 = this.__data__, r2 = t2.delete(n2);
          return this.size = t2.size, r2;
        }
        function jr2(n2) {
          return this.__data__.get(n2);
        }
        function Ar2(n2) {
          return this.__data__.has(n2);
        }
        function kr2(n2, t2) {
          var r2 = this.__data__;
          if (r2 instanceof ir2) {
            var e2 = r2.__data__;
            if (!ts || e2.length < tn - 1) return e2.push([n2, t2]), this.size = ++r2.size, this;
            r2 = this.__data__ = new sr2(e2);
          }
          return r2.set(n2, t2), this.size = r2.size, this;
        }
        function Or2(n2, t2) {
          var r2 = bh(n2), e2 = !r2 && dh(n2), u2 = !r2 && !e2 && mh(n2), i2 = !r2 && !e2 && !u2 && Oh(n2), o2 = r2 || e2 || u2 || i2, f2 = o2 ? O(n2.length, hl) : [], c2 = f2.length;
          for (var a2 in n2) !t2 && !bl.call(n2, a2) || o2 && ("length" == a2 || u2 && ("offset" == a2 || "parent" == a2) || i2 && ("buffer" == a2 || "byteLength" == a2 || "byteOffset" == a2) || Ci(a2, c2)) || f2.push(a2);
          return f2;
        }
        function Ir2(n2) {
          var t2 = n2.length;
          return t2 ? n2[tu(0, t2 - 1)] : X;
        }
        function Rr2(n2, t2) {
          return Xi(Tu(n2), Mr2(t2, 0, n2.length));
        }
        function zr2(n2) {
          return Xi(Tu(n2));
        }
        function Er2(n2, t2, r2) {
          (r2 === X || Gf(n2[t2], r2)) && (r2 !== X || t2 in n2) || Br2(n2, t2, r2);
        }
        function Sr2(n2, t2, r2) {
          var e2 = n2[t2];
          bl.call(n2, t2) && Gf(e2, r2) && (r2 !== X || t2 in n2) || Br2(n2, t2, r2);
        }
        function Wr2(n2, t2) {
          for (var r2 = n2.length; r2--; ) if (Gf(n2[r2][0], t2)) return r2;
          return -1;
        }
        function Lr2(n2, t2, r2, e2) {
          return ys(n2, function(n3, u2, i2) {
            t2(e2, n3, r2(n3), i2);
          }), e2;
        }
        function Cr2(n2, t2) {
          return n2 && $u(t2, Pc(t2), n2);
        }
        function Ur2(n2, t2) {
          return n2 && $u(t2, qc(t2), n2);
        }
        function Br2(n2, t2, r2) {
          "__proto__" == t2 && Tl ? Tl(n2, t2, { configurable: true, enumerable: true, value: r2, writable: true }) : n2[t2] = r2;
        }
        function Tr2(n2, t2) {
          for (var r2 = -1, e2 = t2.length, u2 = il(e2), i2 = null == n2; ++r2 < e2; ) u2[r2] = i2 ? X : Mc(n2, t2[r2]);
          return u2;
        }
        function Mr2(n2, t2, r2) {
          return n2 === n2 && (r2 !== X && (n2 = n2 <= r2 ? n2 : r2), t2 !== X && (n2 = n2 >= t2 ? n2 : t2)), n2;
        }
        function Fr2(n2, t2, e2, u2, i2, o2) {
          var f2, c2 = t2 & an, a2 = t2 & ln, l2 = t2 & sn;
          if (e2 && (f2 = i2 ? e2(n2, u2, i2, o2) : e2(n2)), f2 !== X) return f2;
          if (!fc(n2)) return n2;
          var s2 = bh(n2);
          if (s2) {
            if (f2 = zi(n2), !c2) return Tu(n2, f2);
          } else {
            var h2 = zs(n2), p3 = h2 == Kn || h2 == Vn;
            if (mh(n2)) return Iu(n2, c2);
            if (h2 == Yn || h2 == Dn || p3 && !i2) {
              if (f2 = a2 || p3 ? {} : Ei(n2), !c2) return a2 ? Mu(n2, Ur2(f2, n2)) : Du(n2, Cr2(f2, n2));
            } else {
              if (!Vr[h2]) return i2 ? n2 : {};
              f2 = Si(n2, h2, c2);
            }
          }
          o2 || (o2 = new wr2());
          var _2 = o2.get(n2);
          if (_2) return _2;
          o2.set(n2, f2), kh(n2) ? n2.forEach(function(r2) {
            f2.add(Fr2(r2, t2, e2, r2, n2, o2));
          }) : jh(n2) && n2.forEach(function(r2, u3) {
            f2.set(u3, Fr2(r2, t2, e2, u3, n2, o2));
          });
          var v2 = l2 ? a2 ? di : yi : a2 ? qc : Pc, g2 = s2 ? X : v2(n2);
          return r(g2 || n2, function(r2, u3) {
            g2 && (u3 = r2, r2 = n2[u3]), Sr2(f2, u3, Fr2(r2, t2, e2, u3, n2, o2));
          }), f2;
        }
        function Nr2(n2) {
          var t2 = Pc(n2);
          return function(r2) {
            return Pr2(r2, n2, t2);
          };
        }
        function Pr2(n2, t2, r2) {
          var e2 = r2.length;
          if (null == n2) return !e2;
          for (n2 = ll(n2); e2--; ) {
            var u2 = r2[e2], i2 = t2[u2], o2 = n2[u2];
            if (o2 === X && !(u2 in n2) || !i2(o2)) return false;
          }
          return true;
        }
        function Gr2(n2, t2, r2) {
          if ("function" != typeof n2) throw new pl(en);
          return Ws(function() {
            n2.apply(X, r2);
          }, t2);
        }
        function Hr2(n2, t2, r2, e2) {
          var u2 = -1, i2 = o, a2 = true, l2 = n2.length, s2 = [], h2 = t2.length;
          if (!l2) return s2;
          r2 && (t2 = c(t2, z(r2))), e2 ? (i2 = f, a2 = false) : t2.length >= tn && (i2 = S, a2 = false, t2 = new yr2(t2));
          n: for (; ++u2 < l2; ) {
            var p3 = n2[u2], _2 = null == r2 ? p3 : r2(p3);
            if (p3 = e2 || 0 !== p3 ? p3 : 0, a2 && _2 === _2) {
              for (var v2 = h2; v2--; ) if (t2[v2] === _2) continue n;
              s2.push(p3);
            } else i2(t2, _2, e2) || s2.push(p3);
          }
          return s2;
        }
        function Jr2(n2, t2) {
          var r2 = true;
          return ys(n2, function(n3, e2, u2) {
            return r2 = !!t2(n3, e2, u2);
          }), r2;
        }
        function Yr2(n2, t2, r2) {
          for (var e2 = -1, u2 = n2.length; ++e2 < u2; ) {
            var i2 = n2[e2], o2 = t2(i2);
            if (null != o2 && (f2 === X ? o2 === o2 && !bc(o2) : r2(o2, f2))) var f2 = o2, c2 = i2;
          }
          return c2;
        }
        function ne2(n2, t2, r2, e2) {
          var u2 = n2.length;
          for (r2 = kc(r2), r2 < 0 && (r2 = -r2 > u2 ? 0 : u2 + r2), e2 = e2 === X || e2 > u2 ? u2 : kc(e2), e2 < 0 && (e2 += u2), e2 = r2 > e2 ? 0 : Oc(e2); r2 < e2; ) n2[r2++] = t2;
          return n2;
        }
        function te2(n2, t2) {
          var r2 = [];
          return ys(n2, function(n3, e2, u2) {
            t2(n3, e2, u2) && r2.push(n3);
          }), r2;
        }
        function ee2(n2, t2, r2, e2, u2) {
          var i2 = -1, o2 = n2.length;
          for (r2 || (r2 = Li), u2 || (u2 = []); ++i2 < o2; ) {
            var f2 = n2[i2];
            t2 > 0 && r2(f2) ? t2 > 1 ? ee2(f2, t2 - 1, r2, e2, u2) : a(u2, f2) : e2 || (u2[u2.length] = f2);
          }
          return u2;
        }
        function ue2(n2, t2) {
          return n2 && bs(n2, t2, Pc);
        }
        function oe2(n2, t2) {
          return n2 && ws(n2, t2, Pc);
        }
        function fe2(n2, t2) {
          return i(t2, function(t3) {
            return uc(n2[t3]);
          });
        }
        function _e2(n2, t2) {
          t2 = ku(t2, n2);
          for (var r2 = 0, e2 = t2.length; null != n2 && r2 < e2; ) n2 = n2[no(t2[r2++])];
          return r2 && r2 == e2 ? n2 : X;
        }
        function de2(n2, t2, r2) {
          var e2 = t2(n2);
          return bh(n2) ? e2 : a(e2, r2(n2));
        }
        function we(n2) {
          return null == n2 ? n2 === X ? ut : Jn : Bl && Bl in ll(n2) ? ki(n2) : Ki(n2);
        }
        function me(n2, t2) {
          return n2 > t2;
        }
        function xe(n2, t2) {
          return null != n2 && bl.call(n2, t2);
        }
        function je(n2, t2) {
          return null != n2 && t2 in ll(n2);
        }
        function Ae(n2, t2, r2) {
          return n2 >= Hl(t2, r2) && n2 < Gl(t2, r2);
        }
        function ke(n2, t2, r2) {
          for (var e2 = r2 ? f : o, u2 = n2[0].length, i2 = n2.length, a2 = i2, l2 = il(i2), s2 = 1 / 0, h2 = []; a2--; ) {
            var p3 = n2[a2];
            a2 && t2 && (p3 = c(p3, z(t2))), s2 = Hl(p3.length, s2), l2[a2] = !r2 && (t2 || u2 >= 120 && p3.length >= 120) ? new yr2(a2 && p3) : X;
          }
          p3 = n2[0];
          var _2 = -1, v2 = l2[0];
          n: for (; ++_2 < u2 && h2.length < s2; ) {
            var g2 = p3[_2], y2 = t2 ? t2(g2) : g2;
            if (g2 = r2 || 0 !== g2 ? g2 : 0, !(v2 ? S(v2, y2) : e2(h2, y2, r2))) {
              for (a2 = i2; --a2; ) {
                var d2 = l2[a2];
                if (!(d2 ? S(d2, y2) : e2(n2[a2], y2, r2))) continue n;
              }
              v2 && v2.push(y2), h2.push(g2);
            }
          }
          return h2;
        }
        function Oe(n2, t2, r2, e2) {
          return ue2(n2, function(n3, u2, i2) {
            t2(e2, r2(n3), u2, i2);
          }), e2;
        }
        function Ie(t2, r2, e2) {
          r2 = ku(r2, t2), t2 = Gi(t2, r2);
          var u2 = null == t2 ? t2 : t2[no(jo(r2))];
          return null == u2 ? X : n(u2, t2, e2);
        }
        function Re(n2) {
          return cc(n2) && we(n2) == Dn;
        }
        function ze(n2) {
          return cc(n2) && we(n2) == ft;
        }
        function Ee(n2) {
          return cc(n2) && we(n2) == Pn;
        }
        function Se(n2, t2, r2, e2, u2) {
          return n2 === t2 || (null == n2 || null == t2 || !cc(n2) && !cc(t2) ? n2 !== n2 && t2 !== t2 : We(n2, t2, r2, e2, Se, u2));
        }
        function We(n2, t2, r2, e2, u2, i2) {
          var o2 = bh(n2), f2 = bh(t2), c2 = o2 ? Mn : zs(n2), a2 = f2 ? Mn : zs(t2);
          c2 = c2 == Dn ? Yn : c2, a2 = a2 == Dn ? Yn : a2;
          var l2 = c2 == Yn, s2 = a2 == Yn, h2 = c2 == a2;
          if (h2 && mh(n2)) {
            if (!mh(t2)) return false;
            o2 = true, l2 = false;
          }
          if (h2 && !l2) return i2 || (i2 = new wr2()), o2 || Oh(n2) ? pi(n2, t2, r2, e2, u2, i2) : _i(n2, t2, c2, r2, e2, u2, i2);
          if (!(r2 & hn)) {
            var p3 = l2 && bl.call(n2, "__wrapped__"), _2 = s2 && bl.call(t2, "__wrapped__");
            if (p3 || _2) {
              var v2 = p3 ? n2.value() : n2, g2 = _2 ? t2.value() : t2;
              return i2 || (i2 = new wr2()), u2(v2, g2, r2, e2, i2);
            }
          }
          return !!h2 && (i2 || (i2 = new wr2()), vi(n2, t2, r2, e2, u2, i2));
        }
        function Le(n2) {
          return cc(n2) && zs(n2) == Gn;
        }
        function Ce(n2, t2, r2, e2) {
          var u2 = r2.length, i2 = u2, o2 = !e2;
          if (null == n2) return !i2;
          for (n2 = ll(n2); u2--; ) {
            var f2 = r2[u2];
            if (o2 && f2[2] ? f2[1] !== n2[f2[0]] : !(f2[0] in n2)) return false;
          }
          for (; ++u2 < i2; ) {
            f2 = r2[u2];
            var c2 = f2[0], a2 = n2[c2], l2 = f2[1];
            if (o2 && f2[2]) {
              if (a2 === X && !(c2 in n2)) return false;
            } else {
              var s2 = new wr2();
              if (e2) var h2 = e2(a2, l2, c2, n2, t2, s2);
              if (!(h2 === X ? Se(l2, a2, hn | pn, e2, s2) : h2)) return false;
            }
          }
          return true;
        }
        function Ue(n2) {
          return !(!fc(n2) || Di(n2)) && (uc(n2) ? kl : Zt).test(to(n2));
        }
        function Be(n2) {
          return cc(n2) && we(n2) == nt;
        }
        function Te(n2) {
          return cc(n2) && zs(n2) == tt;
        }
        function $e(n2) {
          return cc(n2) && oc(n2.length) && !!Kr[we(n2)];
        }
        function De(n2) {
          return "function" == typeof n2 ? n2 : null == n2 ? La : "object" == typeof n2 ? bh(n2) ? Ze(n2[0], n2[1]) : qe(n2) : Fa(n2);
        }
        function Me(n2) {
          if (!Mi(n2)) return Vl(n2);
          var t2 = [];
          for (var r2 in ll(n2)) bl.call(n2, r2) && "constructor" != r2 && t2.push(r2);
          return t2;
        }
        function Fe(n2) {
          if (!fc(n2)) return Zi(n2);
          var t2 = Mi(n2), r2 = [];
          for (var e2 in n2) ("constructor" != e2 || !t2 && bl.call(n2, e2)) && r2.push(e2);
          return r2;
        }
        function Ne(n2, t2) {
          return n2 < t2;
        }
        function Pe(n2, t2) {
          var r2 = -1, e2 = Hf(n2) ? il(n2.length) : [];
          return ys(n2, function(n3, u2, i2) {
            e2[++r2] = t2(n3, u2, i2);
          }), e2;
        }
        function qe(n2) {
          var t2 = ji(n2);
          return 1 == t2.length && t2[0][2] ? Ni(t2[0][0], t2[0][1]) : function(r2) {
            return r2 === n2 || Ce(r2, n2, t2);
          };
        }
        function Ze(n2, t2) {
          return Bi(n2) && Fi(t2) ? Ni(no(n2), t2) : function(r2) {
            var e2 = Mc(r2, n2);
            return e2 === X && e2 === t2 ? Nc(r2, n2) : Se(t2, e2, hn | pn);
          };
        }
        function Ke(n2, t2, r2, e2, u2) {
          n2 !== t2 && bs(t2, function(i2, o2) {
            if (u2 || (u2 = new wr2()), fc(i2)) Ve(n2, t2, o2, r2, Ke, e2, u2);
            else {
              var f2 = e2 ? e2(Ji(n2, o2), i2, o2 + "", n2, t2, u2) : X;
              f2 === X && (f2 = i2), Er2(n2, o2, f2);
            }
          }, qc);
        }
        function Ve(n2, t2, r2, e2, u2, i2, o2) {
          var f2 = Ji(n2, r2), c2 = Ji(t2, r2), a2 = o2.get(c2);
          if (a2) return Er2(n2, r2, a2), X;
          var l2 = i2 ? i2(f2, c2, r2 + "", n2, t2, o2) : X, s2 = l2 === X;
          if (s2) {
            var h2 = bh(c2), p3 = !h2 && mh(c2), _2 = !h2 && !p3 && Oh(c2);
            l2 = c2, h2 || p3 || _2 ? bh(f2) ? l2 = f2 : Jf(f2) ? l2 = Tu(f2) : p3 ? (s2 = false, l2 = Iu(c2, true)) : _2 ? (s2 = false, l2 = Wu(c2, true)) : l2 = [] : gc(c2) || dh(c2) ? (l2 = f2, dh(f2) ? l2 = Rc(f2) : fc(f2) && !uc(f2) || (l2 = Ei(c2))) : s2 = false;
          }
          s2 && (o2.set(c2, l2), u2(l2, c2, e2, i2, o2), o2.delete(c2)), Er2(n2, r2, l2);
        }
        function Ge(n2, t2) {
          var r2 = n2.length;
          if (r2) return t2 += t2 < 0 ? r2 : 0, Ci(t2, r2) ? n2[t2] : X;
        }
        function He(n2, t2, r2) {
          t2 = t2.length ? c(t2, function(n3) {
            return bh(n3) ? function(t3) {
              return _e2(t3, 1 === n3.length ? n3[0] : n3);
            } : n3;
          }) : [La];
          var e2 = -1;
          return t2 = c(t2, z(mi())), A(Pe(n2, function(n3, r3, u2) {
            return { criteria: c(t2, function(t3) {
              return t3(n3);
            }), index: ++e2, value: n3 };
          }), function(n3, t3) {
            return Cu(n3, t3, r2);
          });
        }
        function Je(n2, t2) {
          return Ye(n2, t2, function(t3, r2) {
            return Nc(n2, r2);
          });
        }
        function Ye(n2, t2, r2) {
          for (var e2 = -1, u2 = t2.length, i2 = {}; ++e2 < u2; ) {
            var o2 = t2[e2], f2 = _e2(n2, o2);
            r2(f2, o2) && fu(i2, ku(o2, n2), f2);
          }
          return i2;
        }
        function Qe(n2) {
          return function(t2) {
            return _e2(t2, n2);
          };
        }
        function Xe(n2, t2, r2, e2) {
          var u2 = e2 ? d : y, i2 = -1, o2 = t2.length, f2 = n2;
          for (n2 === t2 && (t2 = Tu(t2)), r2 && (f2 = c(n2, z(r2))); ++i2 < o2; ) for (var a2 = 0, l2 = t2[i2], s2 = r2 ? r2(l2) : l2; (a2 = u2(f2, s2, a2, e2)) > -1; ) f2 !== n2 && Ll.call(f2, a2, 1), Ll.call(n2, a2, 1);
          return n2;
        }
        function nu(n2, t2) {
          for (var r2 = n2 ? t2.length : 0, e2 = r2 - 1; r2--; ) {
            var u2 = t2[r2];
            if (r2 == e2 || u2 !== i2) {
              var i2 = u2;
              Ci(u2) ? Ll.call(n2, u2, 1) : yu(n2, u2);
            }
          }
          return n2;
        }
        function tu(n2, t2) {
          return n2 + Nl(Ql() * (t2 - n2 + 1));
        }
        function ru(n2, t2, r2, e2) {
          for (var u2 = -1, i2 = Gl(Fl((t2 - n2) / (r2 || 1)), 0), o2 = il(i2); i2--; ) o2[e2 ? i2 : ++u2] = n2, n2 += r2;
          return o2;
        }
        function eu(n2, t2) {
          var r2 = "";
          if (!n2 || t2 < 1 || t2 > Wn) return r2;
          do
            t2 % 2 && (r2 += n2), t2 = Nl(t2 / 2), t2 && (n2 += n2);
          while (t2);
          return r2;
        }
        function uu(n2, t2) {
          return Ls(Vi(n2, t2, La), n2 + "");
        }
        function iu(n2) {
          return Ir2(ra(n2));
        }
        function ou(n2, t2) {
          var r2 = ra(n2);
          return Xi(r2, Mr2(t2, 0, r2.length));
        }
        function fu(n2, t2, r2, e2) {
          if (!fc(n2)) return n2;
          t2 = ku(t2, n2);
          for (var u2 = -1, i2 = t2.length, o2 = i2 - 1, f2 = n2; null != f2 && ++u2 < i2; ) {
            var c2 = no(t2[u2]), a2 = r2;
            if ("__proto__" === c2 || "constructor" === c2 || "prototype" === c2) return n2;
            if (u2 != o2) {
              var l2 = f2[c2];
              a2 = e2 ? e2(l2, c2, f2) : X, a2 === X && (a2 = fc(l2) ? l2 : Ci(t2[u2 + 1]) ? [] : {});
            }
            Sr2(f2, c2, a2), f2 = f2[c2];
          }
          return n2;
        }
        function cu(n2) {
          return Xi(ra(n2));
        }
        function au(n2, t2, r2) {
          var e2 = -1, u2 = n2.length;
          t2 < 0 && (t2 = -t2 > u2 ? 0 : u2 + t2), r2 = r2 > u2 ? u2 : r2, r2 < 0 && (r2 += u2), u2 = t2 > r2 ? 0 : r2 - t2 >>> 0, t2 >>>= 0;
          for (var i2 = il(u2); ++e2 < u2; ) i2[e2] = n2[e2 + t2];
          return i2;
        }
        function lu(n2, t2) {
          var r2;
          return ys(n2, function(n3, e2, u2) {
            return r2 = t2(n3, e2, u2), !r2;
          }), !!r2;
        }
        function su(n2, t2, r2) {
          var e2 = 0, u2 = null == n2 ? e2 : n2.length;
          if ("number" == typeof t2 && t2 === t2 && u2 <= Tn) {
            for (; e2 < u2; ) {
              var i2 = e2 + u2 >>> 1, o2 = n2[i2];
              null !== o2 && !bc(o2) && (r2 ? o2 <= t2 : o2 < t2) ? e2 = i2 + 1 : u2 = i2;
            }
            return u2;
          }
          return hu(n2, t2, La, r2);
        }
        function hu(n2, t2, r2, e2) {
          var u2 = 0, i2 = null == n2 ? 0 : n2.length;
          if (0 === i2) return 0;
          t2 = r2(t2);
          for (var o2 = t2 !== t2, f2 = null === t2, c2 = bc(t2), a2 = t2 === X; u2 < i2; ) {
            var l2 = Nl((u2 + i2) / 2), s2 = r2(n2[l2]), h2 = s2 !== X, p3 = null === s2, _2 = s2 === s2, v2 = bc(s2);
            if (o2) var g2 = e2 || _2;
            else g2 = a2 ? _2 && (e2 || h2) : f2 ? _2 && h2 && (e2 || !p3) : c2 ? _2 && h2 && !p3 && (e2 || !v2) : !p3 && !v2 && (e2 ? s2 <= t2 : s2 < t2);
            g2 ? u2 = l2 + 1 : i2 = l2;
          }
          return Hl(i2, Bn);
        }
        function pu(n2, t2) {
          for (var r2 = -1, e2 = n2.length, u2 = 0, i2 = []; ++r2 < e2; ) {
            var o2 = n2[r2], f2 = t2 ? t2(o2) : o2;
            if (!r2 || !Gf(f2, c2)) {
              var c2 = f2;
              i2[u2++] = 0 === o2 ? 0 : o2;
            }
          }
          return i2;
        }
        function _u(n2) {
          return "number" == typeof n2 ? n2 : bc(n2) ? Cn : +n2;
        }
        function vu(n2) {
          if ("string" == typeof n2) return n2;
          if (bh(n2)) return c(n2, vu) + "";
          if (bc(n2)) return vs ? vs.call(n2) : "";
          var t2 = n2 + "";
          return "0" == t2 && 1 / n2 == -Sn ? "-0" : t2;
        }
        function gu(n2, t2, r2) {
          var e2 = -1, u2 = o, i2 = n2.length, c2 = true, a2 = [], l2 = a2;
          if (r2) c2 = false, u2 = f;
          else if (i2 >= tn) {
            var s2 = t2 ? null : ks(n2);
            if (s2) return P(s2);
            c2 = false, u2 = S, l2 = new yr2();
          } else l2 = t2 ? [] : a2;
          n: for (; ++e2 < i2; ) {
            var h2 = n2[e2], p3 = t2 ? t2(h2) : h2;
            if (h2 = r2 || 0 !== h2 ? h2 : 0, c2 && p3 === p3) {
              for (var _2 = l2.length; _2--; ) if (l2[_2] === p3) continue n;
              t2 && l2.push(p3), a2.push(h2);
            } else u2(l2, p3, r2) || (l2 !== a2 && l2.push(p3), a2.push(h2));
          }
          return a2;
        }
        function yu(n2, t2) {
          return t2 = ku(t2, n2), n2 = Gi(n2, t2), null == n2 || delete n2[no(jo(t2))];
        }
        function du(n2, t2, r2, e2) {
          return fu(n2, t2, r2(_e2(n2, t2)), e2);
        }
        function bu(n2, t2, r2, e2) {
          for (var u2 = n2.length, i2 = e2 ? u2 : -1; (e2 ? i2-- : ++i2 < u2) && t2(n2[i2], i2, n2); ) ;
          return r2 ? au(n2, e2 ? 0 : i2, e2 ? i2 + 1 : u2) : au(n2, e2 ? i2 + 1 : 0, e2 ? u2 : i2);
        }
        function wu(n2, t2) {
          var r2 = n2;
          return r2 instanceof Ct2 && (r2 = r2.value()), l(t2, function(n3, t3) {
            return t3.func.apply(t3.thisArg, a([n3], t3.args));
          }, r2);
        }
        function mu(n2, t2, r2) {
          var e2 = n2.length;
          if (e2 < 2) return e2 ? gu(n2[0]) : [];
          for (var u2 = -1, i2 = il(e2); ++u2 < e2; ) for (var o2 = n2[u2], f2 = -1; ++f2 < e2; ) f2 != u2 && (i2[u2] = Hr2(i2[u2] || o2, n2[f2], t2, r2));
          return gu(ee2(i2, 1), t2, r2);
        }
        function xu(n2, t2, r2) {
          for (var e2 = -1, u2 = n2.length, i2 = t2.length, o2 = {}; ++e2 < u2; ) {
            r2(o2, n2[e2], e2 < i2 ? t2[e2] : X);
          }
          return o2;
        }
        function ju(n2) {
          return Jf(n2) ? n2 : [];
        }
        function Au(n2) {
          return "function" == typeof n2 ? n2 : La;
        }
        function ku(n2, t2) {
          return bh(n2) ? n2 : Bi(n2, t2) ? [n2] : Cs(Ec(n2));
        }
        function Ou(n2, t2, r2) {
          var e2 = n2.length;
          return r2 = r2 === X ? e2 : r2, !t2 && r2 >= e2 ? n2 : au(n2, t2, r2);
        }
        function Iu(n2, t2) {
          if (t2) return n2.slice();
          var r2 = n2.length, e2 = zl ? zl(r2) : new n2.constructor(r2);
          return n2.copy(e2), e2;
        }
        function Ru(n2) {
          var t2 = new n2.constructor(n2.byteLength);
          return new Rl(t2).set(new Rl(n2)), t2;
        }
        function zu(n2, t2) {
          return new n2.constructor(t2 ? Ru(n2.buffer) : n2.buffer, n2.byteOffset, n2.byteLength);
        }
        function Eu(n2) {
          var t2 = new n2.constructor(n2.source, Nt.exec(n2));
          return t2.lastIndex = n2.lastIndex, t2;
        }
        function Su(n2) {
          return _s ? ll(_s.call(n2)) : {};
        }
        function Wu(n2, t2) {
          return new n2.constructor(t2 ? Ru(n2.buffer) : n2.buffer, n2.byteOffset, n2.length);
        }
        function Lu(n2, t2) {
          if (n2 !== t2) {
            var r2 = n2 !== X, e2 = null === n2, u2 = n2 === n2, i2 = bc(n2), o2 = t2 !== X, f2 = null === t2, c2 = t2 === t2, a2 = bc(t2);
            if (!f2 && !a2 && !i2 && n2 > t2 || i2 && o2 && c2 && !f2 && !a2 || e2 && o2 && c2 || !r2 && c2 || !u2) return 1;
            if (!e2 && !i2 && !a2 && n2 < t2 || a2 && r2 && u2 && !e2 && !i2 || f2 && r2 && u2 || !o2 && u2 || !c2) return -1;
          }
          return 0;
        }
        function Cu(n2, t2, r2) {
          for (var e2 = -1, u2 = n2.criteria, i2 = t2.criteria, o2 = u2.length, f2 = r2.length; ++e2 < o2; ) {
            var c2 = Lu(u2[e2], i2[e2]);
            if (c2) {
              if (e2 >= f2) return c2;
              return c2 * ("desc" == r2[e2] ? -1 : 1);
            }
          }
          return n2.index - t2.index;
        }
        function Uu(n2, t2, r2, e2) {
          for (var u2 = -1, i2 = n2.length, o2 = r2.length, f2 = -1, c2 = t2.length, a2 = Gl(i2 - o2, 0), l2 = il(c2 + a2), s2 = !e2; ++f2 < c2; ) l2[f2] = t2[f2];
          for (; ++u2 < o2; ) (s2 || u2 < i2) && (l2[r2[u2]] = n2[u2]);
          for (; a2--; ) l2[f2++] = n2[u2++];
          return l2;
        }
        function Bu(n2, t2, r2, e2) {
          for (var u2 = -1, i2 = n2.length, o2 = -1, f2 = r2.length, c2 = -1, a2 = t2.length, l2 = Gl(i2 - f2, 0), s2 = il(l2 + a2), h2 = !e2; ++u2 < l2; ) s2[u2] = n2[u2];
          for (var p3 = u2; ++c2 < a2; ) s2[p3 + c2] = t2[c2];
          for (; ++o2 < f2; ) (h2 || u2 < i2) && (s2[p3 + r2[o2]] = n2[u2++]);
          return s2;
        }
        function Tu(n2, t2) {
          var r2 = -1, e2 = n2.length;
          for (t2 || (t2 = il(e2)); ++r2 < e2; ) t2[r2] = n2[r2];
          return t2;
        }
        function $u(n2, t2, r2, e2) {
          var u2 = !r2;
          r2 || (r2 = {});
          for (var i2 = -1, o2 = t2.length; ++i2 < o2; ) {
            var f2 = t2[i2], c2 = e2 ? e2(r2[f2], n2[f2], f2, r2, n2) : X;
            c2 === X && (c2 = n2[f2]), u2 ? Br2(r2, f2, c2) : Sr2(r2, f2, c2);
          }
          return r2;
        }
        function Du(n2, t2) {
          return $u(n2, Is(n2), t2);
        }
        function Mu(n2, t2) {
          return $u(n2, Rs(n2), t2);
        }
        function Fu(n2, r2) {
          return function(e2, u2) {
            var i2 = bh(e2) ? t : Lr2, o2 = r2 ? r2() : {};
            return i2(e2, n2, mi(u2, 2), o2);
          };
        }
        function Nu(n2) {
          return uu(function(t2, r2) {
            var e2 = -1, u2 = r2.length, i2 = u2 > 1 ? r2[u2 - 1] : X, o2 = u2 > 2 ? r2[2] : X;
            for (i2 = n2.length > 3 && "function" == typeof i2 ? (u2--, i2) : X, o2 && Ui(r2[0], r2[1], o2) && (i2 = u2 < 3 ? X : i2, u2 = 1), t2 = ll(t2); ++e2 < u2; ) {
              var f2 = r2[e2];
              f2 && n2(t2, f2, e2, i2);
            }
            return t2;
          });
        }
        function Pu(n2, t2) {
          return function(r2, e2) {
            if (null == r2) return r2;
            if (!Hf(r2)) return n2(r2, e2);
            for (var u2 = r2.length, i2 = t2 ? u2 : -1, o2 = ll(r2); (t2 ? i2-- : ++i2 < u2) && e2(o2[i2], i2, o2) !== false; ) ;
            return r2;
          };
        }
        function qu(n2) {
          return function(t2, r2, e2) {
            for (var u2 = -1, i2 = ll(t2), o2 = e2(t2), f2 = o2.length; f2--; ) {
              var c2 = o2[n2 ? f2 : ++u2];
              if (r2(i2[c2], c2, i2) === false) break;
            }
            return t2;
          };
        }
        function Zu(n2, t2, r2) {
          function e2() {
            return (this && this !== re && this instanceof e2 ? i2 : n2).apply(u2 ? r2 : this, arguments);
          }
          var u2 = t2 & _n, i2 = Gu(n2);
          return e2;
        }
        function Ku(n2) {
          return function(t2) {
            t2 = Ec(t2);
            var r2 = T(t2) ? G(t2) : X, e2 = r2 ? r2[0] : t2.charAt(0), u2 = r2 ? Ou(r2, 1).join("") : t2.slice(1);
            return e2[n2]() + u2;
          };
        }
        function Vu(n2) {
          return function(t2) {
            return l(Ra(ca(t2).replace($r, "")), n2, "");
          };
        }
        function Gu(n2) {
          return function() {
            var t2 = arguments;
            switch (t2.length) {
              case 0:
                return new n2();
              case 1:
                return new n2(t2[0]);
              case 2:
                return new n2(t2[0], t2[1]);
              case 3:
                return new n2(t2[0], t2[1], t2[2]);
              case 4:
                return new n2(t2[0], t2[1], t2[2], t2[3]);
              case 5:
                return new n2(t2[0], t2[1], t2[2], t2[3], t2[4]);
              case 6:
                return new n2(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]);
              case 7:
                return new n2(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]);
            }
            var r2 = gs(n2.prototype), e2 = n2.apply(r2, t2);
            return fc(e2) ? e2 : r2;
          };
        }
        function Hu(t2, r2, e2) {
          function u2() {
            for (var o2 = arguments.length, f2 = il(o2), c2 = o2, a2 = wi(u2); c2--; ) f2[c2] = arguments[c2];
            var l2 = o2 < 3 && f2[0] !== a2 && f2[o2 - 1] !== a2 ? [] : N(f2, a2);
            return o2 -= l2.length, o2 < e2 ? oi(t2, r2, Qu, u2.placeholder, X, f2, l2, X, X, e2 - o2) : n(this && this !== re && this instanceof u2 ? i2 : t2, this, f2);
          }
          var i2 = Gu(t2);
          return u2;
        }
        function Ju(n2) {
          return function(t2, r2, e2) {
            var u2 = ll(t2);
            if (!Hf(t2)) {
              var i2 = mi(r2, 3);
              t2 = Pc(t2), r2 = function(n3) {
                return i2(u2[n3], n3, u2);
              };
            }
            var o2 = n2(t2, r2, e2);
            return o2 > -1 ? u2[i2 ? t2[o2] : o2] : X;
          };
        }
        function Yu(n2) {
          return gi(function(t2) {
            var r2 = t2.length, e2 = r2, u2 = Y2.prototype.thru;
            for (n2 && t2.reverse(); e2--; ) {
              var i2 = t2[e2];
              if ("function" != typeof i2) throw new pl(en);
              if (u2 && !o2 && "wrapper" == bi(i2)) var o2 = new Y2([], true);
            }
            for (e2 = o2 ? e2 : r2; ++e2 < r2; ) {
              i2 = t2[e2];
              var f2 = bi(i2), c2 = "wrapper" == f2 ? Os(i2) : X;
              o2 = c2 && $i(c2[0]) && c2[1] == (mn | yn | bn | xn) && !c2[4].length && 1 == c2[9] ? o2[bi(c2[0])].apply(o2, c2[3]) : 1 == i2.length && $i(i2) ? o2[f2]() : o2.thru(i2);
            }
            return function() {
              var n3 = arguments, e3 = n3[0];
              if (o2 && 1 == n3.length && bh(e3)) return o2.plant(e3).value();
              for (var u3 = 0, i3 = r2 ? t2[u3].apply(this, n3) : e3; ++u3 < r2; ) i3 = t2[u3].call(this, i3);
              return i3;
            };
          });
        }
        function Qu(n2, t2, r2, e2, u2, i2, o2, f2, c2, a2) {
          function l2() {
            for (var y2 = arguments.length, d2 = il(y2), b2 = y2; b2--; ) d2[b2] = arguments[b2];
            if (_2) var w2 = wi(l2), m2 = C(d2, w2);
            if (e2 && (d2 = Uu(d2, e2, u2, _2)), i2 && (d2 = Bu(d2, i2, o2, _2)), y2 -= m2, _2 && y2 < a2) {
              return oi(n2, t2, Qu, l2.placeholder, r2, d2, N(d2, w2), f2, c2, a2 - y2);
            }
            var x3 = h2 ? r2 : this, j2 = p3 ? x3[n2] : n2;
            return y2 = d2.length, f2 ? d2 = Hi(d2, f2) : v2 && y2 > 1 && d2.reverse(), s2 && c2 < y2 && (d2.length = c2), this && this !== re && this instanceof l2 && (j2 = g2 || Gu(j2)), j2.apply(x3, d2);
          }
          var s2 = t2 & mn, h2 = t2 & _n, p3 = t2 & vn, _2 = t2 & (yn | dn), v2 = t2 & jn, g2 = p3 ? X : Gu(n2);
          return l2;
        }
        function Xu(n2, t2) {
          return function(r2, e2) {
            return Oe(r2, n2, t2(e2), {});
          };
        }
        function ni(n2, t2) {
          return function(r2, e2) {
            var u2;
            if (r2 === X && e2 === X) return t2;
            if (r2 !== X && (u2 = r2), e2 !== X) {
              if (u2 === X) return e2;
              "string" == typeof r2 || "string" == typeof e2 ? (r2 = vu(r2), e2 = vu(e2)) : (r2 = _u(r2), e2 = _u(e2)), u2 = n2(r2, e2);
            }
            return u2;
          };
        }
        function ti(t2) {
          return gi(function(r2) {
            return r2 = c(r2, z(mi())), uu(function(e2) {
              var u2 = this;
              return t2(r2, function(t3) {
                return n(t3, u2, e2);
              });
            });
          });
        }
        function ri(n2, t2) {
          t2 = t2 === X ? " " : vu(t2);
          var r2 = t2.length;
          if (r2 < 2) return r2 ? eu(t2, n2) : t2;
          var e2 = eu(t2, Fl(n2 / V(t2)));
          return T(t2) ? Ou(G(e2), 0, n2).join("") : e2.slice(0, n2);
        }
        function ei(t2, r2, e2, u2) {
          function i2() {
            for (var r3 = -1, c2 = arguments.length, a2 = -1, l2 = u2.length, s2 = il(l2 + c2), h2 = this && this !== re && this instanceof i2 ? f2 : t2; ++a2 < l2; ) s2[a2] = u2[a2];
            for (; c2--; ) s2[a2++] = arguments[++r3];
            return n(h2, o2 ? e2 : this, s2);
          }
          var o2 = r2 & _n, f2 = Gu(t2);
          return i2;
        }
        function ui(n2) {
          return function(t2, r2, e2) {
            return e2 && "number" != typeof e2 && Ui(t2, r2, e2) && (r2 = e2 = X), t2 = Ac(t2), r2 === X ? (r2 = t2, t2 = 0) : r2 = Ac(r2), e2 = e2 === X ? t2 < r2 ? 1 : -1 : Ac(e2), ru(t2, r2, e2, n2);
          };
        }
        function ii(n2) {
          return function(t2, r2) {
            return "string" == typeof t2 && "string" == typeof r2 || (t2 = Ic(t2), r2 = Ic(r2)), n2(t2, r2);
          };
        }
        function oi(n2, t2, r2, e2, u2, i2, o2, f2, c2, a2) {
          var l2 = t2 & yn, s2 = l2 ? o2 : X, h2 = l2 ? X : o2, p3 = l2 ? i2 : X, _2 = l2 ? X : i2;
          t2 |= l2 ? bn : wn, t2 &= ~(l2 ? wn : bn), t2 & gn || (t2 &= -4);
          var v2 = [n2, t2, u2, p3, s2, _2, h2, f2, c2, a2], g2 = r2.apply(X, v2);
          return $i(n2) && Ss(g2, v2), g2.placeholder = e2, Yi(g2, n2, t2);
        }
        function fi(n2) {
          var t2 = al[n2];
          return function(n3, r2) {
            if (n3 = Ic(n3), r2 = null == r2 ? 0 : Hl(kc(r2), 292), r2 && Zl(n3)) {
              var e2 = (Ec(n3) + "e").split("e");
              return e2 = (Ec(t2(e2[0] + "e" + (+e2[1] + r2))) + "e").split("e"), +(e2[0] + "e" + (+e2[1] - r2));
            }
            return t2(n3);
          };
        }
        function ci(n2) {
          return function(t2) {
            var r2 = zs(t2);
            return r2 == Gn ? M(t2) : r2 == tt ? q(t2) : I(t2, n2(t2));
          };
        }
        function ai(n2, t2, r2, e2, u2, i2, o2, f2) {
          var c2 = t2 & vn;
          if (!c2 && "function" != typeof n2) throw new pl(en);
          var a2 = e2 ? e2.length : 0;
          if (a2 || (t2 &= -97, e2 = u2 = X), o2 = o2 === X ? o2 : Gl(kc(o2), 0), f2 = f2 === X ? f2 : kc(f2), a2 -= u2 ? u2.length : 0, t2 & wn) {
            var l2 = e2, s2 = u2;
            e2 = u2 = X;
          }
          var h2 = c2 ? X : Os(n2), p3 = [n2, t2, r2, e2, u2, l2, s2, i2, o2, f2];
          if (h2 && qi(p3, h2), n2 = p3[0], t2 = p3[1], r2 = p3[2], e2 = p3[3], u2 = p3[4], f2 = p3[9] = p3[9] === X ? c2 ? 0 : n2.length : Gl(p3[9] - a2, 0), !f2 && t2 & (yn | dn) && (t2 &= -25), t2 && t2 != _n) _2 = t2 == yn || t2 == dn ? Hu(n2, t2, f2) : t2 != bn && t2 != (_n | bn) || u2.length ? Qu.apply(X, p3) : ei(n2, t2, r2, e2);
          else var _2 = Zu(n2, t2, r2);
          return Yi((h2 ? ms2 : Ss)(_2, p3), n2, t2);
        }
        function li(n2, t2, r2, e2) {
          return n2 === X || Gf(n2, gl[r2]) && !bl.call(e2, r2) ? t2 : n2;
        }
        function si(n2, t2, r2, e2, u2, i2) {
          return fc(n2) && fc(t2) && (i2.set(t2, n2), Ke(n2, t2, X, si, i2), i2.delete(t2)), n2;
        }
        function hi(n2) {
          return gc(n2) ? X : n2;
        }
        function pi(n2, t2, r2, e2, u2, i2) {
          var o2 = r2 & hn, f2 = n2.length, c2 = t2.length;
          if (f2 != c2 && !(o2 && c2 > f2)) return false;
          var a2 = i2.get(n2), l2 = i2.get(t2);
          if (a2 && l2) return a2 == t2 && l2 == n2;
          var s2 = -1, p3 = true, _2 = r2 & pn ? new yr2() : X;
          for (i2.set(n2, t2), i2.set(t2, n2); ++s2 < f2; ) {
            var v2 = n2[s2], g2 = t2[s2];
            if (e2) var y2 = o2 ? e2(g2, v2, s2, t2, n2, i2) : e2(v2, g2, s2, n2, t2, i2);
            if (y2 !== X) {
              if (y2) continue;
              p3 = false;
              break;
            }
            if (_2) {
              if (!h(t2, function(n3, t3) {
                if (!S(_2, t3) && (v2 === n3 || u2(v2, n3, r2, e2, i2))) return _2.push(t3);
              })) {
                p3 = false;
                break;
              }
            } else if (v2 !== g2 && !u2(v2, g2, r2, e2, i2)) {
              p3 = false;
              break;
            }
          }
          return i2.delete(n2), i2.delete(t2), p3;
        }
        function _i(n2, t2, r2, e2, u2, i2, o2) {
          switch (r2) {
            case ct:
              if (n2.byteLength != t2.byteLength || n2.byteOffset != t2.byteOffset) return false;
              n2 = n2.buffer, t2 = t2.buffer;
            case ft:
              return !(n2.byteLength != t2.byteLength || !i2(new Rl(n2), new Rl(t2)));
            case Nn:
            case Pn:
            case Hn:
              return Gf(+n2, +t2);
            case Zn:
              return n2.name == t2.name && n2.message == t2.message;
            case nt:
            case rt:
              return n2 == t2 + "";
            case Gn:
              var f2 = M;
            case tt:
              var c2 = e2 & hn;
              if (f2 || (f2 = P), n2.size != t2.size && !c2) return false;
              var a2 = o2.get(n2);
              if (a2) return a2 == t2;
              e2 |= pn, o2.set(n2, t2);
              var l2 = pi(f2(n2), f2(t2), e2, u2, i2, o2);
              return o2.delete(n2), l2;
            case et:
              if (_s) return _s.call(n2) == _s.call(t2);
          }
          return false;
        }
        function vi(n2, t2, r2, e2, u2, i2) {
          var o2 = r2 & hn, f2 = yi(n2), c2 = f2.length;
          if (c2 != yi(t2).length && !o2) return false;
          for (var a2 = c2; a2--; ) {
            var l2 = f2[a2];
            if (!(o2 ? l2 in t2 : bl.call(t2, l2))) return false;
          }
          var s2 = i2.get(n2), h2 = i2.get(t2);
          if (s2 && h2) return s2 == t2 && h2 == n2;
          var p3 = true;
          i2.set(n2, t2), i2.set(t2, n2);
          for (var _2 = o2; ++a2 < c2; ) {
            l2 = f2[a2];
            var v2 = n2[l2], g2 = t2[l2];
            if (e2) var y2 = o2 ? e2(g2, v2, l2, t2, n2, i2) : e2(v2, g2, l2, n2, t2, i2);
            if (!(y2 === X ? v2 === g2 || u2(v2, g2, r2, e2, i2) : y2)) {
              p3 = false;
              break;
            }
            _2 || (_2 = "constructor" == l2);
          }
          if (p3 && !_2) {
            var d2 = n2.constructor, b2 = t2.constructor;
            d2 != b2 && "constructor" in n2 && "constructor" in t2 && !("function" == typeof d2 && d2 instanceof d2 && "function" == typeof b2 && b2 instanceof b2) && (p3 = false);
          }
          return i2.delete(n2), i2.delete(t2), p3;
        }
        function gi(n2) {
          return Ls(Vi(n2, X, _o), n2 + "");
        }
        function yi(n2) {
          return de2(n2, Pc, Is);
        }
        function di(n2) {
          return de2(n2, qc, Rs);
        }
        function bi(n2) {
          for (var t2 = n2.name + "", r2 = fs[t2], e2 = bl.call(fs, t2) ? r2.length : 0; e2--; ) {
            var u2 = r2[e2], i2 = u2.func;
            if (null == i2 || i2 == n2) return u2.name;
          }
          return t2;
        }
        function wi(n2) {
          return (bl.call(Z2, "placeholder") ? Z2 : n2).placeholder;
        }
        function mi() {
          var n2 = Z2.iteratee || Ca;
          return n2 = n2 === Ca ? De : n2, arguments.length ? n2(arguments[0], arguments[1]) : n2;
        }
        function xi(n2, t2) {
          var r2 = n2.__data__;
          return Ti(t2) ? r2["string" == typeof t2 ? "string" : "hash"] : r2.map;
        }
        function ji(n2) {
          for (var t2 = Pc(n2), r2 = t2.length; r2--; ) {
            var e2 = t2[r2], u2 = n2[e2];
            t2[r2] = [e2, u2, Fi(u2)];
          }
          return t2;
        }
        function Ai(n2, t2) {
          var r2 = B(n2, t2);
          return Ue(r2) ? r2 : X;
        }
        function ki(n2) {
          var t2 = bl.call(n2, Bl), r2 = n2[Bl];
          try {
            n2[Bl] = X;
            var e2 = true;
          } catch (n3) {
          }
          var u2 = xl.call(n2);
          return e2 && (t2 ? n2[Bl] = r2 : delete n2[Bl]), u2;
        }
        function Oi(n2, t2, r2) {
          for (var e2 = -1, u2 = r2.length; ++e2 < u2; ) {
            var i2 = r2[e2], o2 = i2.size;
            switch (i2.type) {
              case "drop":
                n2 += o2;
                break;
              case "dropRight":
                t2 -= o2;
                break;
              case "take":
                t2 = Hl(t2, n2 + o2);
                break;
              case "takeRight":
                n2 = Gl(n2, t2 - o2);
            }
          }
          return { start: n2, end: t2 };
        }
        function Ii(n2) {
          var t2 = n2.match(Bt);
          return t2 ? t2[1].split(Tt) : [];
        }
        function Ri(n2, t2, r2) {
          t2 = ku(t2, n2);
          for (var e2 = -1, u2 = t2.length, i2 = false; ++e2 < u2; ) {
            var o2 = no(t2[e2]);
            if (!(i2 = null != n2 && r2(n2, o2))) break;
            n2 = n2[o2];
          }
          return i2 || ++e2 != u2 ? i2 : (u2 = null == n2 ? 0 : n2.length, !!u2 && oc(u2) && Ci(o2, u2) && (bh(n2) || dh(n2)));
        }
        function zi(n2) {
          var t2 = n2.length, r2 = new n2.constructor(t2);
          return t2 && "string" == typeof n2[0] && bl.call(n2, "index") && (r2.index = n2.index, r2.input = n2.input), r2;
        }
        function Ei(n2) {
          return "function" != typeof n2.constructor || Mi(n2) ? {} : gs(El(n2));
        }
        function Si(n2, t2, r2) {
          var e2 = n2.constructor;
          switch (t2) {
            case ft:
              return Ru(n2);
            case Nn:
            case Pn:
              return new e2(+n2);
            case ct:
              return zu(n2, r2);
            case at:
            case lt:
            case st:
            case ht:
            case pt:
            case _t:
            case vt:
            case gt:
            case yt:
              return Wu(n2, r2);
            case Gn:
              return new e2();
            case Hn:
            case rt:
              return new e2(n2);
            case nt:
              return Eu(n2);
            case tt:
              return new e2();
            case et:
              return Su(n2);
          }
        }
        function Wi(n2, t2) {
          var r2 = t2.length;
          if (!r2) return n2;
          var e2 = r2 - 1;
          return t2[e2] = (r2 > 1 ? "& " : "") + t2[e2], t2 = t2.join(r2 > 2 ? ", " : " "), n2.replace(Ut, "{\n/* [wrapped with " + t2 + "] */\n");
        }
        function Li(n2) {
          return bh(n2) || dh(n2) || !!(Cl && n2 && n2[Cl]);
        }
        function Ci(n2, t2) {
          var r2 = typeof n2;
          return t2 = null == t2 ? Wn : t2, !!t2 && ("number" == r2 || "symbol" != r2 && Vt.test(n2)) && n2 > -1 && n2 % 1 == 0 && n2 < t2;
        }
        function Ui(n2, t2, r2) {
          if (!fc(r2)) return false;
          var e2 = typeof t2;
          return !!("number" == e2 ? Hf(r2) && Ci(t2, r2.length) : "string" == e2 && t2 in r2) && Gf(r2[t2], n2);
        }
        function Bi(n2, t2) {
          if (bh(n2)) return false;
          var r2 = typeof n2;
          return !("number" != r2 && "symbol" != r2 && "boolean" != r2 && null != n2 && !bc(n2)) || (zt.test(n2) || !Rt.test(n2) || null != t2 && n2 in ll(t2));
        }
        function Ti(n2) {
          var t2 = typeof n2;
          return "string" == t2 || "number" == t2 || "symbol" == t2 || "boolean" == t2 ? "__proto__" !== n2 : null === n2;
        }
        function $i(n2) {
          var t2 = bi(n2), r2 = Z2[t2];
          if ("function" != typeof r2 || !(t2 in Ct2.prototype)) return false;
          if (n2 === r2) return true;
          var e2 = Os(r2);
          return !!e2 && n2 === e2[0];
        }
        function Di(n2) {
          return !!ml && ml in n2;
        }
        function Mi(n2) {
          var t2 = n2 && n2.constructor;
          return n2 === ("function" == typeof t2 && t2.prototype || gl);
        }
        function Fi(n2) {
          return n2 === n2 && !fc(n2);
        }
        function Ni(n2, t2) {
          return function(r2) {
            return null != r2 && (r2[n2] === t2 && (t2 !== X || n2 in ll(r2)));
          };
        }
        function Pi(n2) {
          var t2 = Cf(n2, function(n3) {
            return r2.size === fn && r2.clear(), n3;
          }), r2 = t2.cache;
          return t2;
        }
        function qi(n2, t2) {
          var r2 = n2[1], e2 = t2[1], u2 = r2 | e2, i2 = u2 < (_n | vn | mn), o2 = e2 == mn && r2 == yn || e2 == mn && r2 == xn && n2[7].length <= t2[8] || e2 == (mn | xn) && t2[7].length <= t2[8] && r2 == yn;
          if (!i2 && !o2) return n2;
          e2 & _n && (n2[2] = t2[2], u2 |= r2 & _n ? 0 : gn);
          var f2 = t2[3];
          if (f2) {
            var c2 = n2[3];
            n2[3] = c2 ? Uu(c2, f2, t2[4]) : f2, n2[4] = c2 ? N(n2[3], cn) : t2[4];
          }
          return f2 = t2[5], f2 && (c2 = n2[5], n2[5] = c2 ? Bu(c2, f2, t2[6]) : f2, n2[6] = c2 ? N(n2[5], cn) : t2[6]), f2 = t2[7], f2 && (n2[7] = f2), e2 & mn && (n2[8] = null == n2[8] ? t2[8] : Hl(n2[8], t2[8])), null == n2[9] && (n2[9] = t2[9]), n2[0] = t2[0], n2[1] = u2, n2;
        }
        function Zi(n2) {
          var t2 = [];
          if (null != n2) for (var r2 in ll(n2)) t2.push(r2);
          return t2;
        }
        function Ki(n2) {
          return xl.call(n2);
        }
        function Vi(t2, r2, e2) {
          return r2 = Gl(r2 === X ? t2.length - 1 : r2, 0), function() {
            for (var u2 = arguments, i2 = -1, o2 = Gl(u2.length - r2, 0), f2 = il(o2); ++i2 < o2; ) f2[i2] = u2[r2 + i2];
            i2 = -1;
            for (var c2 = il(r2 + 1); ++i2 < r2; ) c2[i2] = u2[i2];
            return c2[r2] = e2(f2), n(t2, this, c2);
          };
        }
        function Gi(n2, t2) {
          return t2.length < 2 ? n2 : _e2(n2, au(t2, 0, -1));
        }
        function Hi(n2, t2) {
          for (var r2 = n2.length, e2 = Hl(t2.length, r2), u2 = Tu(n2); e2--; ) {
            var i2 = t2[e2];
            n2[e2] = Ci(i2, r2) ? u2[i2] : X;
          }
          return n2;
        }
        function Ji(n2, t2) {
          if (("constructor" !== t2 || "function" != typeof n2[t2]) && "__proto__" != t2) return n2[t2];
        }
        function Yi(n2, t2, r2) {
          var e2 = t2 + "";
          return Ls(n2, Wi(e2, ro(Ii(e2), r2)));
        }
        function Qi(n2) {
          var t2 = 0, r2 = 0;
          return function() {
            var e2 = Jl(), u2 = In - (e2 - r2);
            if (r2 = e2, u2 > 0) {
              if (++t2 >= On) return arguments[0];
            } else t2 = 0;
            return n2.apply(X, arguments);
          };
        }
        function Xi(n2, t2) {
          var r2 = -1, e2 = n2.length, u2 = e2 - 1;
          for (t2 = t2 === X ? e2 : t2; ++r2 < t2; ) {
            var i2 = tu(r2, u2), o2 = n2[i2];
            n2[i2] = n2[r2], n2[r2] = o2;
          }
          return n2.length = t2, n2;
        }
        function no(n2) {
          if ("string" == typeof n2 || bc(n2)) return n2;
          var t2 = n2 + "";
          return "0" == t2 && 1 / n2 == -Sn ? "-0" : t2;
        }
        function to(n2) {
          if (null != n2) {
            try {
              return dl.call(n2);
            } catch (n3) {
            }
            try {
              return n2 + "";
            } catch (n3) {
            }
          }
          return "";
        }
        function ro(n2, t2) {
          return r($n, function(r2) {
            var e2 = "_." + r2[0];
            t2 & r2[1] && !o(n2, e2) && n2.push(e2);
          }), n2.sort();
        }
        function eo(n2) {
          if (n2 instanceof Ct2) return n2.clone();
          var t2 = new Y2(n2.__wrapped__, n2.__chain__);
          return t2.__actions__ = Tu(n2.__actions__), t2.__index__ = n2.__index__, t2.__values__ = n2.__values__, t2;
        }
        function uo(n2, t2, r2) {
          t2 = (r2 ? Ui(n2, t2, r2) : t2 === X) ? 1 : Gl(kc(t2), 0);
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2 || t2 < 1) return [];
          for (var u2 = 0, i2 = 0, o2 = il(Fl(e2 / t2)); u2 < e2; ) o2[i2++] = au(n2, u2, u2 += t2);
          return o2;
        }
        function io(n2) {
          for (var t2 = -1, r2 = null == n2 ? 0 : n2.length, e2 = 0, u2 = []; ++t2 < r2; ) {
            var i2 = n2[t2];
            i2 && (u2[e2++] = i2);
          }
          return u2;
        }
        function oo() {
          var n2 = arguments.length;
          if (!n2) return [];
          for (var t2 = il(n2 - 1), r2 = arguments[0], e2 = n2; e2--; ) t2[e2 - 1] = arguments[e2];
          return a(bh(r2) ? Tu(r2) : [r2], ee2(t2, 1));
        }
        function fo(n2, t2, r2) {
          var e2 = null == n2 ? 0 : n2.length;
          return e2 ? (t2 = r2 || t2 === X ? 1 : kc(t2), au(n2, t2 < 0 ? 0 : t2, e2)) : [];
        }
        function co(n2, t2, r2) {
          var e2 = null == n2 ? 0 : n2.length;
          return e2 ? (t2 = r2 || t2 === X ? 1 : kc(t2), t2 = e2 - t2, au(n2, 0, t2 < 0 ? 0 : t2)) : [];
        }
        function ao(n2, t2) {
          return n2 && n2.length ? bu(n2, mi(t2, 3), true, true) : [];
        }
        function lo(n2, t2) {
          return n2 && n2.length ? bu(n2, mi(t2, 3), true) : [];
        }
        function so(n2, t2, r2, e2) {
          var u2 = null == n2 ? 0 : n2.length;
          return u2 ? (r2 && "number" != typeof r2 && Ui(n2, t2, r2) && (r2 = 0, e2 = u2), ne2(n2, t2, r2, e2)) : [];
        }
        function ho(n2, t2, r2) {
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2) return -1;
          var u2 = null == r2 ? 0 : kc(r2);
          return u2 < 0 && (u2 = Gl(e2 + u2, 0)), g(n2, mi(t2, 3), u2);
        }
        function po(n2, t2, r2) {
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2) return -1;
          var u2 = e2 - 1;
          return r2 !== X && (u2 = kc(r2), u2 = r2 < 0 ? Gl(e2 + u2, 0) : Hl(u2, e2 - 1)), g(n2, mi(t2, 3), u2, true);
        }
        function _o(n2) {
          return (null == n2 ? 0 : n2.length) ? ee2(n2, 1) : [];
        }
        function vo(n2) {
          return (null == n2 ? 0 : n2.length) ? ee2(n2, Sn) : [];
        }
        function go(n2, t2) {
          return (null == n2 ? 0 : n2.length) ? (t2 = t2 === X ? 1 : kc(t2), ee2(n2, t2)) : [];
        }
        function yo(n2) {
          for (var t2 = -1, r2 = null == n2 ? 0 : n2.length, e2 = {}; ++t2 < r2; ) {
            var u2 = n2[t2];
            e2[u2[0]] = u2[1];
          }
          return e2;
        }
        function bo(n2) {
          return n2 && n2.length ? n2[0] : X;
        }
        function wo(n2, t2, r2) {
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2) return -1;
          var u2 = null == r2 ? 0 : kc(r2);
          return u2 < 0 && (u2 = Gl(e2 + u2, 0)), y(n2, t2, u2);
        }
        function mo(n2) {
          return (null == n2 ? 0 : n2.length) ? au(n2, 0, -1) : [];
        }
        function xo(n2, t2) {
          return null == n2 ? "" : Kl.call(n2, t2);
        }
        function jo(n2) {
          var t2 = null == n2 ? 0 : n2.length;
          return t2 ? n2[t2 - 1] : X;
        }
        function Ao(n2, t2, r2) {
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2) return -1;
          var u2 = e2;
          return r2 !== X && (u2 = kc(r2), u2 = u2 < 0 ? Gl(e2 + u2, 0) : Hl(u2, e2 - 1)), t2 === t2 ? K(n2, t2, u2) : g(n2, b, u2, true);
        }
        function ko(n2, t2) {
          return n2 && n2.length ? Ge(n2, kc(t2)) : X;
        }
        function Oo(n2, t2) {
          return n2 && n2.length && t2 && t2.length ? Xe(n2, t2) : n2;
        }
        function Io(n2, t2, r2) {
          return n2 && n2.length && t2 && t2.length ? Xe(n2, t2, mi(r2, 2)) : n2;
        }
        function Ro(n2, t2, r2) {
          return n2 && n2.length && t2 && t2.length ? Xe(n2, t2, X, r2) : n2;
        }
        function zo(n2, t2) {
          var r2 = [];
          if (!n2 || !n2.length) return r2;
          var e2 = -1, u2 = [], i2 = n2.length;
          for (t2 = mi(t2, 3); ++e2 < i2; ) {
            var o2 = n2[e2];
            t2(o2, e2, n2) && (r2.push(o2), u2.push(e2));
          }
          return nu(n2, u2), r2;
        }
        function Eo(n2) {
          return null == n2 ? n2 : Xl.call(n2);
        }
        function So(n2, t2, r2) {
          var e2 = null == n2 ? 0 : n2.length;
          return e2 ? (r2 && "number" != typeof r2 && Ui(n2, t2, r2) ? (t2 = 0, r2 = e2) : (t2 = null == t2 ? 0 : kc(t2), r2 = r2 === X ? e2 : kc(r2)), au(n2, t2, r2)) : [];
        }
        function Wo(n2, t2) {
          return su(n2, t2);
        }
        function Lo(n2, t2, r2) {
          return hu(n2, t2, mi(r2, 2));
        }
        function Co(n2, t2) {
          var r2 = null == n2 ? 0 : n2.length;
          if (r2) {
            var e2 = su(n2, t2);
            if (e2 < r2 && Gf(n2[e2], t2)) return e2;
          }
          return -1;
        }
        function Uo(n2, t2) {
          return su(n2, t2, true);
        }
        function Bo(n2, t2, r2) {
          return hu(n2, t2, mi(r2, 2), true);
        }
        function To(n2, t2) {
          if (null == n2 ? 0 : n2.length) {
            var r2 = su(n2, t2, true) - 1;
            if (Gf(n2[r2], t2)) return r2;
          }
          return -1;
        }
        function $o(n2) {
          return n2 && n2.length ? pu(n2) : [];
        }
        function Do(n2, t2) {
          return n2 && n2.length ? pu(n2, mi(t2, 2)) : [];
        }
        function Mo(n2) {
          var t2 = null == n2 ? 0 : n2.length;
          return t2 ? au(n2, 1, t2) : [];
        }
        function Fo(n2, t2, r2) {
          return n2 && n2.length ? (t2 = r2 || t2 === X ? 1 : kc(t2), au(n2, 0, t2 < 0 ? 0 : t2)) : [];
        }
        function No(n2, t2, r2) {
          var e2 = null == n2 ? 0 : n2.length;
          return e2 ? (t2 = r2 || t2 === X ? 1 : kc(t2), t2 = e2 - t2, au(n2, t2 < 0 ? 0 : t2, e2)) : [];
        }
        function Po(n2, t2) {
          return n2 && n2.length ? bu(n2, mi(t2, 3), false, true) : [];
        }
        function qo(n2, t2) {
          return n2 && n2.length ? bu(n2, mi(t2, 3)) : [];
        }
        function Zo(n2) {
          return n2 && n2.length ? gu(n2) : [];
        }
        function Ko(n2, t2) {
          return n2 && n2.length ? gu(n2, mi(t2, 2)) : [];
        }
        function Vo(n2, t2) {
          return t2 = "function" == typeof t2 ? t2 : X, n2 && n2.length ? gu(n2, X, t2) : [];
        }
        function Go(n2) {
          if (!n2 || !n2.length) return [];
          var t2 = 0;
          return n2 = i(n2, function(n3) {
            if (Jf(n3)) return t2 = Gl(n3.length, t2), true;
          }), O(t2, function(t3) {
            return c(n2, m(t3));
          });
        }
        function Ho(t2, r2) {
          if (!t2 || !t2.length) return [];
          var e2 = Go(t2);
          return null == r2 ? e2 : c(e2, function(t3) {
            return n(r2, X, t3);
          });
        }
        function Jo(n2, t2) {
          return xu(n2 || [], t2 || [], Sr2);
        }
        function Yo(n2, t2) {
          return xu(n2 || [], t2 || [], fu);
        }
        function Qo(n2) {
          var t2 = Z2(n2);
          return t2.__chain__ = true, t2;
        }
        function Xo(n2, t2) {
          return t2(n2), n2;
        }
        function nf(n2, t2) {
          return t2(n2);
        }
        function tf() {
          return Qo(this);
        }
        function rf() {
          return new Y2(this.value(), this.__chain__);
        }
        function ef() {
          this.__values__ === X && (this.__values__ = jc(this.value()));
          var n2 = this.__index__ >= this.__values__.length;
          return { done: n2, value: n2 ? X : this.__values__[this.__index__++] };
        }
        function uf() {
          return this;
        }
        function of2(n2) {
          for (var t2, r2 = this; r2 instanceof J2; ) {
            var e2 = eo(r2);
            e2.__index__ = 0, e2.__values__ = X, t2 ? u2.__wrapped__ = e2 : t2 = e2;
            var u2 = e2;
            r2 = r2.__wrapped__;
          }
          return u2.__wrapped__ = n2, t2;
        }
        function ff() {
          var n2 = this.__wrapped__;
          if (n2 instanceof Ct2) {
            var t2 = n2;
            return this.__actions__.length && (t2 = new Ct2(this)), t2 = t2.reverse(), t2.__actions__.push({ func: nf, args: [Eo], thisArg: X }), new Y2(t2, this.__chain__);
          }
          return this.thru(Eo);
        }
        function cf() {
          return wu(this.__wrapped__, this.__actions__);
        }
        function af(n2, t2, r2) {
          var e2 = bh(n2) ? u : Jr2;
          return r2 && Ui(n2, t2, r2) && (t2 = X), e2(n2, mi(t2, 3));
        }
        function lf(n2, t2) {
          return (bh(n2) ? i : te2)(n2, mi(t2, 3));
        }
        function sf(n2, t2) {
          return ee2(yf(n2, t2), 1);
        }
        function hf(n2, t2) {
          return ee2(yf(n2, t2), Sn);
        }
        function pf(n2, t2, r2) {
          return r2 = r2 === X ? 1 : kc(r2), ee2(yf(n2, t2), r2);
        }
        function _f(n2, t2) {
          return (bh(n2) ? r : ys)(n2, mi(t2, 3));
        }
        function vf(n2, t2) {
          return (bh(n2) ? e : ds)(n2, mi(t2, 3));
        }
        function gf(n2, t2, r2, e2) {
          n2 = Hf(n2) ? n2 : ra(n2), r2 = r2 && !e2 ? kc(r2) : 0;
          var u2 = n2.length;
          return r2 < 0 && (r2 = Gl(u2 + r2, 0)), dc(n2) ? r2 <= u2 && n2.indexOf(t2, r2) > -1 : !!u2 && y(n2, t2, r2) > -1;
        }
        function yf(n2, t2) {
          return (bh(n2) ? c : Pe)(n2, mi(t2, 3));
        }
        function df(n2, t2, r2, e2) {
          return null == n2 ? [] : (bh(t2) || (t2 = null == t2 ? [] : [t2]), r2 = e2 ? X : r2, bh(r2) || (r2 = null == r2 ? [] : [r2]), He(n2, t2, r2));
        }
        function bf(n2, t2, r2) {
          var e2 = bh(n2) ? l : j, u2 = arguments.length < 3;
          return e2(n2, mi(t2, 4), r2, u2, ys);
        }
        function wf(n2, t2, r2) {
          var e2 = bh(n2) ? s : j, u2 = arguments.length < 3;
          return e2(n2, mi(t2, 4), r2, u2, ds);
        }
        function mf(n2, t2) {
          return (bh(n2) ? i : te2)(n2, Uf(mi(t2, 3)));
        }
        function xf(n2) {
          return (bh(n2) ? Ir2 : iu)(n2);
        }
        function jf(n2, t2, r2) {
          return t2 = (r2 ? Ui(n2, t2, r2) : t2 === X) ? 1 : kc(t2), (bh(n2) ? Rr2 : ou)(n2, t2);
        }
        function Af(n2) {
          return (bh(n2) ? zr2 : cu)(n2);
        }
        function kf(n2) {
          if (null == n2) return 0;
          if (Hf(n2)) return dc(n2) ? V(n2) : n2.length;
          var t2 = zs(n2);
          return t2 == Gn || t2 == tt ? n2.size : Me(n2).length;
        }
        function Of(n2, t2, r2) {
          var e2 = bh(n2) ? h : lu;
          return r2 && Ui(n2, t2, r2) && (t2 = X), e2(n2, mi(t2, 3));
        }
        function If(n2, t2) {
          if ("function" != typeof t2) throw new pl(en);
          return n2 = kc(n2), function() {
            if (--n2 < 1) return t2.apply(this, arguments);
          };
        }
        function Rf(n2, t2, r2) {
          return t2 = r2 ? X : t2, t2 = n2 && null == t2 ? n2.length : t2, ai(n2, mn, X, X, X, X, t2);
        }
        function zf(n2, t2) {
          var r2;
          if ("function" != typeof t2) throw new pl(en);
          return n2 = kc(n2), function() {
            return --n2 > 0 && (r2 = t2.apply(this, arguments)), n2 <= 1 && (t2 = X), r2;
          };
        }
        function Ef(n2, t2, r2) {
          t2 = r2 ? X : t2;
          var e2 = ai(n2, yn, X, X, X, X, X, t2);
          return e2.placeholder = Ef.placeholder, e2;
        }
        function Sf(n2, t2, r2) {
          t2 = r2 ? X : t2;
          var e2 = ai(n2, dn, X, X, X, X, X, t2);
          return e2.placeholder = Sf.placeholder, e2;
        }
        function Wf(n2, t2, r2) {
          function e2(t3) {
            var r3 = h2, e3 = p3;
            return h2 = p3 = X, d2 = t3, v2 = n2.apply(e3, r3);
          }
          function u2(n3) {
            return d2 = n3, g2 = Ws(f2, t2), b2 ? e2(n3) : v2;
          }
          function i2(n3) {
            var r3 = n3 - y2, e3 = n3 - d2, u3 = t2 - r3;
            return w2 ? Hl(u3, _2 - e3) : u3;
          }
          function o2(n3) {
            var r3 = n3 - y2, e3 = n3 - d2;
            return y2 === X || r3 >= t2 || r3 < 0 || w2 && e3 >= _2;
          }
          function f2() {
            var n3 = fh();
            return o2(n3) ? c2(n3) : (g2 = Ws(f2, i2(n3)), X);
          }
          function c2(n3) {
            return g2 = X, m2 && h2 ? e2(n3) : (h2 = p3 = X, v2);
          }
          function a2() {
            g2 !== X && As(g2), d2 = 0, h2 = y2 = p3 = g2 = X;
          }
          function l2() {
            return g2 === X ? v2 : c2(fh());
          }
          function s2() {
            var n3 = fh(), r3 = o2(n3);
            if (h2 = arguments, p3 = this, y2 = n3, r3) {
              if (g2 === X) return u2(y2);
              if (w2) return As(g2), g2 = Ws(f2, t2), e2(y2);
            }
            return g2 === X && (g2 = Ws(f2, t2)), v2;
          }
          var h2, p3, _2, v2, g2, y2, d2 = 0, b2 = false, w2 = false, m2 = true;
          if ("function" != typeof n2) throw new pl(en);
          return t2 = Ic(t2) || 0, fc(r2) && (b2 = !!r2.leading, w2 = "maxWait" in r2, _2 = w2 ? Gl(Ic(r2.maxWait) || 0, t2) : _2, m2 = "trailing" in r2 ? !!r2.trailing : m2), s2.cancel = a2, s2.flush = l2, s2;
        }
        function Lf(n2) {
          return ai(n2, jn);
        }
        function Cf(n2, t2) {
          if ("function" != typeof n2 || null != t2 && "function" != typeof t2) throw new pl(en);
          var r2 = function() {
            var e2 = arguments, u2 = t2 ? t2.apply(this, e2) : e2[0], i2 = r2.cache;
            if (i2.has(u2)) return i2.get(u2);
            var o2 = n2.apply(this, e2);
            return r2.cache = i2.set(u2, o2) || i2, o2;
          };
          return r2.cache = new (Cf.Cache || sr2)(), r2;
        }
        function Uf(n2) {
          if ("function" != typeof n2) throw new pl(en);
          return function() {
            var t2 = arguments;
            switch (t2.length) {
              case 0:
                return !n2.call(this);
              case 1:
                return !n2.call(this, t2[0]);
              case 2:
                return !n2.call(this, t2[0], t2[1]);
              case 3:
                return !n2.call(this, t2[0], t2[1], t2[2]);
            }
            return !n2.apply(this, t2);
          };
        }
        function Bf(n2) {
          return zf(2, n2);
        }
        function Tf(n2, t2) {
          if ("function" != typeof n2) throw new pl(en);
          return t2 = t2 === X ? t2 : kc(t2), uu(n2, t2);
        }
        function $f(t2, r2) {
          if ("function" != typeof t2) throw new pl(en);
          return r2 = null == r2 ? 0 : Gl(kc(r2), 0), uu(function(e2) {
            var u2 = e2[r2], i2 = Ou(e2, 0, r2);
            return u2 && a(i2, u2), n(t2, this, i2);
          });
        }
        function Df(n2, t2, r2) {
          var e2 = true, u2 = true;
          if ("function" != typeof n2) throw new pl(en);
          return fc(r2) && (e2 = "leading" in r2 ? !!r2.leading : e2, u2 = "trailing" in r2 ? !!r2.trailing : u2), Wf(n2, t2, { leading: e2, maxWait: t2, trailing: u2 });
        }
        function Mf(n2) {
          return Rf(n2, 1);
        }
        function Ff(n2, t2) {
          return ph(Au(t2), n2);
        }
        function Nf() {
          if (!arguments.length) return [];
          var n2 = arguments[0];
          return bh(n2) ? n2 : [n2];
        }
        function Pf(n2) {
          return Fr2(n2, sn);
        }
        function qf(n2, t2) {
          return t2 = "function" == typeof t2 ? t2 : X, Fr2(n2, sn, t2);
        }
        function Zf(n2) {
          return Fr2(n2, an | sn);
        }
        function Kf(n2, t2) {
          return t2 = "function" == typeof t2 ? t2 : X, Fr2(n2, an | sn, t2);
        }
        function Vf(n2, t2) {
          return null == t2 || Pr2(n2, t2, Pc(t2));
        }
        function Gf(n2, t2) {
          return n2 === t2 || n2 !== n2 && t2 !== t2;
        }
        function Hf(n2) {
          return null != n2 && oc(n2.length) && !uc(n2);
        }
        function Jf(n2) {
          return cc(n2) && Hf(n2);
        }
        function Yf(n2) {
          return n2 === true || n2 === false || cc(n2) && we(n2) == Nn;
        }
        function Qf(n2) {
          return cc(n2) && 1 === n2.nodeType && !gc(n2);
        }
        function Xf(n2) {
          if (null == n2) return true;
          if (Hf(n2) && (bh(n2) || "string" == typeof n2 || "function" == typeof n2.splice || mh(n2) || Oh(n2) || dh(n2))) return !n2.length;
          var t2 = zs(n2);
          if (t2 == Gn || t2 == tt) return !n2.size;
          if (Mi(n2)) return !Me(n2).length;
          for (var r2 in n2) if (bl.call(n2, r2)) return false;
          return true;
        }
        function nc(n2, t2) {
          return Se(n2, t2);
        }
        function tc(n2, t2, r2) {
          r2 = "function" == typeof r2 ? r2 : X;
          var e2 = r2 ? r2(n2, t2) : X;
          return e2 === X ? Se(n2, t2, X, r2) : !!e2;
        }
        function rc(n2) {
          if (!cc(n2)) return false;
          var t2 = we(n2);
          return t2 == Zn || t2 == qn || "string" == typeof n2.message && "string" == typeof n2.name && !gc(n2);
        }
        function ec(n2) {
          return "number" == typeof n2 && Zl(n2);
        }
        function uc(n2) {
          if (!fc(n2)) return false;
          var t2 = we(n2);
          return t2 == Kn || t2 == Vn || t2 == Fn || t2 == Xn;
        }
        function ic(n2) {
          return "number" == typeof n2 && n2 == kc(n2);
        }
        function oc(n2) {
          return "number" == typeof n2 && n2 > -1 && n2 % 1 == 0 && n2 <= Wn;
        }
        function fc(n2) {
          var t2 = typeof n2;
          return null != n2 && ("object" == t2 || "function" == t2);
        }
        function cc(n2) {
          return null != n2 && "object" == typeof n2;
        }
        function ac(n2, t2) {
          return n2 === t2 || Ce(n2, t2, ji(t2));
        }
        function lc(n2, t2, r2) {
          return r2 = "function" == typeof r2 ? r2 : X, Ce(n2, t2, ji(t2), r2);
        }
        function sc(n2) {
          return vc(n2) && n2 != +n2;
        }
        function hc(n2) {
          if (Es(n2)) throw new fl(rn);
          return Ue(n2);
        }
        function pc(n2) {
          return null === n2;
        }
        function _c(n2) {
          return null == n2;
        }
        function vc(n2) {
          return "number" == typeof n2 || cc(n2) && we(n2) == Hn;
        }
        function gc(n2) {
          if (!cc(n2) || we(n2) != Yn) return false;
          var t2 = El(n2);
          if (null === t2) return true;
          var r2 = bl.call(t2, "constructor") && t2.constructor;
          return "function" == typeof r2 && r2 instanceof r2 && dl.call(r2) == jl;
        }
        function yc(n2) {
          return ic(n2) && n2 >= -Wn && n2 <= Wn;
        }
        function dc(n2) {
          return "string" == typeof n2 || !bh(n2) && cc(n2) && we(n2) == rt;
        }
        function bc(n2) {
          return "symbol" == typeof n2 || cc(n2) && we(n2) == et;
        }
        function wc(n2) {
          return n2 === X;
        }
        function mc(n2) {
          return cc(n2) && zs(n2) == it;
        }
        function xc(n2) {
          return cc(n2) && we(n2) == ot;
        }
        function jc(n2) {
          if (!n2) return [];
          if (Hf(n2)) return dc(n2) ? G(n2) : Tu(n2);
          if (Ul && n2[Ul]) return D(n2[Ul]());
          var t2 = zs(n2);
          return (t2 == Gn ? M : t2 == tt ? P : ra)(n2);
        }
        function Ac(n2) {
          if (!n2) return 0 === n2 ? n2 : 0;
          if (n2 = Ic(n2), n2 === Sn || n2 === -Sn) {
            return (n2 < 0 ? -1 : 1) * Ln;
          }
          return n2 === n2 ? n2 : 0;
        }
        function kc(n2) {
          var t2 = Ac(n2), r2 = t2 % 1;
          return t2 === t2 ? r2 ? t2 - r2 : t2 : 0;
        }
        function Oc(n2) {
          return n2 ? Mr2(kc(n2), 0, Un) : 0;
        }
        function Ic(n2) {
          if ("number" == typeof n2) return n2;
          if (bc(n2)) return Cn;
          if (fc(n2)) {
            var t2 = "function" == typeof n2.valueOf ? n2.valueOf() : n2;
            n2 = fc(t2) ? t2 + "" : t2;
          }
          if ("string" != typeof n2) return 0 === n2 ? n2 : +n2;
          n2 = R(n2);
          var r2 = qt.test(n2);
          return r2 || Kt.test(n2) ? Xr(n2.slice(2), r2 ? 2 : 8) : Pt.test(n2) ? Cn : +n2;
        }
        function Rc(n2) {
          return $u(n2, qc(n2));
        }
        function zc(n2) {
          return n2 ? Mr2(kc(n2), -Wn, Wn) : 0 === n2 ? n2 : 0;
        }
        function Ec(n2) {
          return null == n2 ? "" : vu(n2);
        }
        function Sc(n2, t2) {
          var r2 = gs(n2);
          return null == t2 ? r2 : Cr2(r2, t2);
        }
        function Wc(n2, t2) {
          return v(n2, mi(t2, 3), ue2);
        }
        function Lc(n2, t2) {
          return v(n2, mi(t2, 3), oe2);
        }
        function Cc(n2, t2) {
          return null == n2 ? n2 : bs(n2, mi(t2, 3), qc);
        }
        function Uc(n2, t2) {
          return null == n2 ? n2 : ws(n2, mi(t2, 3), qc);
        }
        function Bc(n2, t2) {
          return n2 && ue2(n2, mi(t2, 3));
        }
        function Tc(n2, t2) {
          return n2 && oe2(n2, mi(t2, 3));
        }
        function $c(n2) {
          return null == n2 ? [] : fe2(n2, Pc(n2));
        }
        function Dc(n2) {
          return null == n2 ? [] : fe2(n2, qc(n2));
        }
        function Mc(n2, t2, r2) {
          var e2 = null == n2 ? X : _e2(n2, t2);
          return e2 === X ? r2 : e2;
        }
        function Fc(n2, t2) {
          return null != n2 && Ri(n2, t2, xe);
        }
        function Nc(n2, t2) {
          return null != n2 && Ri(n2, t2, je);
        }
        function Pc(n2) {
          return Hf(n2) ? Or2(n2) : Me(n2);
        }
        function qc(n2) {
          return Hf(n2) ? Or2(n2, true) : Fe(n2);
        }
        function Zc(n2, t2) {
          var r2 = {};
          return t2 = mi(t2, 3), ue2(n2, function(n3, e2, u2) {
            Br2(r2, t2(n3, e2, u2), n3);
          }), r2;
        }
        function Kc(n2, t2) {
          var r2 = {};
          return t2 = mi(t2, 3), ue2(n2, function(n3, e2, u2) {
            Br2(r2, e2, t2(n3, e2, u2));
          }), r2;
        }
        function Vc(n2, t2) {
          return Gc(n2, Uf(mi(t2)));
        }
        function Gc(n2, t2) {
          if (null == n2) return {};
          var r2 = c(di(n2), function(n3) {
            return [n3];
          });
          return t2 = mi(t2), Ye(n2, r2, function(n3, r3) {
            return t2(n3, r3[0]);
          });
        }
        function Hc(n2, t2, r2) {
          t2 = ku(t2, n2);
          var e2 = -1, u2 = t2.length;
          for (u2 || (u2 = 1, n2 = X); ++e2 < u2; ) {
            var i2 = null == n2 ? X : n2[no(t2[e2])];
            i2 === X && (e2 = u2, i2 = r2), n2 = uc(i2) ? i2.call(n2) : i2;
          }
          return n2;
        }
        function Jc(n2, t2, r2) {
          return null == n2 ? n2 : fu(n2, t2, r2);
        }
        function Yc(n2, t2, r2, e2) {
          return e2 = "function" == typeof e2 ? e2 : X, null == n2 ? n2 : fu(n2, t2, r2, e2);
        }
        function Qc(n2, t2, e2) {
          var u2 = bh(n2), i2 = u2 || mh(n2) || Oh(n2);
          if (t2 = mi(t2, 4), null == e2) {
            var o2 = n2 && n2.constructor;
            e2 = i2 ? u2 ? new o2() : [] : fc(n2) && uc(o2) ? gs(El(n2)) : {};
          }
          return (i2 ? r : ue2)(n2, function(n3, r2, u3) {
            return t2(e2, n3, r2, u3);
          }), e2;
        }
        function Xc(n2, t2) {
          return null == n2 || yu(n2, t2);
        }
        function na(n2, t2, r2) {
          return null == n2 ? n2 : du(n2, t2, Au(r2));
        }
        function ta(n2, t2, r2, e2) {
          return e2 = "function" == typeof e2 ? e2 : X, null == n2 ? n2 : du(n2, t2, Au(r2), e2);
        }
        function ra(n2) {
          return null == n2 ? [] : E(n2, Pc(n2));
        }
        function ea(n2) {
          return null == n2 ? [] : E(n2, qc(n2));
        }
        function ua(n2, t2, r2) {
          return r2 === X && (r2 = t2, t2 = X), r2 !== X && (r2 = Ic(r2), r2 = r2 === r2 ? r2 : 0), t2 !== X && (t2 = Ic(t2), t2 = t2 === t2 ? t2 : 0), Mr2(Ic(n2), t2, r2);
        }
        function ia(n2, t2, r2) {
          return t2 = Ac(t2), r2 === X ? (r2 = t2, t2 = 0) : r2 = Ac(r2), n2 = Ic(n2), Ae(n2, t2, r2);
        }
        function oa(n2, t2, r2) {
          if (r2 && "boolean" != typeof r2 && Ui(n2, t2, r2) && (t2 = r2 = X), r2 === X && ("boolean" == typeof t2 ? (r2 = t2, t2 = X) : "boolean" == typeof n2 && (r2 = n2, n2 = X)), n2 === X && t2 === X ? (n2 = 0, t2 = 1) : (n2 = Ac(n2), t2 === X ? (t2 = n2, n2 = 0) : t2 = Ac(t2)), n2 > t2) {
            var e2 = n2;
            n2 = t2, t2 = e2;
          }
          if (r2 || n2 % 1 || t2 % 1) {
            var u2 = Ql();
            return Hl(n2 + u2 * (t2 - n2 + Qr("1e-" + ((u2 + "").length - 1))), t2);
          }
          return tu(n2, t2);
        }
        function fa(n2) {
          return Qh(Ec(n2).toLowerCase());
        }
        function ca(n2) {
          return n2 = Ec(n2), n2 && n2.replace(Gt, ve).replace(Dr, "");
        }
        function aa(n2, t2, r2) {
          n2 = Ec(n2), t2 = vu(t2);
          var e2 = n2.length;
          r2 = r2 === X ? e2 : Mr2(kc(r2), 0, e2);
          var u2 = r2;
          return r2 -= t2.length, r2 >= 0 && n2.slice(r2, u2) == t2;
        }
        function la(n2) {
          return n2 = Ec(n2), n2 && At.test(n2) ? n2.replace(xt, ge) : n2;
        }
        function sa(n2) {
          return n2 = Ec(n2), n2 && Wt.test(n2) ? n2.replace(St, "\\$&") : n2;
        }
        function ha(n2, t2, r2) {
          n2 = Ec(n2), t2 = kc(t2);
          var e2 = t2 ? V(n2) : 0;
          if (!t2 || e2 >= t2) return n2;
          var u2 = (t2 - e2) / 2;
          return ri(Nl(u2), r2) + n2 + ri(Fl(u2), r2);
        }
        function pa(n2, t2, r2) {
          n2 = Ec(n2), t2 = kc(t2);
          var e2 = t2 ? V(n2) : 0;
          return t2 && e2 < t2 ? n2 + ri(t2 - e2, r2) : n2;
        }
        function _a(n2, t2, r2) {
          n2 = Ec(n2), t2 = kc(t2);
          var e2 = t2 ? V(n2) : 0;
          return t2 && e2 < t2 ? ri(t2 - e2, r2) + n2 : n2;
        }
        function va(n2, t2, r2) {
          return r2 || null == t2 ? t2 = 0 : t2 && (t2 = +t2), Yl(Ec(n2).replace(Lt, ""), t2 || 0);
        }
        function ga(n2, t2, r2) {
          return t2 = (r2 ? Ui(n2, t2, r2) : t2 === X) ? 1 : kc(t2), eu(Ec(n2), t2);
        }
        function ya() {
          var n2 = arguments, t2 = Ec(n2[0]);
          return n2.length < 3 ? t2 : t2.replace(n2[1], n2[2]);
        }
        function da(n2, t2, r2) {
          return r2 && "number" != typeof r2 && Ui(n2, t2, r2) && (t2 = r2 = X), (r2 = r2 === X ? Un : r2 >>> 0) ? (n2 = Ec(n2), n2 && ("string" == typeof t2 || null != t2 && !Ah(t2)) && (t2 = vu(t2), !t2 && T(n2)) ? Ou(G(n2), 0, r2) : n2.split(t2, r2)) : [];
        }
        function ba(n2, t2, r2) {
          return n2 = Ec(n2), r2 = null == r2 ? 0 : Mr2(kc(r2), 0, n2.length), t2 = vu(t2), n2.slice(r2, r2 + t2.length) == t2;
        }
        function wa(n2, t2, r2) {
          var e2 = Z2.templateSettings;
          r2 && Ui(n2, t2, r2) && (t2 = X), n2 = Ec(n2), t2 = Sh({}, t2, e2, li);
          var u2, i2, o2 = Sh({}, t2.imports, e2.imports, li), f2 = Pc(o2), c2 = E(o2, f2), a2 = 0, l2 = t2.interpolate || Ht, s2 = "__p += '", h2 = sl((t2.escape || Ht).source + "|" + l2.source + "|" + (l2 === It ? Ft : Ht).source + "|" + (t2.evaluate || Ht).source + "|$", "g"), p3 = "//# sourceURL=" + (bl.call(t2, "sourceURL") ? (t2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Zr + "]") + "\n";
          n2.replace(h2, function(t3, r3, e3, o3, f3, c3) {
            return e3 || (e3 = o3), s2 += n2.slice(a2, c3).replace(Jt, U), r3 && (u2 = true, s2 += "' +\n__e(" + r3 + ") +\n'"), f3 && (i2 = true, s2 += "';\n" + f3 + ";\n__p += '"), e3 && (s2 += "' +\n((__t = (" + e3 + ")) == null ? '' : __t) +\n'"), a2 = c3 + t3.length, t3;
          }), s2 += "';\n";
          var _2 = bl.call(t2, "variable") && t2.variable;
          if (_2) {
            if (Dt.test(_2)) throw new fl(un);
          } else s2 = "with (obj) {\n" + s2 + "\n}\n";
          s2 = (i2 ? s2.replace(dt, "") : s2).replace(bt, "$1").replace(wt, "$1;"), s2 = "function(" + (_2 || "obj") + ") {\n" + (_2 ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (u2 ? ", __e = _.escape" : "") + (i2 ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + s2 + "return __p\n}";
          var v2 = Xh(function() {
            return cl(f2, p3 + "return " + s2).apply(X, c2);
          });
          if (v2.source = s2, rc(v2)) throw v2;
          return v2;
        }
        function ma(n2) {
          return Ec(n2).toLowerCase();
        }
        function xa(n2) {
          return Ec(n2).toUpperCase();
        }
        function ja(n2, t2, r2) {
          if (n2 = Ec(n2), n2 && (r2 || t2 === X)) return R(n2);
          if (!n2 || !(t2 = vu(t2))) return n2;
          var e2 = G(n2), u2 = G(t2);
          return Ou(e2, W(e2, u2), L(e2, u2) + 1).join("");
        }
        function Aa(n2, t2, r2) {
          if (n2 = Ec(n2), n2 && (r2 || t2 === X)) return n2.slice(0, H(n2) + 1);
          if (!n2 || !(t2 = vu(t2))) return n2;
          var e2 = G(n2);
          return Ou(e2, 0, L(e2, G(t2)) + 1).join("");
        }
        function ka(n2, t2, r2) {
          if (n2 = Ec(n2), n2 && (r2 || t2 === X)) return n2.replace(Lt, "");
          if (!n2 || !(t2 = vu(t2))) return n2;
          var e2 = G(n2);
          return Ou(e2, W(e2, G(t2))).join("");
        }
        function Oa(n2, t2) {
          var r2 = An, e2 = kn;
          if (fc(t2)) {
            var u2 = "separator" in t2 ? t2.separator : u2;
            r2 = "length" in t2 ? kc(t2.length) : r2, e2 = "omission" in t2 ? vu(t2.omission) : e2;
          }
          n2 = Ec(n2);
          var i2 = n2.length;
          if (T(n2)) {
            var o2 = G(n2);
            i2 = o2.length;
          }
          if (r2 >= i2) return n2;
          var f2 = r2 - V(e2);
          if (f2 < 1) return e2;
          var c2 = o2 ? Ou(o2, 0, f2).join("") : n2.slice(0, f2);
          if (u2 === X) return c2 + e2;
          if (o2 && (f2 += c2.length - f2), Ah(u2)) {
            if (n2.slice(f2).search(u2)) {
              var a2, l2 = c2;
              for (u2.global || (u2 = sl(u2.source, Ec(Nt.exec(u2)) + "g")), u2.lastIndex = 0; a2 = u2.exec(l2); ) var s2 = a2.index;
              c2 = c2.slice(0, s2 === X ? f2 : s2);
            }
          } else if (n2.indexOf(vu(u2), f2) != f2) {
            var h2 = c2.lastIndexOf(u2);
            h2 > -1 && (c2 = c2.slice(0, h2));
          }
          return c2 + e2;
        }
        function Ia(n2) {
          return n2 = Ec(n2), n2 && jt.test(n2) ? n2.replace(mt, ye) : n2;
        }
        function Ra(n2, t2, r2) {
          return n2 = Ec(n2), t2 = r2 ? X : t2, t2 === X ? $(n2) ? Q(n2) : _(n2) : n2.match(t2) || [];
        }
        function za(t2) {
          var r2 = null == t2 ? 0 : t2.length, e2 = mi();
          return t2 = r2 ? c(t2, function(n2) {
            if ("function" != typeof n2[1]) throw new pl(en);
            return [e2(n2[0]), n2[1]];
          }) : [], uu(function(e3) {
            for (var u2 = -1; ++u2 < r2; ) {
              var i2 = t2[u2];
              if (n(i2[0], this, e3)) return n(i2[1], this, e3);
            }
          });
        }
        function Ea(n2) {
          return Nr2(Fr2(n2, an));
        }
        function Sa(n2) {
          return function() {
            return n2;
          };
        }
        function Wa(n2, t2) {
          return null == n2 || n2 !== n2 ? t2 : n2;
        }
        function La(n2) {
          return n2;
        }
        function Ca(n2) {
          return De("function" == typeof n2 ? n2 : Fr2(n2, an));
        }
        function Ua(n2) {
          return qe(Fr2(n2, an));
        }
        function Ba(n2, t2) {
          return Ze(n2, Fr2(t2, an));
        }
        function Ta(n2, t2, e2) {
          var u2 = Pc(t2), i2 = fe2(t2, u2);
          null != e2 || fc(t2) && (i2.length || !u2.length) || (e2 = t2, t2 = n2, n2 = this, i2 = fe2(t2, Pc(t2)));
          var o2 = !(fc(e2) && "chain" in e2 && !e2.chain), f2 = uc(n2);
          return r(i2, function(r2) {
            var e3 = t2[r2];
            n2[r2] = e3, f2 && (n2.prototype[r2] = function() {
              var t3 = this.__chain__;
              if (o2 || t3) {
                var r3 = n2(this.__wrapped__);
                return (r3.__actions__ = Tu(this.__actions__)).push({ func: e3, args: arguments, thisArg: n2 }), r3.__chain__ = t3, r3;
              }
              return e3.apply(n2, a([this.value()], arguments));
            });
          }), n2;
        }
        function $a() {
          return re._ === this && (re._ = Al), this;
        }
        function Da() {
        }
        function Ma(n2) {
          return n2 = kc(n2), uu(function(t2) {
            return Ge(t2, n2);
          });
        }
        function Fa(n2) {
          return Bi(n2) ? m(no(n2)) : Qe(n2);
        }
        function Na(n2) {
          return function(t2) {
            return null == n2 ? X : _e2(n2, t2);
          };
        }
        function Pa() {
          return [];
        }
        function qa() {
          return false;
        }
        function Za() {
          return {};
        }
        function Ka() {
          return "";
        }
        function Va() {
          return true;
        }
        function Ga(n2, t2) {
          if (n2 = kc(n2), n2 < 1 || n2 > Wn) return [];
          var r2 = Un, e2 = Hl(n2, Un);
          t2 = mi(t2), n2 -= Un;
          for (var u2 = O(e2, t2); ++r2 < n2; ) t2(r2);
          return u2;
        }
        function Ha(n2) {
          return bh(n2) ? c(n2, no) : bc(n2) ? [n2] : Tu(Cs(Ec(n2)));
        }
        function Ja(n2) {
          var t2 = ++wl;
          return Ec(n2) + t2;
        }
        function Ya(n2) {
          return n2 && n2.length ? Yr2(n2, La, me) : X;
        }
        function Qa(n2, t2) {
          return n2 && n2.length ? Yr2(n2, mi(t2, 2), me) : X;
        }
        function Xa(n2) {
          return w(n2, La);
        }
        function nl(n2, t2) {
          return w(n2, mi(t2, 2));
        }
        function tl(n2) {
          return n2 && n2.length ? Yr2(n2, La, Ne) : X;
        }
        function rl(n2, t2) {
          return n2 && n2.length ? Yr2(n2, mi(t2, 2), Ne) : X;
        }
        function el(n2) {
          return n2 && n2.length ? k(n2, La) : 0;
        }
        function ul(n2, t2) {
          return n2 && n2.length ? k(n2, mi(t2, 2)) : 0;
        }
        x2 = null == x2 ? re : be.defaults(re.Object(), x2, be.pick(re, qr));
        var il = x2.Array, ol = x2.Date, fl = x2.Error, cl = x2.Function, al = x2.Math, ll = x2.Object, sl = x2.RegExp, hl = x2.String, pl = x2.TypeError, _l = il.prototype, vl = cl.prototype, gl = ll.prototype, yl = x2["__core-js_shared__"], dl = vl.toString, bl = gl.hasOwnProperty, wl = 0, ml = function() {
          var n2 = /[^.]+$/.exec(yl && yl.keys && yl.keys.IE_PROTO || "");
          return n2 ? "Symbol(src)_1." + n2 : "";
        }(), xl = gl.toString, jl = dl.call(ll), Al = re._, kl = sl("^" + dl.call(bl).replace(St, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Ol = ie ? x2.Buffer : X, Il = x2.Symbol, Rl = x2.Uint8Array, zl = Ol ? Ol.allocUnsafe : X, El = F(ll.getPrototypeOf, ll), Sl = ll.create, Wl = gl.propertyIsEnumerable, Ll = _l.splice, Cl = Il ? Il.isConcatSpreadable : X, Ul = Il ? Il.iterator : X, Bl = Il ? Il.toStringTag : X, Tl = function() {
          try {
            var n2 = Ai(ll, "defineProperty");
            return n2({}, "", {}), n2;
          } catch (n3) {
          }
        }(), $l = x2.clearTimeout !== re.clearTimeout && x2.clearTimeout, Dl = ol && ol.now !== re.Date.now && ol.now, Ml = x2.setTimeout !== re.setTimeout && x2.setTimeout, Fl = al.ceil, Nl = al.floor, Pl = ll.getOwnPropertySymbols, ql = Ol ? Ol.isBuffer : X, Zl = x2.isFinite, Kl = _l.join, Vl = F(ll.keys, ll), Gl = al.max, Hl = al.min, Jl = ol.now, Yl = x2.parseInt, Ql = al.random, Xl = _l.reverse, ns = Ai(x2, "DataView"), ts = Ai(x2, "Map"), rs = Ai(x2, "Promise"), es = Ai(x2, "Set"), us = Ai(x2, "WeakMap"), is = Ai(ll, "create"), os = us && new us(), fs = {}, cs = to(ns), as = to(ts), ls = to(rs), ss = to(es), hs = to(us), ps = Il ? Il.prototype : X, _s = ps ? ps.valueOf : X, vs = ps ? ps.toString : X, gs = /* @__PURE__ */ function() {
          function n2() {
          }
          return function(t2) {
            if (!fc(t2)) return {};
            if (Sl) return Sl(t2);
            n2.prototype = t2;
            var r2 = new n2();
            return n2.prototype = X, r2;
          };
        }();
        Z2.templateSettings = { escape: kt, evaluate: Ot, interpolate: It, variable: "", imports: { _: Z2 } }, Z2.prototype = J2.prototype, Z2.prototype.constructor = Z2, Y2.prototype = gs(J2.prototype), Y2.prototype.constructor = Y2, Ct2.prototype = gs(J2.prototype), Ct2.prototype.constructor = Ct2, Xt2.prototype.clear = nr2, Xt2.prototype.delete = tr2, Xt2.prototype.get = rr2, Xt2.prototype.has = er2, Xt2.prototype.set = ur2, ir2.prototype.clear = or2, ir2.prototype.delete = fr2, ir2.prototype.get = cr2, ir2.prototype.has = ar2, ir2.prototype.set = lr2, sr2.prototype.clear = hr2, sr2.prototype.delete = pr2, sr2.prototype.get = _r2, sr2.prototype.has = vr2, sr2.prototype.set = gr2, yr2.prototype.add = yr2.prototype.push = dr2, yr2.prototype.has = br2, wr2.prototype.clear = mr2, wr2.prototype.delete = xr2, wr2.prototype.get = jr2, wr2.prototype.has = Ar2, wr2.prototype.set = kr2;
        var ys = Pu(ue2), ds = Pu(oe2, true), bs = qu(), ws = qu(true), ms2 = os ? function(n2, t2) {
          return os.set(n2, t2), n2;
        } : La, xs = Tl ? function(n2, t2) {
          return Tl(n2, "toString", {
            configurable: true,
            enumerable: false,
            value: Sa(t2),
            writable: true
          });
        } : La, js = uu, As = $l || function(n2) {
          return re.clearTimeout(n2);
        }, ks = es && 1 / P(new es([, -0]))[1] == Sn ? function(n2) {
          return new es(n2);
        } : Da, Os = os ? function(n2) {
          return os.get(n2);
        } : Da, Is = Pl ? function(n2) {
          return null == n2 ? [] : (n2 = ll(n2), i(Pl(n2), function(t2) {
            return Wl.call(n2, t2);
          }));
        } : Pa, Rs = Pl ? function(n2) {
          for (var t2 = []; n2; ) a(t2, Is(n2)), n2 = El(n2);
          return t2;
        } : Pa, zs = we;
        (ns && zs(new ns(new ArrayBuffer(1))) != ct || ts && zs(new ts()) != Gn || rs && zs(rs.resolve()) != Qn || es && zs(new es()) != tt || us && zs(new us()) != it) && (zs = function(n2) {
          var t2 = we(n2), r2 = t2 == Yn ? n2.constructor : X, e2 = r2 ? to(r2) : "";
          if (e2) switch (e2) {
            case cs:
              return ct;
            case as:
              return Gn;
            case ls:
              return Qn;
            case ss:
              return tt;
            case hs:
              return it;
          }
          return t2;
        });
        var Es = yl ? uc : qa, Ss = Qi(ms2), Ws = Ml || function(n2, t2) {
          return re.setTimeout(n2, t2);
        }, Ls = Qi(xs), Cs = Pi(function(n2) {
          var t2 = [];
          return 46 === n2.charCodeAt(0) && t2.push(""), n2.replace(Et, function(n3, r2, e2, u2) {
            t2.push(e2 ? u2.replace(Mt, "$1") : r2 || n3);
          }), t2;
        }), Us = uu(function(n2, t2) {
          return Jf(n2) ? Hr2(n2, ee2(t2, 1, Jf, true)) : [];
        }), Bs = uu(function(n2, t2) {
          var r2 = jo(t2);
          return Jf(r2) && (r2 = X), Jf(n2) ? Hr2(n2, ee2(t2, 1, Jf, true), mi(r2, 2)) : [];
        }), Ts = uu(function(n2, t2) {
          var r2 = jo(t2);
          return Jf(r2) && (r2 = X), Jf(n2) ? Hr2(n2, ee2(t2, 1, Jf, true), X, r2) : [];
        }), $s = uu(function(n2) {
          var t2 = c(n2, ju);
          return t2.length && t2[0] === n2[0] ? ke(t2) : [];
        }), Ds = uu(function(n2) {
          var t2 = jo(n2), r2 = c(n2, ju);
          return t2 === jo(r2) ? t2 = X : r2.pop(), r2.length && r2[0] === n2[0] ? ke(r2, mi(t2, 2)) : [];
        }), Ms = uu(function(n2) {
          var t2 = jo(n2), r2 = c(n2, ju);
          return t2 = "function" == typeof t2 ? t2 : X, t2 && r2.pop(), r2.length && r2[0] === n2[0] ? ke(r2, X, t2) : [];
        }), Fs = uu(Oo), Ns = gi(function(n2, t2) {
          var r2 = null == n2 ? 0 : n2.length, e2 = Tr2(n2, t2);
          return nu(n2, c(t2, function(n3) {
            return Ci(n3, r2) ? +n3 : n3;
          }).sort(Lu)), e2;
        }), Ps = uu(function(n2) {
          return gu(ee2(n2, 1, Jf, true));
        }), qs = uu(function(n2) {
          var t2 = jo(n2);
          return Jf(t2) && (t2 = X), gu(ee2(n2, 1, Jf, true), mi(t2, 2));
        }), Zs = uu(function(n2) {
          var t2 = jo(n2);
          return t2 = "function" == typeof t2 ? t2 : X, gu(ee2(n2, 1, Jf, true), X, t2);
        }), Ks = uu(function(n2, t2) {
          return Jf(n2) ? Hr2(n2, t2) : [];
        }), Vs = uu(function(n2) {
          return mu(i(n2, Jf));
        }), Gs = uu(function(n2) {
          var t2 = jo(n2);
          return Jf(t2) && (t2 = X), mu(i(n2, Jf), mi(t2, 2));
        }), Hs = uu(function(n2) {
          var t2 = jo(n2);
          return t2 = "function" == typeof t2 ? t2 : X, mu(i(n2, Jf), X, t2);
        }), Js = uu(Go), Ys = uu(function(n2) {
          var t2 = n2.length, r2 = t2 > 1 ? n2[t2 - 1] : X;
          return r2 = "function" == typeof r2 ? (n2.pop(), r2) : X, Ho(n2, r2);
        }), Qs = gi(function(n2) {
          var t2 = n2.length, r2 = t2 ? n2[0] : 0, e2 = this.__wrapped__, u2 = function(t3) {
            return Tr2(t3, n2);
          };
          return !(t2 > 1 || this.__actions__.length) && e2 instanceof Ct2 && Ci(r2) ? (e2 = e2.slice(r2, +r2 + (t2 ? 1 : 0)), e2.__actions__.push({ func: nf, args: [u2], thisArg: X }), new Y2(e2, this.__chain__).thru(function(n3) {
            return t2 && !n3.length && n3.push(X), n3;
          })) : this.thru(u2);
        }), Xs = Fu(function(n2, t2, r2) {
          bl.call(n2, r2) ? ++n2[r2] : Br2(n2, r2, 1);
        }), nh = Ju(ho), th = Ju(po), rh = Fu(function(n2, t2, r2) {
          bl.call(n2, r2) ? n2[r2].push(t2) : Br2(n2, r2, [t2]);
        }), eh = uu(function(t2, r2, e2) {
          var u2 = -1, i2 = "function" == typeof r2, o2 = Hf(t2) ? il(t2.length) : [];
          return ys(t2, function(t3) {
            o2[++u2] = i2 ? n(r2, t3, e2) : Ie(t3, r2, e2);
          }), o2;
        }), uh = Fu(function(n2, t2, r2) {
          Br2(n2, r2, t2);
        }), ih = Fu(function(n2, t2, r2) {
          n2[r2 ? 0 : 1].push(t2);
        }, function() {
          return [[], []];
        }), oh = uu(function(n2, t2) {
          if (null == n2) return [];
          var r2 = t2.length;
          return r2 > 1 && Ui(n2, t2[0], t2[1]) ? t2 = [] : r2 > 2 && Ui(t2[0], t2[1], t2[2]) && (t2 = [t2[0]]), He(n2, ee2(t2, 1), []);
        }), fh = Dl || function() {
          return re.Date.now();
        }, ch = uu(function(n2, t2, r2) {
          var e2 = _n;
          if (r2.length) {
            var u2 = N(r2, wi(ch));
            e2 |= bn;
          }
          return ai(n2, e2, t2, r2, u2);
        }), ah = uu(function(n2, t2, r2) {
          var e2 = _n | vn;
          if (r2.length) {
            var u2 = N(r2, wi(ah));
            e2 |= bn;
          }
          return ai(t2, e2, n2, r2, u2);
        }), lh = uu(function(n2, t2) {
          return Gr2(n2, 1, t2);
        }), sh = uu(function(n2, t2, r2) {
          return Gr2(n2, Ic(t2) || 0, r2);
        });
        Cf.Cache = sr2;
        var hh = js(function(t2, r2) {
          r2 = 1 == r2.length && bh(r2[0]) ? c(r2[0], z(mi())) : c(ee2(r2, 1), z(mi()));
          var e2 = r2.length;
          return uu(function(u2) {
            for (var i2 = -1, o2 = Hl(u2.length, e2); ++i2 < o2; ) u2[i2] = r2[i2].call(this, u2[i2]);
            return n(t2, this, u2);
          });
        }), ph = uu(function(n2, t2) {
          return ai(n2, bn, X, t2, N(t2, wi(ph)));
        }), _h = uu(function(n2, t2) {
          return ai(n2, wn, X, t2, N(t2, wi(_h)));
        }), vh = gi(function(n2, t2) {
          return ai(n2, xn, X, X, X, t2);
        }), gh = ii(me), yh = ii(function(n2, t2) {
          return n2 >= t2;
        }), dh = Re(/* @__PURE__ */ function() {
          return arguments;
        }()) ? Re : function(n2) {
          return cc(n2) && bl.call(n2, "callee") && !Wl.call(n2, "callee");
        }, bh = il.isArray, wh = ce ? z(ce) : ze, mh = ql || qa, xh = ae ? z(ae) : Ee, jh = le ? z(le) : Le, Ah = se ? z(se) : Be, kh = he ? z(he) : Te, Oh = pe ? z(pe) : $e, Ih = ii(Ne), Rh = ii(function(n2, t2) {
          return n2 <= t2;
        }), zh = Nu(function(n2, t2) {
          if (Mi(t2) || Hf(t2)) return $u(t2, Pc(t2), n2), X;
          for (var r2 in t2) bl.call(t2, r2) && Sr2(n2, r2, t2[r2]);
        }), Eh = Nu(function(n2, t2) {
          $u(t2, qc(t2), n2);
        }), Sh = Nu(function(n2, t2, r2, e2) {
          $u(t2, qc(t2), n2, e2);
        }), Wh = Nu(function(n2, t2, r2, e2) {
          $u(t2, Pc(t2), n2, e2);
        }), Lh = gi(Tr2), Ch = uu(function(n2, t2) {
          n2 = ll(n2);
          var r2 = -1, e2 = t2.length, u2 = e2 > 2 ? t2[2] : X;
          for (u2 && Ui(t2[0], t2[1], u2) && (e2 = 1); ++r2 < e2; ) for (var i2 = t2[r2], o2 = qc(i2), f2 = -1, c2 = o2.length; ++f2 < c2; ) {
            var a2 = o2[f2], l2 = n2[a2];
            (l2 === X || Gf(l2, gl[a2]) && !bl.call(n2, a2)) && (n2[a2] = i2[a2]);
          }
          return n2;
        }), Uh = uu(function(t2) {
          return t2.push(X, si), n(Mh, X, t2);
        }), Bh = Xu(function(n2, t2, r2) {
          null != t2 && "function" != typeof t2.toString && (t2 = xl.call(t2)), n2[t2] = r2;
        }, Sa(La)), Th = Xu(function(n2, t2, r2) {
          null != t2 && "function" != typeof t2.toString && (t2 = xl.call(t2)), bl.call(n2, t2) ? n2[t2].push(r2) : n2[t2] = [r2];
        }, mi), $h = uu(Ie), Dh = Nu(function(n2, t2, r2) {
          Ke(n2, t2, r2);
        }), Mh = Nu(function(n2, t2, r2, e2) {
          Ke(n2, t2, r2, e2);
        }), Fh = gi(function(n2, t2) {
          var r2 = {};
          if (null == n2) return r2;
          var e2 = false;
          t2 = c(t2, function(t3) {
            return t3 = ku(t3, n2), e2 || (e2 = t3.length > 1), t3;
          }), $u(n2, di(n2), r2), e2 && (r2 = Fr2(r2, an | ln | sn, hi));
          for (var u2 = t2.length; u2--; ) yu(r2, t2[u2]);
          return r2;
        }), Nh = gi(function(n2, t2) {
          return null == n2 ? {} : Je(n2, t2);
        }), Ph = ci(Pc), qh = ci(qc), Zh = Vu(function(n2, t2, r2) {
          return t2 = t2.toLowerCase(), n2 + (r2 ? fa(t2) : t2);
        }), Kh = Vu(function(n2, t2, r2) {
          return n2 + (r2 ? "-" : "") + t2.toLowerCase();
        }), Vh = Vu(function(n2, t2, r2) {
          return n2 + (r2 ? " " : "") + t2.toLowerCase();
        }), Gh = Ku("toLowerCase"), Hh = Vu(function(n2, t2, r2) {
          return n2 + (r2 ? "_" : "") + t2.toLowerCase();
        }), Jh = Vu(function(n2, t2, r2) {
          return n2 + (r2 ? " " : "") + Qh(t2);
        }), Yh = Vu(function(n2, t2, r2) {
          return n2 + (r2 ? " " : "") + t2.toUpperCase();
        }), Qh = Ku("toUpperCase"), Xh = uu(function(t2, r2) {
          try {
            return n(t2, X, r2);
          } catch (n2) {
            return rc(n2) ? n2 : new fl(n2);
          }
        }), np = gi(function(n2, t2) {
          return r(t2, function(t3) {
            t3 = no(t3), Br2(n2, t3, ch(n2[t3], n2));
          }), n2;
        }), tp = Yu(), rp = Yu(true), ep = uu(function(n2, t2) {
          return function(r2) {
            return Ie(r2, n2, t2);
          };
        }), up = uu(function(n2, t2) {
          return function(r2) {
            return Ie(n2, r2, t2);
          };
        }), ip2 = ti(c), op = ti(u), fp2 = ti(h), cp = ui(), ap = ui(true), lp = ni(function(n2, t2) {
          return n2 + t2;
        }, 0), sp = fi("ceil"), hp = ni(function(n2, t2) {
          return n2 / t2;
        }, 1), pp = fi("floor"), _p = ni(function(n2, t2) {
          return n2 * t2;
        }, 1), vp = fi("round"), gp = ni(function(n2, t2) {
          return n2 - t2;
        }, 0);
        return Z2.after = If, Z2.ary = Rf, Z2.assign = zh, Z2.assignIn = Eh, Z2.assignInWith = Sh, Z2.assignWith = Wh, Z2.at = Lh, Z2.before = zf, Z2.bind = ch, Z2.bindAll = np, Z2.bindKey = ah, Z2.castArray = Nf, Z2.chain = Qo, Z2.chunk = uo, Z2.compact = io, Z2.concat = oo, Z2.cond = za, Z2.conforms = Ea, Z2.constant = Sa, Z2.countBy = Xs, Z2.create = Sc, Z2.curry = Ef, Z2.curryRight = Sf, Z2.debounce = Wf, Z2.defaults = Ch, Z2.defaultsDeep = Uh, Z2.defer = lh, Z2.delay = sh, Z2.difference = Us, Z2.differenceBy = Bs, Z2.differenceWith = Ts, Z2.drop = fo, Z2.dropRight = co, Z2.dropRightWhile = ao, Z2.dropWhile = lo, Z2.fill = so, Z2.filter = lf, Z2.flatMap = sf, Z2.flatMapDeep = hf, Z2.flatMapDepth = pf, Z2.flatten = _o, Z2.flattenDeep = vo, Z2.flattenDepth = go, Z2.flip = Lf, Z2.flow = tp, Z2.flowRight = rp, Z2.fromPairs = yo, Z2.functions = $c, Z2.functionsIn = Dc, Z2.groupBy = rh, Z2.initial = mo, Z2.intersection = $s, Z2.intersectionBy = Ds, Z2.intersectionWith = Ms, Z2.invert = Bh, Z2.invertBy = Th, Z2.invokeMap = eh, Z2.iteratee = Ca, Z2.keyBy = uh, Z2.keys = Pc, Z2.keysIn = qc, Z2.map = yf, Z2.mapKeys = Zc, Z2.mapValues = Kc, Z2.matches = Ua, Z2.matchesProperty = Ba, Z2.memoize = Cf, Z2.merge = Dh, Z2.mergeWith = Mh, Z2.method = ep, Z2.methodOf = up, Z2.mixin = Ta, Z2.negate = Uf, Z2.nthArg = Ma, Z2.omit = Fh, Z2.omitBy = Vc, Z2.once = Bf, Z2.orderBy = df, Z2.over = ip2, Z2.overArgs = hh, Z2.overEvery = op, Z2.overSome = fp2, Z2.partial = ph, Z2.partialRight = _h, Z2.partition = ih, Z2.pick = Nh, Z2.pickBy = Gc, Z2.property = Fa, Z2.propertyOf = Na, Z2.pull = Fs, Z2.pullAll = Oo, Z2.pullAllBy = Io, Z2.pullAllWith = Ro, Z2.pullAt = Ns, Z2.range = cp, Z2.rangeRight = ap, Z2.rearg = vh, Z2.reject = mf, Z2.remove = zo, Z2.rest = Tf, Z2.reverse = Eo, Z2.sampleSize = jf, Z2.set = Jc, Z2.setWith = Yc, Z2.shuffle = Af, Z2.slice = So, Z2.sortBy = oh, Z2.sortedUniq = $o, Z2.sortedUniqBy = Do, Z2.split = da, Z2.spread = $f, Z2.tail = Mo, Z2.take = Fo, Z2.takeRight = No, Z2.takeRightWhile = Po, Z2.takeWhile = qo, Z2.tap = Xo, Z2.throttle = Df, Z2.thru = nf, Z2.toArray = jc, Z2.toPairs = Ph, Z2.toPairsIn = qh, Z2.toPath = Ha, Z2.toPlainObject = Rc, Z2.transform = Qc, Z2.unary = Mf, Z2.union = Ps, Z2.unionBy = qs, Z2.unionWith = Zs, Z2.uniq = Zo, Z2.uniqBy = Ko, Z2.uniqWith = Vo, Z2.unset = Xc, Z2.unzip = Go, Z2.unzipWith = Ho, Z2.update = na, Z2.updateWith = ta, Z2.values = ra, Z2.valuesIn = ea, Z2.without = Ks, Z2.words = Ra, Z2.wrap = Ff, Z2.xor = Vs, Z2.xorBy = Gs, Z2.xorWith = Hs, Z2.zip = Js, Z2.zipObject = Jo, Z2.zipObjectDeep = Yo, Z2.zipWith = Ys, Z2.entries = Ph, Z2.entriesIn = qh, Z2.extend = Eh, Z2.extendWith = Sh, Ta(Z2, Z2), Z2.add = lp, Z2.attempt = Xh, Z2.camelCase = Zh, Z2.capitalize = fa, Z2.ceil = sp, Z2.clamp = ua, Z2.clone = Pf, Z2.cloneDeep = Zf, Z2.cloneDeepWith = Kf, Z2.cloneWith = qf, Z2.conformsTo = Vf, Z2.deburr = ca, Z2.defaultTo = Wa, Z2.divide = hp, Z2.endsWith = aa, Z2.eq = Gf, Z2.escape = la, Z2.escapeRegExp = sa, Z2.every = af, Z2.find = nh, Z2.findIndex = ho, Z2.findKey = Wc, Z2.findLast = th, Z2.findLastIndex = po, Z2.findLastKey = Lc, Z2.floor = pp, Z2.forEach = _f, Z2.forEachRight = vf, Z2.forIn = Cc, Z2.forInRight = Uc, Z2.forOwn = Bc, Z2.forOwnRight = Tc, Z2.get = Mc, Z2.gt = gh, Z2.gte = yh, Z2.has = Fc, Z2.hasIn = Nc, Z2.head = bo, Z2.identity = La, Z2.includes = gf, Z2.indexOf = wo, Z2.inRange = ia, Z2.invoke = $h, Z2.isArguments = dh, Z2.isArray = bh, Z2.isArrayBuffer = wh, Z2.isArrayLike = Hf, Z2.isArrayLikeObject = Jf, Z2.isBoolean = Yf, Z2.isBuffer = mh, Z2.isDate = xh, Z2.isElement = Qf, Z2.isEmpty = Xf, Z2.isEqual = nc, Z2.isEqualWith = tc, Z2.isError = rc, Z2.isFinite = ec, Z2.isFunction = uc, Z2.isInteger = ic, Z2.isLength = oc, Z2.isMap = jh, Z2.isMatch = ac, Z2.isMatchWith = lc, Z2.isNaN = sc, Z2.isNative = hc, Z2.isNil = _c, Z2.isNull = pc, Z2.isNumber = vc, Z2.isObject = fc, Z2.isObjectLike = cc, Z2.isPlainObject = gc, Z2.isRegExp = Ah, Z2.isSafeInteger = yc, Z2.isSet = kh, Z2.isString = dc, Z2.isSymbol = bc, Z2.isTypedArray = Oh, Z2.isUndefined = wc, Z2.isWeakMap = mc, Z2.isWeakSet = xc, Z2.join = xo, Z2.kebabCase = Kh, Z2.last = jo, Z2.lastIndexOf = Ao, Z2.lowerCase = Vh, Z2.lowerFirst = Gh, Z2.lt = Ih, Z2.lte = Rh, Z2.max = Ya, Z2.maxBy = Qa, Z2.mean = Xa, Z2.meanBy = nl, Z2.min = tl, Z2.minBy = rl, Z2.stubArray = Pa, Z2.stubFalse = qa, Z2.stubObject = Za, Z2.stubString = Ka, Z2.stubTrue = Va, Z2.multiply = _p, Z2.nth = ko, Z2.noConflict = $a, Z2.noop = Da, Z2.now = fh, Z2.pad = ha, Z2.padEnd = pa, Z2.padStart = _a, Z2.parseInt = va, Z2.random = oa, Z2.reduce = bf, Z2.reduceRight = wf, Z2.repeat = ga, Z2.replace = ya, Z2.result = Hc, Z2.round = vp, Z2.runInContext = p2, Z2.sample = xf, Z2.size = kf, Z2.snakeCase = Hh, Z2.some = Of, Z2.sortedIndex = Wo, Z2.sortedIndexBy = Lo, Z2.sortedIndexOf = Co, Z2.sortedLastIndex = Uo, Z2.sortedLastIndexBy = Bo, Z2.sortedLastIndexOf = To, Z2.startCase = Jh, Z2.startsWith = ba, Z2.subtract = gp, Z2.sum = el, Z2.sumBy = ul, Z2.template = wa, Z2.times = Ga, Z2.toFinite = Ac, Z2.toInteger = kc, Z2.toLength = Oc, Z2.toLower = ma, Z2.toNumber = Ic, Z2.toSafeInteger = zc, Z2.toString = Ec, Z2.toUpper = xa, Z2.trim = ja, Z2.trimEnd = Aa, Z2.trimStart = ka, Z2.truncate = Oa, Z2.unescape = Ia, Z2.uniqueId = Ja, Z2.upperCase = Yh, Z2.upperFirst = Qh, Z2.each = _f, Z2.eachRight = vf, Z2.first = bo, Ta(Z2, function() {
          var n2 = {};
          return ue2(Z2, function(t2, r2) {
            bl.call(Z2.prototype, r2) || (n2[r2] = t2);
          }), n2;
        }(), { chain: false }), Z2.VERSION = nn, r(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n2) {
          Z2[n2].placeholder = Z2;
        }), r(["drop", "take"], function(n2, t2) {
          Ct2.prototype[n2] = function(r2) {
            r2 = r2 === X ? 1 : Gl(kc(r2), 0);
            var e2 = this.__filtered__ && !t2 ? new Ct2(this) : this.clone();
            return e2.__filtered__ ? e2.__takeCount__ = Hl(r2, e2.__takeCount__) : e2.__views__.push({ size: Hl(r2, Un), type: n2 + (e2.__dir__ < 0 ? "Right" : "") }), e2;
          }, Ct2.prototype[n2 + "Right"] = function(t3) {
            return this.reverse()[n2](t3).reverse();
          };
        }), r(["filter", "map", "takeWhile"], function(n2, t2) {
          var r2 = t2 + 1, e2 = r2 == Rn || r2 == En;
          Ct2.prototype[n2] = function(n3) {
            var t3 = this.clone();
            return t3.__iteratees__.push({ iteratee: mi(n3, 3), type: r2 }), t3.__filtered__ = t3.__filtered__ || e2, t3;
          };
        }), r(["head", "last"], function(n2, t2) {
          var r2 = "take" + (t2 ? "Right" : "");
          Ct2.prototype[n2] = function() {
            return this[r2](1).value()[0];
          };
        }), r(["initial", "tail"], function(n2, t2) {
          var r2 = "drop" + (t2 ? "" : "Right");
          Ct2.prototype[n2] = function() {
            return this.__filtered__ ? new Ct2(this) : this[r2](1);
          };
        }), Ct2.prototype.compact = function() {
          return this.filter(La);
        }, Ct2.prototype.find = function(n2) {
          return this.filter(n2).head();
        }, Ct2.prototype.findLast = function(n2) {
          return this.reverse().find(n2);
        }, Ct2.prototype.invokeMap = uu(function(n2, t2) {
          return "function" == typeof n2 ? new Ct2(this) : this.map(function(r2) {
            return Ie(r2, n2, t2);
          });
        }), Ct2.prototype.reject = function(n2) {
          return this.filter(Uf(mi(n2)));
        }, Ct2.prototype.slice = function(n2, t2) {
          n2 = kc(n2);
          var r2 = this;
          return r2.__filtered__ && (n2 > 0 || t2 < 0) ? new Ct2(r2) : (n2 < 0 ? r2 = r2.takeRight(-n2) : n2 && (r2 = r2.drop(n2)), t2 !== X && (t2 = kc(t2), r2 = t2 < 0 ? r2.dropRight(-t2) : r2.take(t2 - n2)), r2);
        }, Ct2.prototype.takeRightWhile = function(n2) {
          return this.reverse().takeWhile(n2).reverse();
        }, Ct2.prototype.toArray = function() {
          return this.take(Un);
        }, ue2(Ct2.prototype, function(n2, t2) {
          var r2 = /^(?:filter|find|map|reject)|While$/.test(t2), e2 = /^(?:head|last)$/.test(t2), u2 = Z2[e2 ? "take" + ("last" == t2 ? "Right" : "") : t2], i2 = e2 || /^find/.test(t2);
          u2 && (Z2.prototype[t2] = function() {
            var t3 = this.__wrapped__, o2 = e2 ? [1] : arguments, f2 = t3 instanceof Ct2, c2 = o2[0], l2 = f2 || bh(t3), s2 = function(n3) {
              var t4 = u2.apply(Z2, a([n3], o2));
              return e2 && h2 ? t4[0] : t4;
            };
            l2 && r2 && "function" == typeof c2 && 1 != c2.length && (f2 = l2 = false);
            var h2 = this.__chain__, p3 = !!this.__actions__.length, _2 = i2 && !h2, v2 = f2 && !p3;
            if (!i2 && l2) {
              t3 = v2 ? t3 : new Ct2(this);
              var g2 = n2.apply(t3, o2);
              return g2.__actions__.push({ func: nf, args: [s2], thisArg: X }), new Y2(g2, h2);
            }
            return _2 && v2 ? n2.apply(this, o2) : (g2 = this.thru(s2), _2 ? e2 ? g2.value()[0] : g2.value() : g2);
          });
        }), r(["pop", "push", "shift", "sort", "splice", "unshift"], function(n2) {
          var t2 = _l[n2], r2 = /^(?:push|sort|unshift)$/.test(n2) ? "tap" : "thru", e2 = /^(?:pop|shift)$/.test(n2);
          Z2.prototype[n2] = function() {
            var n3 = arguments;
            if (e2 && !this.__chain__) {
              var u2 = this.value();
              return t2.apply(bh(u2) ? u2 : [], n3);
            }
            return this[r2](function(r3) {
              return t2.apply(bh(r3) ? r3 : [], n3);
            });
          };
        }), ue2(Ct2.prototype, function(n2, t2) {
          var r2 = Z2[t2];
          if (r2) {
            var e2 = r2.name + "";
            bl.call(fs, e2) || (fs[e2] = []), fs[e2].push({ name: t2, func: r2 });
          }
        }), fs[Qu(X, vn).name] = [{ name: "wrapper", func: X }], Ct2.prototype.clone = $t2, Ct2.prototype.reverse = Yt2, Ct2.prototype.value = Qt2, Z2.prototype.at = Qs, Z2.prototype.chain = tf, Z2.prototype.commit = rf, Z2.prototype.next = ef, Z2.prototype.plant = of2, Z2.prototype.reverse = ff, Z2.prototype.toJSON = Z2.prototype.valueOf = Z2.prototype.value = cf, Z2.prototype.first = Z2.prototype.head, Ul && (Z2.prototype[Ul] = uf), Z2;
      }, be = de();
      ue ? ((ue.exports = be)._ = be, ee._ = be) : re._ = be;
    }).call(lodash_min);
  })(lodash_min$1, lodash_min$1.exports);
  return lodash_min$1.exports;
}
var _mapping = {};
var hasRequired_mapping;
function require_mapping() {
  if (hasRequired_mapping) return _mapping;
  hasRequired_mapping = 1;
  (function(exports2) {
    exports2.aliasToReal = {
      // Lodash aliases.
      "each": "forEach",
      "eachRight": "forEachRight",
      "entries": "toPairs",
      "entriesIn": "toPairsIn",
      "extend": "assignIn",
      "extendAll": "assignInAll",
      "extendAllWith": "assignInAllWith",
      "extendWith": "assignInWith",
      "first": "head",
      // Methods that are curried variants of others.
      "conforms": "conformsTo",
      "matches": "isMatch",
      "property": "get",
      // Ramda aliases.
      "__": "placeholder",
      "F": "stubFalse",
      "T": "stubTrue",
      "all": "every",
      "allPass": "overEvery",
      "always": "constant",
      "any": "some",
      "anyPass": "overSome",
      "apply": "spread",
      "assoc": "set",
      "assocPath": "set",
      "complement": "negate",
      "compose": "flowRight",
      "contains": "includes",
      "dissoc": "unset",
      "dissocPath": "unset",
      "dropLast": "dropRight",
      "dropLastWhile": "dropRightWhile",
      "equals": "isEqual",
      "identical": "eq",
      "indexBy": "keyBy",
      "init": "initial",
      "invertObj": "invert",
      "juxt": "over",
      "omitAll": "omit",
      "nAry": "ary",
      "path": "get",
      "pathEq": "matchesProperty",
      "pathOr": "getOr",
      "paths": "at",
      "pickAll": "pick",
      "pipe": "flow",
      "pluck": "map",
      "prop": "get",
      "propEq": "matchesProperty",
      "propOr": "getOr",
      "props": "at",
      "symmetricDifference": "xor",
      "symmetricDifferenceBy": "xorBy",
      "symmetricDifferenceWith": "xorWith",
      "takeLast": "takeRight",
      "takeLastWhile": "takeRightWhile",
      "unapply": "rest",
      "unnest": "flatten",
      "useWith": "overArgs",
      "where": "conformsTo",
      "whereEq": "isMatch",
      "zipObj": "zipObject"
    };
    exports2.aryMethod = {
      "1": [
        "assignAll",
        "assignInAll",
        "attempt",
        "castArray",
        "ceil",
        "create",
        "curry",
        "curryRight",
        "defaultsAll",
        "defaultsDeepAll",
        "floor",
        "flow",
        "flowRight",
        "fromPairs",
        "invert",
        "iteratee",
        "memoize",
        "method",
        "mergeAll",
        "methodOf",
        "mixin",
        "nthArg",
        "over",
        "overEvery",
        "overSome",
        "rest",
        "reverse",
        "round",
        "runInContext",
        "spread",
        "template",
        "trim",
        "trimEnd",
        "trimStart",
        "uniqueId",
        "words",
        "zipAll"
      ],
      "2": [
        "add",
        "after",
        "ary",
        "assign",
        "assignAllWith",
        "assignIn",
        "assignInAllWith",
        "at",
        "before",
        "bind",
        "bindAll",
        "bindKey",
        "chunk",
        "cloneDeepWith",
        "cloneWith",
        "concat",
        "conformsTo",
        "countBy",
        "curryN",
        "curryRightN",
        "debounce",
        "defaults",
        "defaultsDeep",
        "defaultTo",
        "delay",
        "difference",
        "divide",
        "drop",
        "dropRight",
        "dropRightWhile",
        "dropWhile",
        "endsWith",
        "eq",
        "every",
        "filter",
        "find",
        "findIndex",
        "findKey",
        "findLast",
        "findLastIndex",
        "findLastKey",
        "flatMap",
        "flatMapDeep",
        "flattenDepth",
        "forEach",
        "forEachRight",
        "forIn",
        "forInRight",
        "forOwn",
        "forOwnRight",
        "get",
        "groupBy",
        "gt",
        "gte",
        "has",
        "hasIn",
        "includes",
        "indexOf",
        "intersection",
        "invertBy",
        "invoke",
        "invokeMap",
        "isEqual",
        "isMatch",
        "join",
        "keyBy",
        "lastIndexOf",
        "lt",
        "lte",
        "map",
        "mapKeys",
        "mapValues",
        "matchesProperty",
        "maxBy",
        "meanBy",
        "merge",
        "mergeAllWith",
        "minBy",
        "multiply",
        "nth",
        "omit",
        "omitBy",
        "overArgs",
        "pad",
        "padEnd",
        "padStart",
        "parseInt",
        "partial",
        "partialRight",
        "partition",
        "pick",
        "pickBy",
        "propertyOf",
        "pull",
        "pullAll",
        "pullAt",
        "random",
        "range",
        "rangeRight",
        "rearg",
        "reject",
        "remove",
        "repeat",
        "restFrom",
        "result",
        "sampleSize",
        "some",
        "sortBy",
        "sortedIndex",
        "sortedIndexOf",
        "sortedLastIndex",
        "sortedLastIndexOf",
        "sortedUniqBy",
        "split",
        "spreadFrom",
        "startsWith",
        "subtract",
        "sumBy",
        "take",
        "takeRight",
        "takeRightWhile",
        "takeWhile",
        "tap",
        "throttle",
        "thru",
        "times",
        "trimChars",
        "trimCharsEnd",
        "trimCharsStart",
        "truncate",
        "union",
        "uniqBy",
        "uniqWith",
        "unset",
        "unzipWith",
        "without",
        "wrap",
        "xor",
        "zip",
        "zipObject",
        "zipObjectDeep"
      ],
      "3": [
        "assignInWith",
        "assignWith",
        "clamp",
        "differenceBy",
        "differenceWith",
        "findFrom",
        "findIndexFrom",
        "findLastFrom",
        "findLastIndexFrom",
        "getOr",
        "includesFrom",
        "indexOfFrom",
        "inRange",
        "intersectionBy",
        "intersectionWith",
        "invokeArgs",
        "invokeArgsMap",
        "isEqualWith",
        "isMatchWith",
        "flatMapDepth",
        "lastIndexOfFrom",
        "mergeWith",
        "orderBy",
        "padChars",
        "padCharsEnd",
        "padCharsStart",
        "pullAllBy",
        "pullAllWith",
        "rangeStep",
        "rangeStepRight",
        "reduce",
        "reduceRight",
        "replace",
        "set",
        "slice",
        "sortedIndexBy",
        "sortedLastIndexBy",
        "transform",
        "unionBy",
        "unionWith",
        "update",
        "xorBy",
        "xorWith",
        "zipWith"
      ],
      "4": [
        "fill",
        "setWith",
        "updateWith"
      ]
    };
    exports2.aryRearg = {
      "2": [1, 0],
      "3": [2, 0, 1],
      "4": [3, 2, 0, 1]
    };
    exports2.iterateeAry = {
      "dropRightWhile": 1,
      "dropWhile": 1,
      "every": 1,
      "filter": 1,
      "find": 1,
      "findFrom": 1,
      "findIndex": 1,
      "findIndexFrom": 1,
      "findKey": 1,
      "findLast": 1,
      "findLastFrom": 1,
      "findLastIndex": 1,
      "findLastIndexFrom": 1,
      "findLastKey": 1,
      "flatMap": 1,
      "flatMapDeep": 1,
      "flatMapDepth": 1,
      "forEach": 1,
      "forEachRight": 1,
      "forIn": 1,
      "forInRight": 1,
      "forOwn": 1,
      "forOwnRight": 1,
      "map": 1,
      "mapKeys": 1,
      "mapValues": 1,
      "partition": 1,
      "reduce": 2,
      "reduceRight": 2,
      "reject": 1,
      "remove": 1,
      "some": 1,
      "takeRightWhile": 1,
      "takeWhile": 1,
      "times": 1,
      "transform": 2
    };
    exports2.iterateeRearg = {
      "mapKeys": [1],
      "reduceRight": [1, 0]
    };
    exports2.methodRearg = {
      "assignInAllWith": [1, 0],
      "assignInWith": [1, 2, 0],
      "assignAllWith": [1, 0],
      "assignWith": [1, 2, 0],
      "differenceBy": [1, 2, 0],
      "differenceWith": [1, 2, 0],
      "getOr": [2, 1, 0],
      "intersectionBy": [1, 2, 0],
      "intersectionWith": [1, 2, 0],
      "isEqualWith": [1, 2, 0],
      "isMatchWith": [2, 1, 0],
      "mergeAllWith": [1, 0],
      "mergeWith": [1, 2, 0],
      "padChars": [2, 1, 0],
      "padCharsEnd": [2, 1, 0],
      "padCharsStart": [2, 1, 0],
      "pullAllBy": [2, 1, 0],
      "pullAllWith": [2, 1, 0],
      "rangeStep": [1, 2, 0],
      "rangeStepRight": [1, 2, 0],
      "setWith": [3, 1, 2, 0],
      "sortedIndexBy": [2, 1, 0],
      "sortedLastIndexBy": [2, 1, 0],
      "unionBy": [1, 2, 0],
      "unionWith": [1, 2, 0],
      "updateWith": [3, 1, 2, 0],
      "xorBy": [1, 2, 0],
      "xorWith": [1, 2, 0],
      "zipWith": [1, 2, 0]
    };
    exports2.methodSpread = {
      "assignAll": { "start": 0 },
      "assignAllWith": { "start": 0 },
      "assignInAll": { "start": 0 },
      "assignInAllWith": { "start": 0 },
      "defaultsAll": { "start": 0 },
      "defaultsDeepAll": { "start": 0 },
      "invokeArgs": { "start": 2 },
      "invokeArgsMap": { "start": 2 },
      "mergeAll": { "start": 0 },
      "mergeAllWith": { "start": 0 },
      "partial": { "start": 1 },
      "partialRight": { "start": 1 },
      "without": { "start": 1 },
      "zipAll": { "start": 0 }
    };
    exports2.mutate = {
      "array": {
        "fill": true,
        "pull": true,
        "pullAll": true,
        "pullAllBy": true,
        "pullAllWith": true,
        "pullAt": true,
        "remove": true,
        "reverse": true
      },
      "object": {
        "assign": true,
        "assignAll": true,
        "assignAllWith": true,
        "assignIn": true,
        "assignInAll": true,
        "assignInAllWith": true,
        "assignInWith": true,
        "assignWith": true,
        "defaults": true,
        "defaultsAll": true,
        "defaultsDeep": true,
        "defaultsDeepAll": true,
        "merge": true,
        "mergeAll": true,
        "mergeAllWith": true,
        "mergeWith": true
      },
      "set": {
        "set": true,
        "setWith": true,
        "unset": true,
        "update": true,
        "updateWith": true
      }
    };
    exports2.realToAlias = function() {
      var hasOwnProperty = Object.prototype.hasOwnProperty, object2 = exports2.aliasToReal, result = {};
      for (var key in object2) {
        var value = object2[key];
        if (hasOwnProperty.call(result, value)) {
          result[value].push(key);
        } else {
          result[value] = [key];
        }
      }
      return result;
    }();
    exports2.remap = {
      "assignAll": "assign",
      "assignAllWith": "assignWith",
      "assignInAll": "assignIn",
      "assignInAllWith": "assignInWith",
      "curryN": "curry",
      "curryRightN": "curryRight",
      "defaultsAll": "defaults",
      "defaultsDeepAll": "defaultsDeep",
      "findFrom": "find",
      "findIndexFrom": "findIndex",
      "findLastFrom": "findLast",
      "findLastIndexFrom": "findLastIndex",
      "getOr": "get",
      "includesFrom": "includes",
      "indexOfFrom": "indexOf",
      "invokeArgs": "invoke",
      "invokeArgsMap": "invokeMap",
      "lastIndexOfFrom": "lastIndexOf",
      "mergeAll": "merge",
      "mergeAllWith": "mergeWith",
      "padChars": "pad",
      "padCharsEnd": "padEnd",
      "padCharsStart": "padStart",
      "propertyOf": "get",
      "rangeStep": "range",
      "rangeStepRight": "rangeRight",
      "restFrom": "rest",
      "spreadFrom": "spread",
      "trimChars": "trim",
      "trimCharsEnd": "trimEnd",
      "trimCharsStart": "trimStart",
      "zipAll": "zip"
    };
    exports2.skipFixed = {
      "castArray": true,
      "flow": true,
      "flowRight": true,
      "iteratee": true,
      "mixin": true,
      "rearg": true,
      "runInContext": true
    };
    exports2.skipRearg = {
      "add": true,
      "assign": true,
      "assignIn": true,
      "bind": true,
      "bindKey": true,
      "concat": true,
      "difference": true,
      "divide": true,
      "eq": true,
      "gt": true,
      "gte": true,
      "isEqual": true,
      "lt": true,
      "lte": true,
      "matchesProperty": true,
      "merge": true,
      "multiply": true,
      "overArgs": true,
      "partial": true,
      "partialRight": true,
      "propertyOf": true,
      "random": true,
      "range": true,
      "rangeRight": true,
      "subtract": true,
      "zip": true,
      "zipObject": true,
      "zipObjectDeep": true
    };
  })(_mapping);
  return _mapping;
}
var placeholder;
var hasRequiredPlaceholder;
function requirePlaceholder() {
  if (hasRequiredPlaceholder) return placeholder;
  hasRequiredPlaceholder = 1;
  placeholder = {};
  return placeholder;
}
var _baseConvert;
var hasRequired_baseConvert;
function require_baseConvert() {
  if (hasRequired_baseConvert) return _baseConvert;
  hasRequired_baseConvert = 1;
  var mapping = require_mapping(), fallbackHolder = requirePlaceholder();
  var push = Array.prototype.push;
  function baseArity(func, n) {
    return n == 2 ? function(a, b) {
      return func.apply(void 0, arguments);
    } : function(a) {
      return func.apply(void 0, arguments);
    };
  }
  function baseAry(func, n) {
    return n == 2 ? function(a, b) {
      return func(a, b);
    } : function(a) {
      return func(a);
    };
  }
  function cloneArray(array2) {
    var length = array2 ? array2.length : 0, result = Array(length);
    while (length--) {
      result[length] = array2[length];
    }
    return result;
  }
  function createCloner(func) {
    return function(object2) {
      return func({}, object2);
    };
  }
  function flatSpread(func, start) {
    return function() {
      var length = arguments.length, lastIndex = length - 1, args2 = Array(length);
      while (length--) {
        args2[length] = arguments[length];
      }
      var array2 = args2[start], otherArgs = args2.slice(0, start);
      if (array2) {
        push.apply(otherArgs, array2);
      }
      if (start != lastIndex) {
        push.apply(otherArgs, args2.slice(start + 1));
      }
      return func.apply(this, otherArgs);
    };
  }
  function wrapImmutable(func, cloner) {
    return function() {
      var length = arguments.length;
      if (!length) {
        return;
      }
      var args2 = Array(length);
      while (length--) {
        args2[length] = arguments[length];
      }
      var result = args2[0] = cloner.apply(void 0, args2);
      func.apply(void 0, args2);
      return result;
    };
  }
  function baseConvert(util, name, func, options) {
    var isLib = typeof name == "function", isObj = name === Object(name);
    if (isObj) {
      options = func;
      func = name;
      name = void 0;
    }
    if (func == null) {
      throw new TypeError();
    }
    options || (options = {});
    var config2 = {
      "cap": "cap" in options ? options.cap : true,
      "curry": "curry" in options ? options.curry : true,
      "fixed": "fixed" in options ? options.fixed : true,
      "immutable": "immutable" in options ? options.immutable : true,
      "rearg": "rearg" in options ? options.rearg : true
    };
    var defaultHolder = isLib ? func : fallbackHolder, forceCurry = "curry" in options && options.curry, forceFixed = "fixed" in options && options.fixed, forceRearg = "rearg" in options && options.rearg, pristine = isLib ? func.runInContext() : void 0;
    var helpers = isLib ? func : {
      "ary": util.ary,
      "assign": util.assign,
      "clone": util.clone,
      "curry": util.curry,
      "forEach": util.forEach,
      "isArray": util.isArray,
      "isError": util.isError,
      "isFunction": util.isFunction,
      "isWeakMap": util.isWeakMap,
      "iteratee": util.iteratee,
      "keys": util.keys,
      "rearg": util.rearg,
      "toInteger": util.toInteger,
      "toPath": util.toPath
    };
    var ary = helpers.ary, assign = helpers.assign, clone2 = helpers.clone, curry = helpers.curry, each = helpers.forEach, isArray = helpers.isArray, isError = helpers.isError, isFunction2 = helpers.isFunction, isWeakMap = helpers.isWeakMap, keys2 = helpers.keys, rearg = helpers.rearg, toInteger = helpers.toInteger, toPath = helpers.toPath;
    var aryMethodKeys = keys2(mapping.aryMethod);
    var wrappers = {
      "castArray": function(castArray) {
        return function() {
          var value = arguments[0];
          return isArray(value) ? castArray(cloneArray(value)) : castArray.apply(void 0, arguments);
        };
      },
      "iteratee": function(iteratee) {
        return function() {
          var func2 = arguments[0], arity = arguments[1], result = iteratee(func2, arity), length = result.length;
          if (config2.cap && typeof arity == "number") {
            arity = arity > 2 ? arity - 2 : 1;
            return length && length <= arity ? result : baseAry(result, arity);
          }
          return result;
        };
      },
      "mixin": function(mixin) {
        return function(source) {
          var func2 = this;
          if (!isFunction2(func2)) {
            return mixin(func2, Object(source));
          }
          var pairs3 = [];
          each(keys2(source), function(key) {
            if (isFunction2(source[key])) {
              pairs3.push([key, func2.prototype[key]]);
            }
          });
          mixin(func2, Object(source));
          each(pairs3, function(pair) {
            var value = pair[1];
            if (isFunction2(value)) {
              func2.prototype[pair[0]] = value;
            } else {
              delete func2.prototype[pair[0]];
            }
          });
          return func2;
        };
      },
      "nthArg": function(nthArg) {
        return function(n) {
          var arity = n < 0 ? 1 : toInteger(n) + 1;
          return curry(nthArg(n), arity);
        };
      },
      "rearg": function(rearg2) {
        return function(func2, indexes) {
          var arity = indexes ? indexes.length : 0;
          return curry(rearg2(func2, indexes), arity);
        };
      },
      "runInContext": function(runInContext) {
        return function(context) {
          return baseConvert(util, runInContext(context), options);
        };
      }
    };
    function castCap(name2, func2) {
      if (config2.cap) {
        var indexes = mapping.iterateeRearg[name2];
        if (indexes) {
          return iterateeRearg(func2, indexes);
        }
        var n = !isLib && mapping.iterateeAry[name2];
        if (n) {
          return iterateeAry(func2, n);
        }
      }
      return func2;
    }
    function castCurry(name2, func2, n) {
      return forceCurry || config2.curry && n > 1 ? curry(func2, n) : func2;
    }
    function castFixed(name2, func2, n) {
      if (config2.fixed && (forceFixed || !mapping.skipFixed[name2])) {
        var data = mapping.methodSpread[name2], start = data && data.start;
        return start === void 0 ? ary(func2, n) : flatSpread(func2, start);
      }
      return func2;
    }
    function castRearg(name2, func2, n) {
      return config2.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name2]) ? rearg(func2, mapping.methodRearg[name2] || mapping.aryRearg[n]) : func2;
    }
    function cloneByPath(object2, path) {
      path = toPath(path);
      var index = -1, length = path.length, lastIndex = length - 1, result = clone2(Object(object2)), nested = result;
      while (nested != null && ++index < length) {
        var key = path[index], value = nested[key];
        if (value != null && !(isFunction2(value) || isError(value) || isWeakMap(value))) {
          nested[key] = clone2(index == lastIndex ? value : Object(value));
        }
        nested = nested[key];
      }
      return result;
    }
    function convertLib(options2) {
      return _.runInContext.convert(options2)(void 0);
    }
    function createConverter(name2, func2) {
      var realName = mapping.aliasToReal[name2] || name2, methodName = mapping.remap[realName] || realName, oldOptions = options;
      return function(options2) {
        var newUtil = isLib ? pristine : helpers, newFunc = isLib ? pristine[methodName] : func2, newOptions = assign(assign({}, oldOptions), options2);
        return baseConvert(newUtil, realName, newFunc, newOptions);
      };
    }
    function iterateeAry(func2, n) {
      return overArg(func2, function(func3) {
        return typeof func3 == "function" ? baseAry(func3, n) : func3;
      });
    }
    function iterateeRearg(func2, indexes) {
      return overArg(func2, function(func3) {
        var n = indexes.length;
        return baseArity(rearg(baseAry(func3, n), indexes), n);
      });
    }
    function overArg(func2, transform) {
      return function() {
        var length = arguments.length;
        if (!length) {
          return func2();
        }
        var args2 = Array(length);
        while (length--) {
          args2[length] = arguments[length];
        }
        var index = config2.rearg ? 0 : length - 1;
        args2[index] = transform(args2[index]);
        return func2.apply(void 0, args2);
      };
    }
    function wrap(name2, func2, placeholder2) {
      var result, realName = mapping.aliasToReal[name2] || name2, wrapped = func2, wrapper = wrappers[realName];
      if (wrapper) {
        wrapped = wrapper(func2);
      } else if (config2.immutable) {
        if (mapping.mutate.array[realName]) {
          wrapped = wrapImmutable(func2, cloneArray);
        } else if (mapping.mutate.object[realName]) {
          wrapped = wrapImmutable(func2, createCloner(func2));
        } else if (mapping.mutate.set[realName]) {
          wrapped = wrapImmutable(func2, cloneByPath);
        }
      }
      each(aryMethodKeys, function(aryKey) {
        each(mapping.aryMethod[aryKey], function(otherName) {
          if (realName == otherName) {
            var data = mapping.methodSpread[realName], afterRearg = data && data.afterRearg;
            result = afterRearg ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey) : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);
            result = castCap(realName, result);
            result = castCurry(realName, result, aryKey);
            return false;
          }
        });
        return !result;
      });
      result || (result = wrapped);
      if (result == func2) {
        result = forceCurry ? curry(result, 1) : function() {
          return func2.apply(this, arguments);
        };
      }
      result.convert = createConverter(realName, func2);
      result.placeholder = func2.placeholder = placeholder2;
      return result;
    }
    if (!isObj) {
      return wrap(name, func, defaultHolder);
    }
    var _ = func;
    var pairs2 = [];
    each(aryMethodKeys, function(aryKey) {
      each(mapping.aryMethod[aryKey], function(key) {
        var func2 = _[mapping.remap[key] || key];
        if (func2) {
          pairs2.push([key, wrap(key, func2, _)]);
        }
      });
    });
    each(keys2(_), function(key) {
      var func2 = _[key];
      if (typeof func2 == "function") {
        var length = pairs2.length;
        while (length--) {
          if (pairs2[length][0] == key) {
            return;
          }
        }
        func2.convert = createConverter(key, func2);
        pairs2.push([key, func2]);
      }
    });
    each(pairs2, function(pair) {
      _[pair[0]] = pair[1];
    });
    _.convert = convertLib;
    _.placeholder = _;
    each(keys2(_), function(key) {
      each(mapping.realToAlias[key] || [], function(alias) {
        _[alias] = _[key];
      });
    });
    return _;
  }
  _baseConvert = baseConvert;
  return _baseConvert;
}
var fp;
var hasRequiredFp;
function requireFp() {
  if (hasRequiredFp) return fp;
  hasRequiredFp = 1;
  var _ = requireLodash_min().runInContext();
  fp = require_baseConvert()(_, _);
  return fp;
}
var cjs = {};
var Observable = {};
var Subscriber = {};
var isFunction = {};
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction;
  hasRequiredIsFunction = 1;
  Object.defineProperty(isFunction, "__esModule", { value: true });
  isFunction.isFunction = void 0;
  function isFunction$1(value) {
    return typeof value === "function";
  }
  isFunction.isFunction = isFunction$1;
  return isFunction;
}
var Subscription = {};
var UnsubscriptionError = {};
var createErrorClass = {};
var hasRequiredCreateErrorClass;
function requireCreateErrorClass() {
  if (hasRequiredCreateErrorClass) return createErrorClass;
  hasRequiredCreateErrorClass = 1;
  Object.defineProperty(createErrorClass, "__esModule", { value: true });
  createErrorClass.createErrorClass = void 0;
  function createErrorClass$1(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  createErrorClass.createErrorClass = createErrorClass$1;
  return createErrorClass;
}
var hasRequiredUnsubscriptionError;
function requireUnsubscriptionError() {
  if (hasRequiredUnsubscriptionError) return UnsubscriptionError;
  hasRequiredUnsubscriptionError = 1;
  Object.defineProperty(UnsubscriptionError, "__esModule", { value: true });
  UnsubscriptionError.UnsubscriptionError = void 0;
  var createErrorClass_1 = /* @__PURE__ */ requireCreateErrorClass();
  UnsubscriptionError.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors2) {
      _super(this);
      this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors2;
    };
  });
  return UnsubscriptionError;
}
var arrRemove = {};
var hasRequiredArrRemove;
function requireArrRemove() {
  if (hasRequiredArrRemove) return arrRemove;
  hasRequiredArrRemove = 1;
  Object.defineProperty(arrRemove, "__esModule", { value: true });
  arrRemove.arrRemove = void 0;
  function arrRemove$1(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  arrRemove.arrRemove = arrRemove$1;
  return arrRemove;
}
var hasRequiredSubscription;
function requireSubscription() {
  if (hasRequiredSubscription) return Subscription;
  hasRequiredSubscription = 1;
  var __values = Subscription && Subscription.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = Subscription && Subscription.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = Subscription && Subscription.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(Subscription, "__esModule", { value: true });
  Subscription.isSubscription = Subscription.EMPTY_SUBSCRIPTION = Subscription.Subscription = void 0;
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  var UnsubscriptionError_1 = /* @__PURE__ */ requireUnsubscriptionError();
  var arrRemove_1 = /* @__PURE__ */ requireArrRemove();
  var Subscription$1 = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors2;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction_1.isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors2 = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err.errors));
                } else {
                  errors2.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        if (errors2) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors2);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove_1.arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty2 = new Subscription2();
      empty2.closed = true;
      return empty2;
    }();
    return Subscription2;
  }();
  Subscription.Subscription = Subscription$1;
  Subscription.EMPTY_SUBSCRIPTION = Subscription$1.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription$1 || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
  }
  Subscription.isSubscription = isSubscription;
  function execFinalizer(finalizer) {
    if (isFunction_1.isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  return Subscription;
}
var config = {};
var hasRequiredConfig;
function requireConfig() {
  if (hasRequiredConfig) return config;
  hasRequiredConfig = 1;
  Object.defineProperty(config, "__esModule", { value: true });
  config.config = void 0;
  config.config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
  return config;
}
var reportUnhandledError = {};
var timeoutProvider = {};
var hasRequiredTimeoutProvider;
function requireTimeoutProvider() {
  if (hasRequiredTimeoutProvider) return timeoutProvider;
  hasRequiredTimeoutProvider = 1;
  (function(exports2) {
    var __read = timeoutProvider && timeoutProvider.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = timeoutProvider && timeoutProvider.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeoutProvider = void 0;
    exports2.timeoutProvider = {
      setTimeout: function(handler, timeout2) {
        var args2 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args2[_i - 2] = arguments[_i];
        }
        var delegate = exports2.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args2)));
        }
        return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args2)));
      },
      clearTimeout: function(handle) {
        var delegate = exports2.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  })(timeoutProvider);
  return timeoutProvider;
}
var hasRequiredReportUnhandledError;
function requireReportUnhandledError() {
  if (hasRequiredReportUnhandledError) return reportUnhandledError;
  hasRequiredReportUnhandledError = 1;
  Object.defineProperty(reportUnhandledError, "__esModule", { value: true });
  reportUnhandledError.reportUnhandledError = void 0;
  var config_1 = /* @__PURE__ */ requireConfig();
  var timeoutProvider_1 = /* @__PURE__ */ requireTimeoutProvider();
  function reportUnhandledError$1(err) {
    timeoutProvider_1.timeoutProvider.setTimeout(function() {
      var onUnhandledError = config_1.config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }
  reportUnhandledError.reportUnhandledError = reportUnhandledError$1;
  return reportUnhandledError;
}
var noop = {};
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop) return noop;
  hasRequiredNoop = 1;
  Object.defineProperty(noop, "__esModule", { value: true });
  noop.noop = void 0;
  function noop$1() {
  }
  noop.noop = noop$1;
  return noop;
}
var NotificationFactories = {};
var hasRequiredNotificationFactories;
function requireNotificationFactories() {
  if (hasRequiredNotificationFactories) return NotificationFactories;
  hasRequiredNotificationFactories = 1;
  Object.defineProperty(NotificationFactories, "__esModule", { value: true });
  NotificationFactories.createNotification = NotificationFactories.nextNotification = NotificationFactories.errorNotification = NotificationFactories.COMPLETE_NOTIFICATION = void 0;
  NotificationFactories.COMPLETE_NOTIFICATION = function() {
    return createNotification("C", void 0, void 0);
  }();
  function errorNotification(error2) {
    return createNotification("E", void 0, error2);
  }
  NotificationFactories.errorNotification = errorNotification;
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  NotificationFactories.nextNotification = nextNotification;
  function createNotification(kind, value, error2) {
    return {
      kind,
      value,
      error: error2
    };
  }
  NotificationFactories.createNotification = createNotification;
  return NotificationFactories;
}
var errorContext = {};
var hasRequiredErrorContext;
function requireErrorContext() {
  if (hasRequiredErrorContext) return errorContext;
  hasRequiredErrorContext = 1;
  Object.defineProperty(errorContext, "__esModule", { value: true });
  errorContext.captureError = errorContext.errorContext = void 0;
  var config_1 = /* @__PURE__ */ requireConfig();
  var context = null;
  function errorContext$1(cb) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error2 = _a.error;
        context = null;
        if (errorThrown) {
          throw error2;
        }
      }
    } else {
      cb();
    }
  }
  errorContext.errorContext = errorContext$1;
  function captureError(err) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  }
  errorContext.captureError = captureError;
  return errorContext;
}
var hasRequiredSubscriber;
function requireSubscriber() {
  if (hasRequiredSubscriber) return Subscriber;
  hasRequiredSubscriber = 1;
  (function(exports2) {
    var __extends = Subscriber && Subscriber.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EMPTY_OBSERVER = exports2.SafeSubscriber = exports2.Subscriber = void 0;
    var isFunction_1 = /* @__PURE__ */ requireIsFunction();
    var Subscription_1 = /* @__PURE__ */ requireSubscription();
    var config_1 = /* @__PURE__ */ requireConfig();
    var reportUnhandledError_1 = /* @__PURE__ */ requireReportUnhandledError();
    var noop_1 = /* @__PURE__ */ requireNoop();
    var NotificationFactories_1 = /* @__PURE__ */ requireNotificationFactories();
    var timeoutProvider_1 = /* @__PURE__ */ requireTimeoutProvider();
    var errorContext_1 = /* @__PURE__ */ requireErrorContext();
    var Subscriber$1 = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports2.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error2, complete) {
        return new SafeSubscriber(next, error2, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports2.Subscriber = Subscriber$1;
    var _bind = Function.prototype.bind;
    function bind(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error2) {
            handleUnhandledError(error2);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error2) {
            handleUnhandledError(error2);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error2) {
            handleUnhandledError(error2);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error2, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error2 !== null && error2 !== void 0 ? error2 : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_1),
              error: observerOrNext.error && bind(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber$1);
    exports2.SafeSubscriber = SafeSubscriber;
    function handleUnhandledError(error2) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error2);
      } else {
        reportUnhandledError_1.reportUnhandledError(error2);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports2.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler,
      complete: noop_1.noop
    };
  })(Subscriber);
  return Subscriber;
}
var observable = {};
var hasRequiredObservable$1;
function requireObservable$1() {
  if (hasRequiredObservable$1) return observable;
  hasRequiredObservable$1 = 1;
  Object.defineProperty(observable, "__esModule", { value: true });
  observable.observable = void 0;
  observable.observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  return observable;
}
var pipe = {};
var identity = {};
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity) return identity;
  hasRequiredIdentity = 1;
  Object.defineProperty(identity, "__esModule", { value: true });
  identity.identity = void 0;
  function identity$1(x) {
    return x;
  }
  identity.identity = identity$1;
  return identity;
}
var hasRequiredPipe;
function requirePipe() {
  if (hasRequiredPipe) return pipe;
  hasRequiredPipe = 1;
  Object.defineProperty(pipe, "__esModule", { value: true });
  pipe.pipeFromArray = pipe.pipe = void 0;
  var identity_1 = /* @__PURE__ */ requireIdentity();
  function pipe$1() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  }
  pipe.pipe = pipe$1;
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity_1.identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  pipe.pipeFromArray = pipeFromArray;
  return pipe;
}
var hasRequiredObservable;
function requireObservable() {
  if (hasRequiredObservable) return Observable;
  hasRequiredObservable = 1;
  Object.defineProperty(Observable, "__esModule", { value: true });
  Observable.Observable = void 0;
  var Subscriber_1 = /* @__PURE__ */ requireSubscriber();
  var Subscription_1 = /* @__PURE__ */ requireSubscription();
  var observable_1 = /* @__PURE__ */ requireObservable$1();
  var pipe_1 = /* @__PURE__ */ requirePipe();
  var config_1 = /* @__PURE__ */ requireConfig();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  var errorContext_1 = /* @__PURE__ */ requireErrorContext();
  var Observable$1 = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error2, complete);
      errorContext_1.errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable_1.observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipe_1.pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  Observable.Observable = Observable$1;
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
  }
  return Observable;
}
var ConnectableObservable = {};
var refCount = {};
var lift = {};
var hasRequiredLift;
function requireLift() {
  if (hasRequiredLift) return lift;
  hasRequiredLift = 1;
  Object.defineProperty(lift, "__esModule", { value: true });
  lift.operate = lift.hasLift = void 0;
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function hasLift(source) {
    return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  lift.hasLift = hasLift;
  function operate(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  lift.operate = operate;
  return lift;
}
var OperatorSubscriber = {};
var hasRequiredOperatorSubscriber;
function requireOperatorSubscriber() {
  if (hasRequiredOperatorSubscriber) return OperatorSubscriber;
  hasRequiredOperatorSubscriber = 1;
  var __extends = OperatorSubscriber && OperatorSubscriber.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(OperatorSubscriber, "__esModule", { value: true });
  OperatorSubscriber.OperatorSubscriber = OperatorSubscriber.createOperatorSubscriber = void 0;
  var Subscriber_1 = /* @__PURE__ */ requireSubscriber();
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber$1(destination, onNext, onComplete, onError, onFinalize);
  }
  OperatorSubscriber.createOperatorSubscriber = createOperatorSubscriber;
  var OperatorSubscriber$1 = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber_1.Subscriber);
  OperatorSubscriber.OperatorSubscriber = OperatorSubscriber$1;
  return OperatorSubscriber;
}
var hasRequiredRefCount;
function requireRefCount() {
  if (hasRequiredRefCount) return refCount;
  hasRequiredRefCount = 1;
  Object.defineProperty(refCount, "__esModule", { value: true });
  refCount.refCount = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function refCount$1() {
    return lift_1.operate(function(source, subscriber) {
      var connection = null;
      source._refCount++;
      var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
        if (!source || source._refCount <= 0 || 0 < --source._refCount) {
          connection = null;
          return;
        }
        var sharedConnection = source._connection;
        var conn = connection;
        connection = null;
        if (sharedConnection && (!conn || sharedConnection === conn)) {
          sharedConnection.unsubscribe();
        }
        subscriber.unsubscribe();
      });
      source.subscribe(refCounter);
      if (!refCounter.closed) {
        connection = source.connect();
      }
    });
  }
  refCount.refCount = refCount$1;
  return refCount;
}
var hasRequiredConnectableObservable;
function requireConnectableObservable() {
  if (hasRequiredConnectableObservable) return ConnectableObservable;
  hasRequiredConnectableObservable = 1;
  var __extends = ConnectableObservable && ConnectableObservable.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(ConnectableObservable, "__esModule", { value: true });
  ConnectableObservable.ConnectableObservable = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var Subscription_1 = /* @__PURE__ */ requireSubscription();
  var refCount_1 = /* @__PURE__ */ requireRefCount();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var lift_1 = /* @__PURE__ */ requireLift();
  var ConnectableObservable$1 = function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._subject = null;
      _this._refCount = 0;
      _this._connection = null;
      if (lift_1.hasLift(source)) {
        _this.lift = source.lift;
      }
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype._teardown = function() {
      this._refCount = 0;
      var _connection = this._connection;
      this._subject = this._connection = null;
      _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
    };
    ConnectableObservable2.prototype.connect = function() {
      var _this = this;
      var connection = this._connection;
      if (!connection) {
        connection = this._connection = new Subscription_1.Subscription();
        var subject_1 = this.getSubject();
        connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
          _this._teardown();
          subject_1.complete();
        }, function(err) {
          _this._teardown();
          subject_1.error(err);
        }, function() {
          return _this._teardown();
        })));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription_1.Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount_1.refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable_1.Observable);
  ConnectableObservable.ConnectableObservable = ConnectableObservable$1;
  return ConnectableObservable;
}
var animationFrames = {};
var performanceTimestampProvider = {};
var hasRequiredPerformanceTimestampProvider;
function requirePerformanceTimestampProvider() {
  if (hasRequiredPerformanceTimestampProvider) return performanceTimestampProvider;
  hasRequiredPerformanceTimestampProvider = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.performanceTimestampProvider = void 0;
    exports2.performanceTimestampProvider = {
      now: function() {
        return (exports2.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  })(performanceTimestampProvider);
  return performanceTimestampProvider;
}
var animationFrameProvider = {};
var hasRequiredAnimationFrameProvider;
function requireAnimationFrameProvider() {
  if (hasRequiredAnimationFrameProvider) return animationFrameProvider;
  hasRequiredAnimationFrameProvider = 1;
  (function(exports2) {
    var __read = animationFrameProvider && animationFrameProvider.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = animationFrameProvider && animationFrameProvider.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrameProvider = void 0;
    var Subscription_1 = /* @__PURE__ */ requireSubscription();
    exports2.animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports2.animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp2) {
          cancel = void 0;
          callback(timestamp2);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args2)));
      },
      cancelAnimationFrame: function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args2)));
      },
      delegate: void 0
    };
  })(animationFrameProvider);
  return animationFrameProvider;
}
var hasRequiredAnimationFrames;
function requireAnimationFrames() {
  if (hasRequiredAnimationFrames) return animationFrames;
  hasRequiredAnimationFrames = 1;
  Object.defineProperty(animationFrames, "__esModule", { value: true });
  animationFrames.animationFrames = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var performanceTimestampProvider_1 = /* @__PURE__ */ requirePerformanceTimestampProvider();
  var animationFrameProvider_1 = /* @__PURE__ */ requireAnimationFrameProvider();
  function animationFrames$1(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
  }
  animationFrames.animationFrames = animationFrames$1;
  function animationFramesFactory(timestampProvider) {
    return new Observable_1.Observable(function(subscriber) {
      var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
      var start = provider.now();
      var id = 0;
      var run = function() {
        if (!subscriber.closed) {
          id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp2) {
            id = 0;
            var now = provider.now();
            subscriber.next({
              timestamp: timestampProvider ? now : timestamp2,
              elapsed: now - start
            });
            run();
          });
        }
      };
      run();
      return function() {
        if (id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        }
      };
    });
  }
  var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  return animationFrames;
}
var Subject = {};
var ObjectUnsubscribedError = {};
var hasRequiredObjectUnsubscribedError;
function requireObjectUnsubscribedError() {
  if (hasRequiredObjectUnsubscribedError) return ObjectUnsubscribedError;
  hasRequiredObjectUnsubscribedError = 1;
  Object.defineProperty(ObjectUnsubscribedError, "__esModule", { value: true });
  ObjectUnsubscribedError.ObjectUnsubscribedError = void 0;
  var createErrorClass_1 = /* @__PURE__ */ requireCreateErrorClass();
  ObjectUnsubscribedError.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
  return ObjectUnsubscribedError;
}
var hasRequiredSubject;
function requireSubject() {
  if (hasRequiredSubject) return Subject;
  hasRequiredSubject = 1;
  var __extends = Subject && Subject.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values = Subject && Subject.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(Subject, "__esModule", { value: true });
  Subject.AnonymousSubject = Subject.Subject = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var Subscription_1 = /* @__PURE__ */ requireSubscription();
  var ObjectUnsubscribedError_1 = /* @__PURE__ */ requireObjectUnsubscribedError();
  var arrRemove_1 = /* @__PURE__ */ requireArrRemove();
  var errorContext_1 = /* @__PURE__ */ requireErrorContext();
  var Subject$1 = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext_1.errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return Subscription_1.EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription_1.Subscription(function() {
        _this.currentObservers = null;
        arrRemove_1.arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable_1.Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable_1.Observable);
  Subject.Subject = Subject$1;
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject$1);
  Subject.AnonymousSubject = AnonymousSubject;
  return Subject;
}
var BehaviorSubject = {};
var hasRequiredBehaviorSubject;
function requireBehaviorSubject() {
  if (hasRequiredBehaviorSubject) return BehaviorSubject;
  hasRequiredBehaviorSubject = 1;
  var __extends = BehaviorSubject && BehaviorSubject.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(BehaviorSubject, "__esModule", { value: true });
  BehaviorSubject.BehaviorSubject = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var BehaviorSubject$1 = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject_1.Subject);
  BehaviorSubject.BehaviorSubject = BehaviorSubject$1;
  return BehaviorSubject;
}
var ReplaySubject = {};
var dateTimestampProvider = {};
var hasRequiredDateTimestampProvider;
function requireDateTimestampProvider() {
  if (hasRequiredDateTimestampProvider) return dateTimestampProvider;
  hasRequiredDateTimestampProvider = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dateTimestampProvider = void 0;
    exports2.dateTimestampProvider = {
      now: function() {
        return (exports2.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  })(dateTimestampProvider);
  return dateTimestampProvider;
}
var hasRequiredReplaySubject;
function requireReplaySubject() {
  if (hasRequiredReplaySubject) return ReplaySubject;
  hasRequiredReplaySubject = 1;
  var __extends = ReplaySubject && ReplaySubject.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(ReplaySubject, "__esModule", { value: true });
  ReplaySubject.ReplaySubject = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var dateTimestampProvider_1 = /* @__PURE__ */ requireDateTimestampProvider();
  var ReplaySubject$1 = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === void 0) {
        _bufferSize = Infinity;
      }
      if (_windowTime === void 0) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === void 0) {
        _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
      if (!isStopped) {
        _buffer.push(value);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
      var copy = _buffer.slice();
      for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last2 = 0;
        for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
          last2 = i;
        }
        last2 && _buffer.splice(0, last2 + 1);
      }
    };
    return ReplaySubject2;
  }(Subject_1.Subject);
  ReplaySubject.ReplaySubject = ReplaySubject$1;
  return ReplaySubject;
}
var AsyncSubject = {};
var hasRequiredAsyncSubject;
function requireAsyncSubject() {
  if (hasRequiredAsyncSubject) return AsyncSubject;
  hasRequiredAsyncSubject = 1;
  var __extends = AsyncSubject && AsyncSubject.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsyncSubject, "__esModule", { value: true });
  AsyncSubject.AsyncSubject = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var AsyncSubject$1 = function(_super) {
    __extends(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._value = null;
      _this._hasValue = false;
      _this._isComplete = false;
      return _this;
    }
    AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped || _isComplete) {
        _hasValue && subscriber.next(_value);
        subscriber.complete();
      }
    };
    AsyncSubject2.prototype.next = function(value) {
      if (!this.isStopped) {
        this._value = value;
        this._hasValue = true;
      }
    };
    AsyncSubject2.prototype.complete = function() {
      var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
      if (!_isComplete) {
        this._isComplete = true;
        _hasValue && _super.prototype.next.call(this, _value);
        _super.prototype.complete.call(this);
      }
    };
    return AsyncSubject2;
  }(Subject_1.Subject);
  AsyncSubject.AsyncSubject = AsyncSubject$1;
  return AsyncSubject;
}
var asap = {};
var AsapAction = {};
var AsyncAction = {};
var Action = {};
var hasRequiredAction;
function requireAction() {
  if (hasRequiredAction) return Action;
  hasRequiredAction = 1;
  var __extends = Action && Action.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(Action, "__esModule", { value: true });
  Action.Action = void 0;
  var Subscription_1 = /* @__PURE__ */ requireSubscription();
  var Action$1 = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state2, delay2) {
      return this;
    };
    return Action2;
  }(Subscription_1.Subscription);
  Action.Action = Action$1;
  return Action;
}
var intervalProvider = {};
var hasRequiredIntervalProvider;
function requireIntervalProvider() {
  if (hasRequiredIntervalProvider) return intervalProvider;
  hasRequiredIntervalProvider = 1;
  (function(exports2) {
    var __read = intervalProvider && intervalProvider.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = intervalProvider && intervalProvider.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.intervalProvider = void 0;
    exports2.intervalProvider = {
      setInterval: function(handler, timeout2) {
        var args2 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args2[_i - 2] = arguments[_i];
        }
        var delegate = exports2.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args2)));
        }
        return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args2)));
      },
      clearInterval: function(handle) {
        var delegate = exports2.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  })(intervalProvider);
  return intervalProvider;
}
var hasRequiredAsyncAction;
function requireAsyncAction() {
  if (hasRequiredAsyncAction) return AsyncAction;
  hasRequiredAsyncAction = 1;
  var __extends = AsyncAction && AsyncAction.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsyncAction, "__esModule", { value: true });
  AsyncAction.AsyncAction = void 0;
  var Action_1 = /* @__PURE__ */ requireAction();
  var intervalProvider_1 = /* @__PURE__ */ requireIntervalProvider();
  var arrRemove_1 = /* @__PURE__ */ requireArrRemove();
  var AsyncAction$1 = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state2, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state2;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && this.delay === delay2 && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider_1.intervalProvider.clearInterval(id);
      }
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state2, delay2) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error2 = this._execute(state2, delay2);
      if (error2) {
        return error2;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state2, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state2);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a = this, id = _a.id, scheduler = _a.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove_1.arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action_1.Action);
  AsyncAction.AsyncAction = AsyncAction$1;
  return AsyncAction;
}
var immediateProvider = {};
var Immediate = {};
var hasRequiredImmediate;
function requireImmediate() {
  if (hasRequiredImmediate) return Immediate;
  hasRequiredImmediate = 1;
  Object.defineProperty(Immediate, "__esModule", { value: true });
  Immediate.TestTools = Immediate.Immediate = void 0;
  var nextHandle = 1;
  var resolved;
  var activeHandles = {};
  function findAndClearHandle(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  }
  Immediate.Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      if (!resolved) {
        resolved = Promise.resolve();
      }
      resolved.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };
  Immediate.TestTools = {
    pending: function() {
      return Object.keys(activeHandles).length;
    }
  };
  return Immediate;
}
var hasRequiredImmediateProvider;
function requireImmediateProvider() {
  if (hasRequiredImmediateProvider) return immediateProvider;
  hasRequiredImmediateProvider = 1;
  (function(exports2) {
    var __read = immediateProvider && immediateProvider.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = immediateProvider && immediateProvider.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.immediateProvider = void 0;
    var Immediate_1 = /* @__PURE__ */ requireImmediate();
    var setImmediate2 = Immediate_1.Immediate.setImmediate, clearImmediate = Immediate_1.Immediate.clearImmediate;
    exports2.immediateProvider = {
      setImmediate: function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray([], __read(args2)));
      },
      clearImmediate: function(handle) {
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  })(immediateProvider);
  return immediateProvider;
}
var hasRequiredAsapAction;
function requireAsapAction() {
  if (hasRequiredAsapAction) return AsapAction;
  hasRequiredAsapAction = 1;
  var __extends = AsapAction && AsapAction.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsapAction, "__esModule", { value: true });
  AsapAction.AsapAction = void 0;
  var AsyncAction_1 = /* @__PURE__ */ requireAsyncAction();
  var immediateProvider_1 = /* @__PURE__ */ requireImmediateProvider();
  var AsapAction$1 = function(_super) {
    __extends(AsapAction2, _super);
    function AsapAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null ? delay2 > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
        immediateProvider_1.immediateProvider.clearImmediate(id);
        if (scheduler._scheduled === id) {
          scheduler._scheduled = void 0;
        }
      }
      return void 0;
    };
    return AsapAction2;
  }(AsyncAction_1.AsyncAction);
  AsapAction.AsapAction = AsapAction$1;
  return AsapAction;
}
var AsapScheduler = {};
var AsyncScheduler = {};
var Scheduler = {};
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return Scheduler;
  hasRequiredScheduler = 1;
  Object.defineProperty(Scheduler, "__esModule", { value: true });
  Scheduler.Scheduler = void 0;
  var dateTimestampProvider_1 = /* @__PURE__ */ requireDateTimestampProvider();
  var Scheduler$1 = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === void 0) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay2, state2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state2, delay2);
    };
    Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
    return Scheduler2;
  }();
  Scheduler.Scheduler = Scheduler$1;
  return Scheduler;
}
var hasRequiredAsyncScheduler;
function requireAsyncScheduler() {
  if (hasRequiredAsyncScheduler) return AsyncScheduler;
  hasRequiredAsyncScheduler = 1;
  var __extends = AsyncScheduler && AsyncScheduler.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsyncScheduler, "__esModule", { value: true });
  AsyncScheduler.AsyncScheduler = void 0;
  var Scheduler_1 = /* @__PURE__ */ requireScheduler();
  var AsyncScheduler$1 = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler_1.Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error2;
      this._active = true;
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error2) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AsyncScheduler2;
  }(Scheduler_1.Scheduler);
  AsyncScheduler.AsyncScheduler = AsyncScheduler$1;
  return AsyncScheduler;
}
var hasRequiredAsapScheduler;
function requireAsapScheduler() {
  if (hasRequiredAsapScheduler) return AsapScheduler;
  hasRequiredAsapScheduler = 1;
  var __extends = AsapScheduler && AsapScheduler.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsapScheduler, "__esModule", { value: true });
  AsapScheduler.AsapScheduler = void 0;
  var AsyncScheduler_1 = /* @__PURE__ */ requireAsyncScheduler();
  var AsapScheduler$1 = function(_super) {
    __extends(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = void 0;
      var actions = this.actions;
      var error2;
      action = action || actions.shift();
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error2) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  AsapScheduler.AsapScheduler = AsapScheduler$1;
  return AsapScheduler;
}
var hasRequiredAsap;
function requireAsap() {
  if (hasRequiredAsap) return asap;
  hasRequiredAsap = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asap = exports2.asapScheduler = void 0;
    var AsapAction_1 = /* @__PURE__ */ requireAsapAction();
    var AsapScheduler_1 = /* @__PURE__ */ requireAsapScheduler();
    exports2.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports2.asap = exports2.asapScheduler;
  })(asap);
  return asap;
}
var async = {};
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.async = exports2.asyncScheduler = void 0;
    var AsyncAction_1 = /* @__PURE__ */ requireAsyncAction();
    var AsyncScheduler_1 = /* @__PURE__ */ requireAsyncScheduler();
    exports2.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports2.async = exports2.asyncScheduler;
  })(async);
  return async;
}
var queue = {};
var QueueAction = {};
var hasRequiredQueueAction;
function requireQueueAction() {
  if (hasRequiredQueueAction) return QueueAction;
  hasRequiredQueueAction = 1;
  var __extends = QueueAction && QueueAction.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(QueueAction, "__esModule", { value: true });
  QueueAction.QueueAction = void 0;
  var AsyncAction_1 = /* @__PURE__ */ requireAsyncAction();
  var QueueAction$1 = function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 > 0) {
        return _super.prototype.schedule.call(this, state2, delay2);
      }
      this.delay = delay2;
      this.state = state2;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state2, delay2) {
      return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
      }
      scheduler.flush(this);
      return 0;
    };
    return QueueAction2;
  }(AsyncAction_1.AsyncAction);
  QueueAction.QueueAction = QueueAction$1;
  return QueueAction;
}
var QueueScheduler = {};
var hasRequiredQueueScheduler;
function requireQueueScheduler() {
  if (hasRequiredQueueScheduler) return QueueScheduler;
  hasRequiredQueueScheduler = 1;
  var __extends = QueueScheduler && QueueScheduler.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(QueueScheduler, "__esModule", { value: true });
  QueueScheduler.QueueScheduler = void 0;
  var AsyncScheduler_1 = /* @__PURE__ */ requireAsyncScheduler();
  var QueueScheduler$1 = function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  QueueScheduler.QueueScheduler = QueueScheduler$1;
  return QueueScheduler;
}
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue;
  hasRequiredQueue = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.queue = exports2.queueScheduler = void 0;
    var QueueAction_1 = /* @__PURE__ */ requireQueueAction();
    var QueueScheduler_1 = /* @__PURE__ */ requireQueueScheduler();
    exports2.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports2.queue = exports2.queueScheduler;
  })(queue);
  return queue;
}
var animationFrame = {};
var AnimationFrameAction = {};
var hasRequiredAnimationFrameAction;
function requireAnimationFrameAction() {
  if (hasRequiredAnimationFrameAction) return AnimationFrameAction;
  hasRequiredAnimationFrameAction = 1;
  var __extends = AnimationFrameAction && AnimationFrameAction.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AnimationFrameAction, "__esModule", { value: true });
  AnimationFrameAction.AnimationFrameAction = void 0;
  var AsyncAction_1 = /* @__PURE__ */ requireAsyncAction();
  var animationFrameProvider_1 = /* @__PURE__ */ requireAnimationFrameProvider();
  var AnimationFrameAction$1 = function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
        return scheduler.flush(void 0);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null ? delay2 > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
      }
      var actions = scheduler.actions;
      if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
        animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        scheduler._scheduled = void 0;
      }
      return void 0;
    };
    return AnimationFrameAction2;
  }(AsyncAction_1.AsyncAction);
  AnimationFrameAction.AnimationFrameAction = AnimationFrameAction$1;
  return AnimationFrameAction;
}
var AnimationFrameScheduler = {};
var hasRequiredAnimationFrameScheduler;
function requireAnimationFrameScheduler() {
  if (hasRequiredAnimationFrameScheduler) return AnimationFrameScheduler;
  hasRequiredAnimationFrameScheduler = 1;
  var __extends = AnimationFrameScheduler && AnimationFrameScheduler.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AnimationFrameScheduler, "__esModule", { value: true });
  AnimationFrameScheduler.AnimationFrameScheduler = void 0;
  var AsyncScheduler_1 = /* @__PURE__ */ requireAsyncScheduler();
  var AnimationFrameScheduler$1 = function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId;
      if (action) {
        flushId = action.id;
      } else {
        flushId = this._scheduled;
        this._scheduled = void 0;
      }
      var actions = this.actions;
      var error2;
      action = action || actions.shift();
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error2) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  AnimationFrameScheduler.AnimationFrameScheduler = AnimationFrameScheduler$1;
  return AnimationFrameScheduler;
}
var hasRequiredAnimationFrame;
function requireAnimationFrame() {
  if (hasRequiredAnimationFrame) return animationFrame;
  hasRequiredAnimationFrame = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrame = exports2.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = /* @__PURE__ */ requireAnimationFrameAction();
    var AnimationFrameScheduler_1 = /* @__PURE__ */ requireAnimationFrameScheduler();
    exports2.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports2.animationFrame = exports2.animationFrameScheduler;
  })(animationFrame);
  return animationFrame;
}
var VirtualTimeScheduler = {};
var hasRequiredVirtualTimeScheduler;
function requireVirtualTimeScheduler() {
  if (hasRequiredVirtualTimeScheduler) return VirtualTimeScheduler;
  hasRequiredVirtualTimeScheduler = 1;
  var __extends = VirtualTimeScheduler && VirtualTimeScheduler.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(VirtualTimeScheduler, "__esModule", { value: true });
  VirtualTimeScheduler.VirtualAction = VirtualTimeScheduler.VirtualTimeScheduler = void 0;
  var AsyncAction_1 = /* @__PURE__ */ requireAsyncAction();
  var Subscription_1 = /* @__PURE__ */ requireSubscription();
  var AsyncScheduler_1 = /* @__PURE__ */ requireAsyncScheduler();
  var VirtualTimeScheduler$1 = function(_super) {
    __extends(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
      if (schedulerActionCtor === void 0) {
        schedulerActionCtor = VirtualAction;
      }
      if (maxFrames === void 0) {
        maxFrames = Infinity;
      }
      var _this = _super.call(this, schedulerActionCtor, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
      var error2;
      var action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error2) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  VirtualTimeScheduler.VirtualTimeScheduler = VirtualTimeScheduler$1;
  var VirtualAction = function(_super) {
    __extends(VirtualAction2, _super);
    function VirtualAction2(scheduler, work, index) {
      if (index === void 0) {
        index = scheduler.index += 1;
      }
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler.index = index;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (Number.isFinite(delay2)) {
        if (!this.id) {
          return _super.prototype.schedule.call(this, state2, delay2);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state2, delay2);
      } else {
        return Subscription_1.Subscription.EMPTY;
      }
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      this.delay = scheduler.frame + delay2;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return 1;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
      return void 0;
    };
    VirtualAction2.prototype._execute = function(state2, delay2) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state2, delay2);
      }
    };
    VirtualAction2.sortActions = function(a, b) {
      if (a.delay === b.delay) {
        if (a.index === b.index) {
          return 0;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction_1.AsyncAction);
  VirtualTimeScheduler.VirtualAction = VirtualAction;
  return VirtualTimeScheduler;
}
var Notification = {};
var empty = {};
var hasRequiredEmpty;
function requireEmpty() {
  if (hasRequiredEmpty) return empty;
  hasRequiredEmpty = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.empty = exports2.EMPTY = void 0;
    var Observable_1 = /* @__PURE__ */ requireObservable();
    exports2.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty2(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports2.EMPTY;
    }
    exports2.empty = empty2;
    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  })(empty);
  return empty;
}
var of = {};
var args = {};
var isScheduler = {};
var hasRequiredIsScheduler;
function requireIsScheduler() {
  if (hasRequiredIsScheduler) return isScheduler;
  hasRequiredIsScheduler = 1;
  Object.defineProperty(isScheduler, "__esModule", { value: true });
  isScheduler.isScheduler = void 0;
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function isScheduler$1(value) {
    return value && isFunction_1.isFunction(value.schedule);
  }
  isScheduler.isScheduler = isScheduler$1;
  return isScheduler;
}
var hasRequiredArgs;
function requireArgs() {
  if (hasRequiredArgs) return args;
  hasRequiredArgs = 1;
  Object.defineProperty(args, "__esModule", { value: true });
  args.popNumber = args.popScheduler = args.popResultSelector = void 0;
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  var isScheduler_1 = /* @__PURE__ */ requireIsScheduler();
  function last2(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args2) {
    return isFunction_1.isFunction(last2(args2)) ? args2.pop() : void 0;
  }
  args.popResultSelector = popResultSelector;
  function popScheduler(args2) {
    return isScheduler_1.isScheduler(last2(args2)) ? args2.pop() : void 0;
  }
  args.popScheduler = popScheduler;
  function popNumber(args2, defaultValue) {
    return typeof last2(args2) === "number" ? args2.pop() : defaultValue;
  }
  args.popNumber = popNumber;
  return args;
}
var from = {};
var scheduled = {};
var scheduleObservable = {};
var innerFrom = {};
var isArrayLike = {};
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike;
  hasRequiredIsArrayLike = 1;
  Object.defineProperty(isArrayLike, "__esModule", { value: true });
  isArrayLike.isArrayLike = void 0;
  isArrayLike.isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };
  return isArrayLike;
}
var isPromise = {};
var hasRequiredIsPromise;
function requireIsPromise() {
  if (hasRequiredIsPromise) return isPromise;
  hasRequiredIsPromise = 1;
  Object.defineProperty(isPromise, "__esModule", { value: true });
  isPromise.isPromise = void 0;
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function isPromise$1(value) {
    return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
  }
  isPromise.isPromise = isPromise$1;
  return isPromise;
}
var isInteropObservable = {};
var hasRequiredIsInteropObservable;
function requireIsInteropObservable() {
  if (hasRequiredIsInteropObservable) return isInteropObservable;
  hasRequiredIsInteropObservable = 1;
  Object.defineProperty(isInteropObservable, "__esModule", { value: true });
  isInteropObservable.isInteropObservable = void 0;
  var observable_1 = /* @__PURE__ */ requireObservable$1();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function isInteropObservable$1(input) {
    return isFunction_1.isFunction(input[observable_1.observable]);
  }
  isInteropObservable.isInteropObservable = isInteropObservable$1;
  return isInteropObservable;
}
var isAsyncIterable = {};
var hasRequiredIsAsyncIterable;
function requireIsAsyncIterable() {
  if (hasRequiredIsAsyncIterable) return isAsyncIterable;
  hasRequiredIsAsyncIterable = 1;
  Object.defineProperty(isAsyncIterable, "__esModule", { value: true });
  isAsyncIterable.isAsyncIterable = void 0;
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function isAsyncIterable$1(obj) {
    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }
  isAsyncIterable.isAsyncIterable = isAsyncIterable$1;
  return isAsyncIterable;
}
var throwUnobservableError = {};
var hasRequiredThrowUnobservableError;
function requireThrowUnobservableError() {
  if (hasRequiredThrowUnobservableError) return throwUnobservableError;
  hasRequiredThrowUnobservableError = 1;
  Object.defineProperty(throwUnobservableError, "__esModule", { value: true });
  throwUnobservableError.createInvalidObservableTypeError = void 0;
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  throwUnobservableError.createInvalidObservableTypeError = createInvalidObservableTypeError;
  return throwUnobservableError;
}
var isIterable = {};
var iterator = {};
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator) return iterator;
  hasRequiredIterator = 1;
  Object.defineProperty(iterator, "__esModule", { value: true });
  iterator.iterator = iterator.getSymbolIterator = void 0;
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  iterator.getSymbolIterator = getSymbolIterator;
  iterator.iterator = getSymbolIterator();
  return iterator;
}
var hasRequiredIsIterable;
function requireIsIterable() {
  if (hasRequiredIsIterable) return isIterable;
  hasRequiredIsIterable = 1;
  Object.defineProperty(isIterable, "__esModule", { value: true });
  isIterable.isIterable = void 0;
  var iterator_1 = /* @__PURE__ */ requireIterator();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function isIterable$1(input) {
    return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
  }
  isIterable.isIterable = isIterable$1;
  return isIterable;
}
var isReadableStreamLike = {};
var hasRequiredIsReadableStreamLike;
function requireIsReadableStreamLike() {
  if (hasRequiredIsReadableStreamLike) return isReadableStreamLike;
  hasRequiredIsReadableStreamLike = 1;
  var __generator = isReadableStreamLike && isReadableStreamLike.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __await = isReadableStreamLike && isReadableStreamLike.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = isReadableStreamLike && isReadableStreamLike.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n]) i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(isReadableStreamLike, "__esModule", { value: true });
  isReadableStreamLike.isReadableStreamLike = isReadableStreamLike.readableStreamLikeToAsyncGenerator = void 0;
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done) return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  isReadableStreamLike.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
  function isReadableStreamLike$1(obj) {
    return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }
  isReadableStreamLike.isReadableStreamLike = isReadableStreamLike$1;
  return isReadableStreamLike;
}
var hasRequiredInnerFrom;
function requireInnerFrom() {
  if (hasRequiredInnerFrom) return innerFrom;
  hasRequiredInnerFrom = 1;
  var __awaiter = innerFrom && innerFrom.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = innerFrom && innerFrom.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __asyncValues = innerFrom && innerFrom.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __values = innerFrom && innerFrom.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(innerFrom, "__esModule", { value: true });
  innerFrom.fromReadableStreamLike = innerFrom.fromAsyncIterable = innerFrom.fromIterable = innerFrom.fromPromise = innerFrom.fromArrayLike = innerFrom.fromInteropObservable = innerFrom.innerFrom = void 0;
  var isArrayLike_1 = /* @__PURE__ */ requireIsArrayLike();
  var isPromise_1 = /* @__PURE__ */ requireIsPromise();
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var isInteropObservable_1 = /* @__PURE__ */ requireIsInteropObservable();
  var isAsyncIterable_1 = /* @__PURE__ */ requireIsAsyncIterable();
  var throwUnobservableError_1 = /* @__PURE__ */ requireThrowUnobservableError();
  var isIterable_1 = /* @__PURE__ */ requireIsIterable();
  var isReadableStreamLike_1 = /* @__PURE__ */ requireIsReadableStreamLike();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  var reportUnhandledError_1 = /* @__PURE__ */ requireReportUnhandledError();
  var observable_1 = /* @__PURE__ */ requireObservable$1();
  function innerFrom$1(input) {
    if (input instanceof Observable_1.Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise_1.isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable_1.isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  innerFrom.innerFrom = innerFrom$1;
  function fromInteropObservable(obj) {
    return new Observable_1.Observable(function(subscriber) {
      var obs = obj[observable_1.observable]();
      if (isFunction_1.isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  innerFrom.fromInteropObservable = fromInteropObservable;
  function fromArrayLike(array2) {
    return new Observable_1.Observable(function(subscriber) {
      for (var i = 0; i < array2.length && !subscriber.closed; i++) {
        subscriber.next(array2[i]);
      }
      subscriber.complete();
    });
  }
  innerFrom.fromArrayLike = fromArrayLike;
  function fromPromise(promise) {
    return new Observable_1.Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError_1.reportUnhandledError);
    });
  }
  innerFrom.fromPromise = fromPromise;
  function fromIterable(iterable) {
    return new Observable_1.Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  innerFrom.fromIterable = fromIterable;
  function fromAsyncIterable(asyncIterable) {
    return new Observable_1.Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  innerFrom.fromAsyncIterable = fromAsyncIterable;
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
  }
  innerFrom.fromReadableStreamLike = fromReadableStreamLike;
  function process2(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2) throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
  return innerFrom;
}
var observeOn = {};
var executeSchedule = {};
var hasRequiredExecuteSchedule;
function requireExecuteSchedule() {
  if (hasRequiredExecuteSchedule) return executeSchedule;
  hasRequiredExecuteSchedule = 1;
  Object.defineProperty(executeSchedule, "__esModule", { value: true });
  executeSchedule.executeSchedule = void 0;
  function executeSchedule$1(parentSubscription, scheduler, work, delay2, repeat2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (repeat2 === void 0) {
      repeat2 = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat2) {
        parentSubscription.add(this.schedule(null, delay2));
      } else {
        this.unsubscribe();
      }
    }, delay2);
    parentSubscription.add(scheduleSubscription);
    if (!repeat2) {
      return scheduleSubscription;
    }
  }
  executeSchedule.executeSchedule = executeSchedule$1;
  return executeSchedule;
}
var hasRequiredObserveOn;
function requireObserveOn() {
  if (hasRequiredObserveOn) return observeOn;
  hasRequiredObserveOn = 1;
  Object.defineProperty(observeOn, "__esModule", { value: true });
  observeOn.observeOn = void 0;
  var executeSchedule_1 = /* @__PURE__ */ requireExecuteSchedule();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function observeOn$1(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay2);
      }, function() {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay2);
      }, function(err) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay2);
      }));
    });
  }
  observeOn.observeOn = observeOn$1;
  return observeOn;
}
var subscribeOn = {};
var hasRequiredSubscribeOn;
function requireSubscribeOn() {
  if (hasRequiredSubscribeOn) return subscribeOn;
  hasRequiredSubscribeOn = 1;
  Object.defineProperty(subscribeOn, "__esModule", { value: true });
  subscribeOn.subscribeOn = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  function subscribeOn$1(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay2));
    });
  }
  subscribeOn.subscribeOn = subscribeOn$1;
  return subscribeOn;
}
var hasRequiredScheduleObservable;
function requireScheduleObservable() {
  if (hasRequiredScheduleObservable) return scheduleObservable;
  hasRequiredScheduleObservable = 1;
  Object.defineProperty(scheduleObservable, "__esModule", { value: true });
  scheduleObservable.scheduleObservable = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var observeOn_1 = /* @__PURE__ */ requireObserveOn();
  var subscribeOn_1 = /* @__PURE__ */ requireSubscribeOn();
  function scheduleObservable$1(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  }
  scheduleObservable.scheduleObservable = scheduleObservable$1;
  return scheduleObservable;
}
var schedulePromise = {};
var hasRequiredSchedulePromise;
function requireSchedulePromise() {
  if (hasRequiredSchedulePromise) return schedulePromise;
  hasRequiredSchedulePromise = 1;
  Object.defineProperty(schedulePromise, "__esModule", { value: true });
  schedulePromise.schedulePromise = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var observeOn_1 = /* @__PURE__ */ requireObserveOn();
  var subscribeOn_1 = /* @__PURE__ */ requireSubscribeOn();
  function schedulePromise$1(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  }
  schedulePromise.schedulePromise = schedulePromise$1;
  return schedulePromise;
}
var scheduleArray = {};
var hasRequiredScheduleArray;
function requireScheduleArray() {
  if (hasRequiredScheduleArray) return scheduleArray;
  hasRequiredScheduleArray = 1;
  Object.defineProperty(scheduleArray, "__esModule", { value: true });
  scheduleArray.scheduleArray = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  function scheduleArray$1(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  scheduleArray.scheduleArray = scheduleArray$1;
  return scheduleArray;
}
var scheduleIterable = {};
var hasRequiredScheduleIterable;
function requireScheduleIterable() {
  if (hasRequiredScheduleIterable) return scheduleIterable;
  hasRequiredScheduleIterable = 1;
  Object.defineProperty(scheduleIterable, "__esModule", { value: true });
  scheduleIterable.scheduleIterable = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var iterator_1 = /* @__PURE__ */ requireIterator();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  var executeSchedule_1 = /* @__PURE__ */ requireExecuteSchedule();
  function scheduleIterable$1(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var iterator2;
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        iterator2 = input[iterator_1.iterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator2.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction_1.isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
      };
    });
  }
  scheduleIterable.scheduleIterable = scheduleIterable$1;
  return scheduleIterable;
}
var scheduleAsyncIterable = {};
var hasRequiredScheduleAsyncIterable;
function requireScheduleAsyncIterable() {
  if (hasRequiredScheduleAsyncIterable) return scheduleAsyncIterable;
  hasRequiredScheduleAsyncIterable = 1;
  Object.defineProperty(scheduleAsyncIterable, "__esModule", { value: true });
  scheduleAsyncIterable.scheduleAsyncIterable = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var executeSchedule_1 = /* @__PURE__ */ requireExecuteSchedule();
  function scheduleAsyncIterable$1(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable_1.Observable(function(subscriber) {
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  scheduleAsyncIterable.scheduleAsyncIterable = scheduleAsyncIterable$1;
  return scheduleAsyncIterable;
}
var scheduleReadableStreamLike = {};
var hasRequiredScheduleReadableStreamLike;
function requireScheduleReadableStreamLike() {
  if (hasRequiredScheduleReadableStreamLike) return scheduleReadableStreamLike;
  hasRequiredScheduleReadableStreamLike = 1;
  Object.defineProperty(scheduleReadableStreamLike, "__esModule", { value: true });
  scheduleReadableStreamLike.scheduleReadableStreamLike = void 0;
  var scheduleAsyncIterable_1 = /* @__PURE__ */ requireScheduleAsyncIterable();
  var isReadableStreamLike_1 = /* @__PURE__ */ requireIsReadableStreamLike();
  function scheduleReadableStreamLike$1(input, scheduler) {
    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
  }
  scheduleReadableStreamLike.scheduleReadableStreamLike = scheduleReadableStreamLike$1;
  return scheduleReadableStreamLike;
}
var hasRequiredScheduled;
function requireScheduled() {
  if (hasRequiredScheduled) return scheduled;
  hasRequiredScheduled = 1;
  Object.defineProperty(scheduled, "__esModule", { value: true });
  scheduled.scheduled = void 0;
  var scheduleObservable_1 = /* @__PURE__ */ requireScheduleObservable();
  var schedulePromise_1 = /* @__PURE__ */ requireSchedulePromise();
  var scheduleArray_1 = /* @__PURE__ */ requireScheduleArray();
  var scheduleIterable_1 = /* @__PURE__ */ requireScheduleIterable();
  var scheduleAsyncIterable_1 = /* @__PURE__ */ requireScheduleAsyncIterable();
  var isInteropObservable_1 = /* @__PURE__ */ requireIsInteropObservable();
  var isPromise_1 = /* @__PURE__ */ requireIsPromise();
  var isArrayLike_1 = /* @__PURE__ */ requireIsArrayLike();
  var isIterable_1 = /* @__PURE__ */ requireIsIterable();
  var isAsyncIterable_1 = /* @__PURE__ */ requireIsAsyncIterable();
  var throwUnobservableError_1 = /* @__PURE__ */ requireThrowUnobservableError();
  var isReadableStreamLike_1 = /* @__PURE__ */ requireIsReadableStreamLike();
  var scheduleReadableStreamLike_1 = /* @__PURE__ */ requireScheduleReadableStreamLike();
  function scheduled$1(input, scheduler) {
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return scheduleObservable_1.scheduleObservable(input, scheduler);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return scheduleArray_1.scheduleArray(input, scheduler);
      }
      if (isPromise_1.isPromise(input)) {
        return schedulePromise_1.schedulePromise(input, scheduler);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable_1.isIterable(input)) {
        return scheduleIterable_1.scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  scheduled.scheduled = scheduled$1;
  return scheduled;
}
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom) return from;
  hasRequiredFrom = 1;
  Object.defineProperty(from, "__esModule", { value: true });
  from.from = void 0;
  var scheduled_1 = /* @__PURE__ */ requireScheduled();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function from$1(input, scheduler) {
    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
  }
  from.from = from$1;
  return from;
}
var hasRequiredOf;
function requireOf() {
  if (hasRequiredOf) return of;
  hasRequiredOf = 1;
  Object.defineProperty(of, "__esModule", { value: true });
  of.of = void 0;
  var args_1 = /* @__PURE__ */ requireArgs();
  var from_1 = /* @__PURE__ */ requireFrom();
  function of$1() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args2);
    return from_1.from(args2, scheduler);
  }
  of.of = of$1;
  return of;
}
var throwError = {};
var hasRequiredThrowError;
function requireThrowError() {
  if (hasRequiredThrowError) return throwError;
  hasRequiredThrowError = 1;
  Object.defineProperty(throwError, "__esModule", { value: true });
  throwError.throwError = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function throwError$1(errorOrErrorFactory, scheduler) {
    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
      return errorOrErrorFactory;
    };
    var init = function(subscriber) {
      return subscriber.error(errorFactory());
    };
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      return scheduler.schedule(init, 0, subscriber);
    } : init);
  }
  throwError.throwError = throwError$1;
  return throwError;
}
var hasRequiredNotification;
function requireNotification() {
  if (hasRequiredNotification) return Notification;
  hasRequiredNotification = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observeNotification = exports2.Notification = exports2.NotificationKind = void 0;
    var empty_1 = /* @__PURE__ */ requireEmpty();
    var of_1 = /* @__PURE__ */ requireOf();
    var throwError_1 = /* @__PURE__ */ requireThrowError();
    var isFunction_1 = /* @__PURE__ */ requireIsFunction();
    (function(NotificationKind) {
      NotificationKind["NEXT"] = "N";
      NotificationKind["ERROR"] = "E";
      NotificationKind["COMPLETE"] = "C";
    })(exports2.NotificationKind || (exports2.NotificationKind = {}));
    var Notification2 = function() {
      function Notification3(kind, value, error2) {
        this.kind = kind;
        this.value = value;
        this.error = error2;
        this.hasValue = kind === "N";
      }
      Notification3.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification3.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error2) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification3.prototype.accept = function(nextOrObserver, error2, complete) {
        var _a;
        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
      };
      Notification3.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
        var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error2;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification3.createNext = function(value) {
        return new Notification3("N", value);
      };
      Notification3.createError = function(err) {
        return new Notification3("E", void 0, err);
      };
      Notification3.createComplete = function() {
        return Notification3.completeNotification;
      };
      Notification3.completeNotification = new Notification3("C");
      return Notification3;
    }();
    exports2.Notification = Notification2;
    function observeNotification(notification, observer) {
      var _a, _b, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error2 = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error2) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports2.observeNotification = observeNotification;
  })(Notification);
  return Notification;
}
var isObservable = {};
var hasRequiredIsObservable;
function requireIsObservable() {
  if (hasRequiredIsObservable) return isObservable;
  hasRequiredIsObservable = 1;
  Object.defineProperty(isObservable, "__esModule", { value: true });
  isObservable.isObservable = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function isObservable$1(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
  }
  isObservable.isObservable = isObservable$1;
  return isObservable;
}
var lastValueFrom = {};
var EmptyError = {};
var hasRequiredEmptyError;
function requireEmptyError() {
  if (hasRequiredEmptyError) return EmptyError;
  hasRequiredEmptyError = 1;
  Object.defineProperty(EmptyError, "__esModule", { value: true });
  EmptyError.EmptyError = void 0;
  var createErrorClass_1 = /* @__PURE__ */ requireCreateErrorClass();
  EmptyError.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });
  return EmptyError;
}
var hasRequiredLastValueFrom;
function requireLastValueFrom() {
  if (hasRequiredLastValueFrom) return lastValueFrom;
  hasRequiredLastValueFrom = 1;
  Object.defineProperty(lastValueFrom, "__esModule", { value: true });
  lastValueFrom.lastValueFrom = void 0;
  var EmptyError_1 = /* @__PURE__ */ requireEmptyError();
  function lastValueFrom$1(source, config2) {
    var hasConfig = typeof config2 === "object";
    return new Promise(function(resolve, reject) {
      var _hasValue = false;
      var _value;
      source.subscribe({
        next: function(value) {
          _value = value;
          _hasValue = true;
        },
        error: reject,
        complete: function() {
          if (_hasValue) {
            resolve(_value);
          } else if (hasConfig) {
            resolve(config2.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError());
          }
        }
      });
    });
  }
  lastValueFrom.lastValueFrom = lastValueFrom$1;
  return lastValueFrom;
}
var firstValueFrom = {};
var hasRequiredFirstValueFrom;
function requireFirstValueFrom() {
  if (hasRequiredFirstValueFrom) return firstValueFrom;
  hasRequiredFirstValueFrom = 1;
  Object.defineProperty(firstValueFrom, "__esModule", { value: true });
  firstValueFrom.firstValueFrom = void 0;
  var EmptyError_1 = /* @__PURE__ */ requireEmptyError();
  var Subscriber_1 = /* @__PURE__ */ requireSubscriber();
  function firstValueFrom$1(source, config2) {
    var hasConfig = typeof config2 === "object";
    return new Promise(function(resolve, reject) {
      var subscriber = new Subscriber_1.SafeSubscriber({
        next: function(value) {
          resolve(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve(config2.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError());
          }
        }
      });
      source.subscribe(subscriber);
    });
  }
  firstValueFrom.firstValueFrom = firstValueFrom$1;
  return firstValueFrom;
}
var ArgumentOutOfRangeError = {};
var hasRequiredArgumentOutOfRangeError;
function requireArgumentOutOfRangeError() {
  if (hasRequiredArgumentOutOfRangeError) return ArgumentOutOfRangeError;
  hasRequiredArgumentOutOfRangeError = 1;
  Object.defineProperty(ArgumentOutOfRangeError, "__esModule", { value: true });
  ArgumentOutOfRangeError.ArgumentOutOfRangeError = void 0;
  var createErrorClass_1 = /* @__PURE__ */ requireCreateErrorClass();
  ArgumentOutOfRangeError.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
    return function ArgumentOutOfRangeErrorImpl() {
      _super(this);
      this.name = "ArgumentOutOfRangeError";
      this.message = "argument out of range";
    };
  });
  return ArgumentOutOfRangeError;
}
var NotFoundError = {};
var hasRequiredNotFoundError;
function requireNotFoundError() {
  if (hasRequiredNotFoundError) return NotFoundError;
  hasRequiredNotFoundError = 1;
  Object.defineProperty(NotFoundError, "__esModule", { value: true });
  NotFoundError.NotFoundError = void 0;
  var createErrorClass_1 = /* @__PURE__ */ requireCreateErrorClass();
  NotFoundError.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
    return function NotFoundErrorImpl(message) {
      _super(this);
      this.name = "NotFoundError";
      this.message = message;
    };
  });
  return NotFoundError;
}
var SequenceError = {};
var hasRequiredSequenceError;
function requireSequenceError() {
  if (hasRequiredSequenceError) return SequenceError;
  hasRequiredSequenceError = 1;
  Object.defineProperty(SequenceError, "__esModule", { value: true });
  SequenceError.SequenceError = void 0;
  var createErrorClass_1 = /* @__PURE__ */ requireCreateErrorClass();
  SequenceError.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
    return function SequenceErrorImpl(message) {
      _super(this);
      this.name = "SequenceError";
      this.message = message;
    };
  });
  return SequenceError;
}
var timeout = {};
var isDate = {};
var hasRequiredIsDate;
function requireIsDate() {
  if (hasRequiredIsDate) return isDate;
  hasRequiredIsDate = 1;
  Object.defineProperty(isDate, "__esModule", { value: true });
  isDate.isValidDate = void 0;
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }
  isDate.isValidDate = isValidDate;
  return isDate;
}
var hasRequiredTimeout;
function requireTimeout() {
  if (hasRequiredTimeout) return timeout;
  hasRequiredTimeout = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeout = exports2.TimeoutError = void 0;
    var async_12 = /* @__PURE__ */ requireAsync();
    var isDate_1 = /* @__PURE__ */ requireIsDate();
    var lift_1 = /* @__PURE__ */ requireLift();
    var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
    var createErrorClass_1 = /* @__PURE__ */ requireCreateErrorClass();
    var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
    var executeSchedule_1 = /* @__PURE__ */ requireExecuteSchedule();
    exports2.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
    function timeout2(config2, schedulerArg) {
      var _a = isDate_1.isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_12.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
      if (first2 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay2) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay2);
        };
        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
      });
    }
    exports2.timeout = timeout2;
    function timeoutErrorFactory(info) {
      throw new exports2.TimeoutError(info);
    }
  })(timeout);
  return timeout;
}
var bindCallback = {};
var bindCallbackInternals = {};
var mapOneOrManyArgs = {};
var map = {};
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map;
  hasRequiredMap = 1;
  Object.defineProperty(map, "__esModule", { value: true });
  map.map = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function map$1(project, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }
  map.map = map$1;
  return map;
}
var hasRequiredMapOneOrManyArgs;
function requireMapOneOrManyArgs() {
  if (hasRequiredMapOneOrManyArgs) return mapOneOrManyArgs;
  hasRequiredMapOneOrManyArgs = 1;
  var __read = mapOneOrManyArgs && mapOneOrManyArgs.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = mapOneOrManyArgs && mapOneOrManyArgs.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(mapOneOrManyArgs, "__esModule", { value: true });
  mapOneOrManyArgs.mapOneOrManyArgs = void 0;
  var map_1 = /* @__PURE__ */ requireMap();
  var isArray = Array.isArray;
  function callOrApply(fn, args2) {
    return isArray(args2) ? fn.apply(void 0, __spreadArray([], __read(args2))) : fn(args2);
  }
  function mapOneOrManyArgs$1(fn) {
    return map_1.map(function(args2) {
      return callOrApply(fn, args2);
    });
  }
  mapOneOrManyArgs.mapOneOrManyArgs = mapOneOrManyArgs$1;
  return mapOneOrManyArgs;
}
var hasRequiredBindCallbackInternals;
function requireBindCallbackInternals() {
  if (hasRequiredBindCallbackInternals) return bindCallbackInternals;
  hasRequiredBindCallbackInternals = 1;
  var __read = bindCallbackInternals && bindCallbackInternals.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = bindCallbackInternals && bindCallbackInternals.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(bindCallbackInternals, "__esModule", { value: true });
  bindCallbackInternals.bindCallbackInternals = void 0;
  var isScheduler_1 = /* @__PURE__ */ requireIsScheduler();
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var subscribeOn_1 = /* @__PURE__ */ requireSubscribeOn();
  var mapOneOrManyArgs_1 = /* @__PURE__ */ requireMapOneOrManyArgs();
  var observeOn_1 = /* @__PURE__ */ requireObserveOn();
  var AsyncSubject_1 = /* @__PURE__ */ requireAsyncSubject();
  function bindCallbackInternals$1(isNodeStyle, callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
      if (isScheduler_1.isScheduler(resultSelector)) {
        scheduler = resultSelector;
      } else {
        return function() {
          var args2 = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args2[_i] = arguments[_i];
          }
          return bindCallbackInternals$1(isNodeStyle, callbackFunc, scheduler).apply(this, args2).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        };
      }
    }
    if (scheduler) {
      return function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return bindCallbackInternals$1(isNodeStyle, callbackFunc).apply(this, args2).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      };
    }
    return function() {
      var _this = this;
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var subject = new AsyncSubject_1.AsyncSubject();
      var uninitialized = true;
      return new Observable_1.Observable(function(subscriber) {
        var subs = subject.subscribe(subscriber);
        if (uninitialized) {
          uninitialized = false;
          var isAsync_1 = false;
          var isComplete_1 = false;
          callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args2)), [
            function() {
              var results = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                results[_i2] = arguments[_i2];
              }
              if (isNodeStyle) {
                var err = results.shift();
                if (err != null) {
                  subject.error(err);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete_1 = true;
              if (isAsync_1) {
                subject.complete();
              }
            }
          ]));
          if (isComplete_1) {
            subject.complete();
          }
          isAsync_1 = true;
        }
        return subs;
      });
    };
  }
  bindCallbackInternals.bindCallbackInternals = bindCallbackInternals$1;
  return bindCallbackInternals;
}
var hasRequiredBindCallback;
function requireBindCallback() {
  if (hasRequiredBindCallback) return bindCallback;
  hasRequiredBindCallback = 1;
  Object.defineProperty(bindCallback, "__esModule", { value: true });
  bindCallback.bindCallback = void 0;
  var bindCallbackInternals_1 = /* @__PURE__ */ requireBindCallbackInternals();
  function bindCallback$1(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
  }
  bindCallback.bindCallback = bindCallback$1;
  return bindCallback;
}
var bindNodeCallback = {};
var hasRequiredBindNodeCallback;
function requireBindNodeCallback() {
  if (hasRequiredBindNodeCallback) return bindNodeCallback;
  hasRequiredBindNodeCallback = 1;
  Object.defineProperty(bindNodeCallback, "__esModule", { value: true });
  bindNodeCallback.bindNodeCallback = void 0;
  var bindCallbackInternals_1 = /* @__PURE__ */ requireBindCallbackInternals();
  function bindNodeCallback$1(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
  }
  bindNodeCallback.bindNodeCallback = bindNodeCallback$1;
  return bindNodeCallback;
}
var combineLatest$1 = {};
var argsArgArrayOrObject = {};
var hasRequiredArgsArgArrayOrObject;
function requireArgsArgArrayOrObject() {
  if (hasRequiredArgsArgArrayOrObject) return argsArgArrayOrObject;
  hasRequiredArgsArgArrayOrObject = 1;
  Object.defineProperty(argsArgArrayOrObject, "__esModule", { value: true });
  argsArgArrayOrObject.argsArgArrayOrObject = void 0;
  var isArray = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
  function argsArgArrayOrObject$1(args2) {
    if (args2.length === 1) {
      var first_1 = args2[0];
      if (isArray(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys2 = getKeys(first_1);
        return {
          args: keys2.map(function(key) {
            return first_1[key];
          }),
          keys: keys2
        };
      }
    }
    return { args: args2, keys: null };
  }
  argsArgArrayOrObject.argsArgArrayOrObject = argsArgArrayOrObject$1;
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }
  return argsArgArrayOrObject;
}
var createObject = {};
var hasRequiredCreateObject;
function requireCreateObject() {
  if (hasRequiredCreateObject) return createObject;
  hasRequiredCreateObject = 1;
  Object.defineProperty(createObject, "__esModule", { value: true });
  createObject.createObject = void 0;
  function createObject$1(keys2, values2) {
    return keys2.reduce(function(result, key, i) {
      return result[key] = values2[i], result;
    }, {});
  }
  createObject.createObject = createObject$1;
  return createObject;
}
var hasRequiredCombineLatest$1;
function requireCombineLatest$1() {
  if (hasRequiredCombineLatest$1) return combineLatest$1;
  hasRequiredCombineLatest$1 = 1;
  Object.defineProperty(combineLatest$1, "__esModule", { value: true });
  combineLatest$1.combineLatestInit = combineLatest$1.combineLatest = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var argsArgArrayOrObject_1 = /* @__PURE__ */ requireArgsArgArrayOrObject();
  var from_1 = /* @__PURE__ */ requireFrom();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  var mapOneOrManyArgs_1 = /* @__PURE__ */ requireMapOneOrManyArgs();
  var args_1 = /* @__PURE__ */ requireArgs();
  var createObject_1 = /* @__PURE__ */ requireCreateObject();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var executeSchedule_1 = /* @__PURE__ */ requireExecuteSchedule();
  function combineLatest2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args2);
    var resultSelector = args_1.popResultSelector(args2);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args2), observables = _a.args, keys2 = _a.keys;
    if (observables.length === 0) {
      return from_1.from([], scheduler);
    }
    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys2 ? function(values2) {
      return createObject_1.createObject(keys2, values2);
    } : identity_1.identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  combineLatest$1.combineLatest = combineLatest2;
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) {
      valueTransform = identity_1.identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values2 = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i2) {
          maybeSchedule(scheduler, function() {
            var source = from_1.from(observables[i2], scheduler);
            var hasFirstValue = false;
            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              values2[i2] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values2.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i = 0; i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  }
  combineLatest$1.combineLatestInit = combineLatestInit;
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule_1.executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }
  return combineLatest$1;
}
var concat$1 = {};
var concatAll = {};
var mergeAll = {};
var mergeMap = {};
var mergeInternals = {};
var hasRequiredMergeInternals;
function requireMergeInternals() {
  if (hasRequiredMergeInternals) return mergeInternals;
  hasRequiredMergeInternals = 1;
  Object.defineProperty(mergeInternals, "__esModule", { value: true });
  mergeInternals.mergeInternals = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var executeSchedule_1 = /* @__PURE__ */ requireExecuteSchedule();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function mergeInternals$1(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
    var buffer2 = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer2.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer2.push(value);
    };
    var doInnerSub = function(value) {
      expand2 && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand2) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer2.shift();
              if (innerSubScheduler) {
                executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer2.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }
  mergeInternals.mergeInternals = mergeInternals$1;
  return mergeInternals;
}
var hasRequiredMergeMap;
function requireMergeMap() {
  if (hasRequiredMergeMap) return mergeMap;
  hasRequiredMergeMap = 1;
  Object.defineProperty(mergeMap, "__esModule", { value: true });
  mergeMap.mergeMap = void 0;
  var map_1 = /* @__PURE__ */ requireMap();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var lift_1 = /* @__PURE__ */ requireLift();
  var mergeInternals_1 = /* @__PURE__ */ requireMergeInternals();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function mergeMap$1(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap$1(function(a, i) {
        return map_1.map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom_1.innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
    });
  }
  mergeMap.mergeMap = mergeMap$1;
  return mergeMap;
}
var hasRequiredMergeAll;
function requireMergeAll() {
  if (hasRequiredMergeAll) return mergeAll;
  hasRequiredMergeAll = 1;
  Object.defineProperty(mergeAll, "__esModule", { value: true });
  mergeAll.mergeAll = void 0;
  var mergeMap_1 = /* @__PURE__ */ requireMergeMap();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  function mergeAll$1(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
  }
  mergeAll.mergeAll = mergeAll$1;
  return mergeAll;
}
var hasRequiredConcatAll;
function requireConcatAll() {
  if (hasRequiredConcatAll) return concatAll;
  hasRequiredConcatAll = 1;
  Object.defineProperty(concatAll, "__esModule", { value: true });
  concatAll.concatAll = void 0;
  var mergeAll_1 = /* @__PURE__ */ requireMergeAll();
  function concatAll$1() {
    return mergeAll_1.mergeAll(1);
  }
  concatAll.concatAll = concatAll$1;
  return concatAll;
}
var hasRequiredConcat$1;
function requireConcat$1() {
  if (hasRequiredConcat$1) return concat$1;
  hasRequiredConcat$1 = 1;
  Object.defineProperty(concat$1, "__esModule", { value: true });
  concat$1.concat = void 0;
  var concatAll_1 = /* @__PURE__ */ requireConcatAll();
  var args_1 = /* @__PURE__ */ requireArgs();
  var from_1 = /* @__PURE__ */ requireFrom();
  function concat2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(from_1.from(args2, args_1.popScheduler(args2)));
  }
  concat$1.concat = concat2;
  return concat$1;
}
var connectable = {};
var defer = {};
var hasRequiredDefer;
function requireDefer() {
  if (hasRequiredDefer) return defer;
  hasRequiredDefer = 1;
  Object.defineProperty(defer, "__esModule", { value: true });
  defer.defer = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function defer$1(observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
    });
  }
  defer.defer = defer$1;
  return defer;
}
var hasRequiredConnectable;
function requireConnectable() {
  if (hasRequiredConnectable) return connectable;
  hasRequiredConnectable = 1;
  Object.defineProperty(connectable, "__esModule", { value: true });
  connectable.connectable = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var defer_12 = /* @__PURE__ */ requireDefer();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject();
    },
    resetOnDisconnect: true
  };
  function connectable$1(source, config2) {
    if (config2 === void 0) {
      config2 = DEFAULT_CONFIG;
    }
    var connection = null;
    var connector = config2.connector, _a = config2.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
    var subject = connector();
    var result = new Observable_1.Observable(function(subscriber) {
      return subject.subscribe(subscriber);
    });
    result.connect = function() {
      if (!connection || connection.closed) {
        connection = defer_12.defer(function() {
          return source;
        }).subscribe(subject);
        if (resetOnDisconnect) {
          connection.add(function() {
            return subject = connector();
          });
        }
      }
      return connection;
    };
    return result;
  }
  connectable.connectable = connectable$1;
  return connectable;
}
var forkJoin = {};
var hasRequiredForkJoin;
function requireForkJoin() {
  if (hasRequiredForkJoin) return forkJoin;
  hasRequiredForkJoin = 1;
  Object.defineProperty(forkJoin, "__esModule", { value: true });
  forkJoin.forkJoin = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var argsArgArrayOrObject_1 = /* @__PURE__ */ requireArgsArgArrayOrObject();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var args_1 = /* @__PURE__ */ requireArgs();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var mapOneOrManyArgs_1 = /* @__PURE__ */ requireMapOneOrManyArgs();
  var createObject_1 = /* @__PURE__ */ requireCreateObject();
  function forkJoin$1() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args2);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args2), sources = _a.args, keys2 = _a.keys;
    var result = new Observable_1.Observable(function(subscriber) {
      var length = sources.length;
      if (!length) {
        subscriber.complete();
        return;
      }
      var values2 = new Array(length);
      var remainingCompletions = length;
      var remainingEmissions = length;
      var _loop_1 = function(sourceIndex2) {
        var hasValue = false;
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!hasValue) {
            hasValue = true;
            remainingEmissions--;
          }
          values2[sourceIndex2] = value;
        }, function() {
          return remainingCompletions--;
        }, void 0, function() {
          if (!remainingCompletions || !hasValue) {
            if (!remainingEmissions) {
              subscriber.next(keys2 ? createObject_1.createObject(keys2, values2) : values2);
            }
            subscriber.complete();
          }
        }));
      };
      for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  forkJoin.forkJoin = forkJoin$1;
  return forkJoin;
}
var fromEvent = {};
var hasRequiredFromEvent;
function requireFromEvent() {
  if (hasRequiredFromEvent) return fromEvent;
  hasRequiredFromEvent = 1;
  var __read = fromEvent && fromEvent.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(fromEvent, "__esModule", { value: true });
  fromEvent.fromEvent = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var mergeMap_1 = /* @__PURE__ */ requireMergeMap();
  var isArrayLike_1 = /* @__PURE__ */ requireIsArrayLike();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  var mapOneOrManyArgs_1 = /* @__PURE__ */ requireMapOneOrManyArgs();
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent$1(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent$1(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
      if (isArrayLike_1.isArrayLike(target)) {
        return mergeMap_1.mergeMap(function(subTarget) {
          return fromEvent$1(subTarget, eventName, options);
        })(innerFrom_1.innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return subscriber.next(1 < args2.length ? args2 : args2[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  }
  fromEvent.fromEvent = fromEvent$1;
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
  }
  return fromEvent;
}
var fromEventPattern = {};
var hasRequiredFromEventPattern;
function requireFromEventPattern() {
  if (hasRequiredFromEventPattern) return fromEventPattern;
  hasRequiredFromEventPattern = 1;
  Object.defineProperty(fromEventPattern, "__esModule", { value: true });
  fromEventPattern.fromEventPattern = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  var mapOneOrManyArgs_1 = /* @__PURE__ */ requireMapOneOrManyArgs();
  function fromEventPattern$1(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern$1(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          e[_i] = arguments[_i];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue = addHandler(handler);
      return isFunction_1.isFunction(removeHandler) ? function() {
        return removeHandler(handler, retValue);
      } : void 0;
    });
  }
  fromEventPattern.fromEventPattern = fromEventPattern$1;
  return fromEventPattern;
}
var generate = {};
var hasRequiredGenerate;
function requireGenerate() {
  if (hasRequiredGenerate) return generate;
  hasRequiredGenerate = 1;
  var __generator = generate && generate.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(generate, "__esModule", { value: true });
  generate.generate = void 0;
  var identity_1 = /* @__PURE__ */ requireIdentity();
  var isScheduler_1 = /* @__PURE__ */ requireIsScheduler();
  var defer_12 = /* @__PURE__ */ requireDefer();
  var scheduleIterable_1 = /* @__PURE__ */ requireScheduleIterable();
  function generate$1(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
    var _a, _b;
    var resultSelector;
    var initialState;
    if (arguments.length === 1) {
      _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
    } else {
      initialState = initialStateOrOptions;
      if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrScheduler;
      } else {
        resultSelector = resultSelectorOrScheduler;
      }
    }
    function gen() {
      var state2;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            state2 = initialState;
            _a2.label = 1;
          case 1:
            if (!(!condition || condition(state2))) return [3, 4];
            return [4, resultSelector(state2)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            state2 = iterate(state2);
            return [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return defer_12.defer(scheduler ? function() {
      return scheduleIterable_1.scheduleIterable(gen(), scheduler);
    } : gen);
  }
  generate.generate = generate$1;
  return generate;
}
var iif = {};
var hasRequiredIif;
function requireIif() {
  if (hasRequiredIif) return iif;
  hasRequiredIif = 1;
  Object.defineProperty(iif, "__esModule", { value: true });
  iif.iif = void 0;
  var defer_12 = /* @__PURE__ */ requireDefer();
  function iif$1(condition, trueResult, falseResult) {
    return defer_12.defer(function() {
      return condition() ? trueResult : falseResult;
    });
  }
  iif.iif = iif$1;
  return iif;
}
var interval = {};
var timer = {};
var hasRequiredTimer;
function requireTimer() {
  if (hasRequiredTimer) return timer;
  hasRequiredTimer = 1;
  Object.defineProperty(timer, "__esModule", { value: true });
  timer.timer = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var async_12 = /* @__PURE__ */ requireAsync();
  var isScheduler_1 = /* @__PURE__ */ requireIsScheduler();
  var isDate_1 = /* @__PURE__ */ requireIsDate();
  function timer$1(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = async_12.async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler_1.isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable_1.Observable(function(subscriber) {
      var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(void 0, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }
  timer.timer = timer$1;
  return timer;
}
var hasRequiredInterval;
function requireInterval() {
  if (hasRequiredInterval) return interval;
  hasRequiredInterval = 1;
  Object.defineProperty(interval, "__esModule", { value: true });
  interval.interval = void 0;
  var async_12 = /* @__PURE__ */ requireAsync();
  var timer_1 = /* @__PURE__ */ requireTimer();
  function interval$1(period, scheduler) {
    if (period === void 0) {
      period = 0;
    }
    if (scheduler === void 0) {
      scheduler = async_12.asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer_1.timer(period, period, scheduler);
  }
  interval.interval = interval$1;
  return interval;
}
var merge$1 = {};
var hasRequiredMerge$1;
function requireMerge$1() {
  if (hasRequiredMerge$1) return merge$1;
  hasRequiredMerge$1 = 1;
  Object.defineProperty(merge$1, "__esModule", { value: true });
  merge$1.merge = void 0;
  var mergeAll_1 = /* @__PURE__ */ requireMergeAll();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var empty_1 = /* @__PURE__ */ requireEmpty();
  var args_1 = /* @__PURE__ */ requireArgs();
  var from_1 = /* @__PURE__ */ requireFrom();
  function merge2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args2);
    var concurrent = args_1.popNumber(args2, Infinity);
    var sources = args2;
    return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
  }
  merge$1.merge = merge2;
  return merge$1;
}
var never = {};
var hasRequiredNever;
function requireNever() {
  if (hasRequiredNever) return never;
  hasRequiredNever = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.never = exports2.NEVER = void 0;
    var Observable_1 = /* @__PURE__ */ requireObservable();
    var noop_1 = /* @__PURE__ */ requireNoop();
    exports2.NEVER = new Observable_1.Observable(noop_1.noop);
    function never2() {
      return exports2.NEVER;
    }
    exports2.never = never2;
  })(never);
  return never;
}
var onErrorResumeNext = {};
var argsOrArgArray = {};
var hasRequiredArgsOrArgArray;
function requireArgsOrArgArray() {
  if (hasRequiredArgsOrArgArray) return argsOrArgArray;
  hasRequiredArgsOrArgArray = 1;
  Object.defineProperty(argsOrArgArray, "__esModule", { value: true });
  argsOrArgArray.argsOrArgArray = void 0;
  var isArray = Array.isArray;
  function argsOrArgArray$1(args2) {
    return args2.length === 1 && isArray(args2[0]) ? args2[0] : args2;
  }
  argsOrArgArray.argsOrArgArray = argsOrArgArray$1;
  return argsOrArgArray;
}
var hasRequiredOnErrorResumeNext;
function requireOnErrorResumeNext() {
  if (hasRequiredOnErrorResumeNext) return onErrorResumeNext;
  hasRequiredOnErrorResumeNext = 1;
  Object.defineProperty(onErrorResumeNext, "__esModule", { value: true });
  onErrorResumeNext.onErrorResumeNext = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var argsOrArgArray_1 = /* @__PURE__ */ requireArgsOrArgArray();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function onErrorResumeNext$1() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return new Observable_1.Observable(function(subscriber) {
      var sourceIndex = 0;
      var subscribeNext = function() {
        if (sourceIndex < nextSources.length) {
          var nextSource = void 0;
          try {
            nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
          } catch (err) {
            subscribeNext();
            return;
          }
          var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
          nextSource.subscribe(innerSubscriber);
          innerSubscriber.add(subscribeNext);
        } else {
          subscriber.complete();
        }
      };
      subscribeNext();
    });
  }
  onErrorResumeNext.onErrorResumeNext = onErrorResumeNext$1;
  return onErrorResumeNext;
}
var pairs = {};
var hasRequiredPairs;
function requirePairs() {
  if (hasRequiredPairs) return pairs;
  hasRequiredPairs = 1;
  Object.defineProperty(pairs, "__esModule", { value: true });
  pairs.pairs = void 0;
  var from_1 = /* @__PURE__ */ requireFrom();
  function pairs$1(obj, scheduler) {
    return from_1.from(Object.entries(obj), scheduler);
  }
  pairs.pairs = pairs$1;
  return pairs;
}
var partition$1 = {};
var not = {};
var hasRequiredNot;
function requireNot() {
  if (hasRequiredNot) return not;
  hasRequiredNot = 1;
  Object.defineProperty(not, "__esModule", { value: true });
  not.not = void 0;
  function not$1(pred, thisArg) {
    return function(value, index) {
      return !pred.call(thisArg, value, index);
    };
  }
  not.not = not$1;
  return not;
}
var filter = {};
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter) return filter;
  hasRequiredFilter = 1;
  Object.defineProperty(filter, "__esModule", { value: true });
  filter.filter = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function filter$1(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  filter.filter = filter$1;
  return filter;
}
var hasRequiredPartition$1;
function requirePartition$1() {
  if (hasRequiredPartition$1) return partition$1;
  hasRequiredPartition$1 = 1;
  Object.defineProperty(partition$1, "__esModule", { value: true });
  partition$1.partition = void 0;
  var not_1 = /* @__PURE__ */ requireNot();
  var filter_1 = /* @__PURE__ */ requireFilter();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function partition2(source, predicate, thisArg) {
    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
  }
  partition$1.partition = partition2;
  return partition$1;
}
var race$1 = {};
var hasRequiredRace$1;
function requireRace$1() {
  if (hasRequiredRace$1) return race$1;
  hasRequiredRace$1 = 1;
  Object.defineProperty(race$1, "__esModule", { value: true });
  race$1.raceInit = race$1.race = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var argsOrArgArray_1 = /* @__PURE__ */ requireArgsOrArgArray();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function race2() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray_1.argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
  }
  race$1.race = race2;
  function raceInit(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i2) {
        subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (subscriptions) {
            for (var s = 0; s < subscriptions.length; s++) {
              s !== i2 && subscriptions[s].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value);
        })));
      };
      for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
        _loop_1(i);
      }
    };
  }
  race$1.raceInit = raceInit;
  return race$1;
}
var range = {};
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  Object.defineProperty(range, "__esModule", { value: true });
  range.range = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var empty_1 = /* @__PURE__ */ requireEmpty();
  function range$12(start, count2, scheduler) {
    if (count2 == null) {
      count2 = start;
      start = 0;
    }
    if (count2 <= 0) {
      return empty_1.EMPTY;
    }
    var end = count2 + start;
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      var n = start;
      return scheduler.schedule(function() {
        if (n < end) {
          subscriber.next(n++);
          this.schedule();
        } else {
          subscriber.complete();
        }
      });
    } : function(subscriber) {
      var n = start;
      while (n < end && !subscriber.closed) {
        subscriber.next(n++);
      }
      subscriber.complete();
    });
  }
  range.range = range$12;
  return range;
}
var using = {};
var hasRequiredUsing;
function requireUsing() {
  if (hasRequiredUsing) return using;
  hasRequiredUsing = 1;
  Object.defineProperty(using, "__esModule", { value: true });
  using.using = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var empty_1 = /* @__PURE__ */ requireEmpty();
  function using$1(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      var resource = resourceFactory();
      var result = observableFactory(resource);
      var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
      source.subscribe(subscriber);
      return function() {
        if (resource) {
          resource.unsubscribe();
        }
      };
    });
  }
  using.using = using$1;
  return using;
}
var zip$1 = {};
var hasRequiredZip$1;
function requireZip$1() {
  if (hasRequiredZip$1) return zip$1;
  hasRequiredZip$1 = 1;
  var __read = zip$1 && zip$1.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = zip$1 && zip$1.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(zip$1, "__esModule", { value: true });
  zip$1.zip = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var argsOrArgArray_1 = /* @__PURE__ */ requireArgsOrArgArray();
  var empty_1 = /* @__PURE__ */ requireEmpty();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var args_1 = /* @__PURE__ */ requireArgs();
  function zip2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args2);
    var sources = argsOrArgArray_1.argsOrArgArray(args2);
    return sources.length ? new Observable_1.Observable(function(subscriber) {
      var buffers = sources.map(function() {
        return [];
      });
      var completed = sources.map(function() {
        return false;
      });
      subscriber.add(function() {
        buffers = completed = null;
      });
      var _loop_1 = function(sourceIndex2) {
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffers[sourceIndex2].push(value);
          if (buffers.every(function(buffer2) {
            return buffer2.length;
          })) {
            var result = buffers.map(function(buffer2) {
              return buffer2.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
            if (buffers.some(function(buffer2, i) {
              return !buffer2.length && completed[i];
            })) {
              subscriber.complete();
            }
          }
        }, function() {
          completed[sourceIndex2] = true;
          !buffers[sourceIndex2].length && subscriber.complete();
        }));
      };
      for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
      return function() {
        buffers = completed = null;
      };
    }) : empty_1.EMPTY;
  }
  zip$1.zip = zip2;
  return zip$1;
}
var types = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", { value: true });
  return types;
}
var audit = {};
var hasRequiredAudit;
function requireAudit() {
  if (hasRequiredAudit) return audit;
  hasRequiredAudit = 1;
  Object.defineProperty(audit, "__esModule", { value: true });
  audit.audit = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function audit$1(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var isComplete = false;
      var endDuration = function() {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
        isComplete && subscriber.complete();
      };
      var cleanupDuration = function() {
        durationSubscriber = null;
        isComplete && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
        if (!durationSubscriber) {
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
        }
      }, function() {
        isComplete = true;
        (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
      }));
    });
  }
  audit.audit = audit$1;
  return audit;
}
var auditTime = {};
var hasRequiredAuditTime;
function requireAuditTime() {
  if (hasRequiredAuditTime) return auditTime;
  hasRequiredAuditTime = 1;
  Object.defineProperty(auditTime, "__esModule", { value: true });
  auditTime.auditTime = void 0;
  var async_12 = /* @__PURE__ */ requireAsync();
  var audit_1 = /* @__PURE__ */ requireAudit();
  var timer_1 = /* @__PURE__ */ requireTimer();
  function auditTime$1(duration, scheduler) {
    if (scheduler === void 0) {
      scheduler = async_12.asyncScheduler;
    }
    return audit_1.audit(function() {
      return timer_1.timer(duration, scheduler);
    });
  }
  auditTime.auditTime = auditTime$1;
  return auditTime;
}
var buffer = {};
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  Object.defineProperty(buffer, "__esModule", { value: true });
  buffer.buffer = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function buffer$1(closingNotifier) {
    return lift_1.operate(function(source, subscriber) {
      var currentBuffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return currentBuffer.push(value);
      }, function() {
        subscriber.next(currentBuffer);
        subscriber.complete();
      }));
      innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        var b = currentBuffer;
        currentBuffer = [];
        subscriber.next(b);
      }, noop_1.noop));
      return function() {
        currentBuffer = null;
      };
    });
  }
  buffer.buffer = buffer$1;
  return buffer;
}
var bufferCount = {};
var hasRequiredBufferCount;
function requireBufferCount() {
  if (hasRequiredBufferCount) return bufferCount;
  hasRequiredBufferCount = 1;
  var __values = bufferCount && bufferCount.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(bufferCount, "__esModule", { value: true });
  bufferCount.bufferCount = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var arrRemove_1 = /* @__PURE__ */ requireArrRemove();
  function bufferCount$1(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      var count2 = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a, e_2, _b;
        var toEmit = null;
        if (count2++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer2 = buffers_1_1.value;
            buffer2.push(value);
            if (bufferSize <= buffer2.length) {
              toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
              toEmit.push(buffer2);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer2 = toEmit_1_1.value;
              arrRemove_1.arrRemove(buffers, buffer2);
              subscriber.next(buffer2);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a;
        try {
          for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer2 = buffers_2_1.value;
            subscriber.next(buffer2);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        subscriber.complete();
      }, void 0, function() {
        buffers = null;
      }));
    });
  }
  bufferCount.bufferCount = bufferCount$1;
  return bufferCount;
}
var bufferTime = {};
var hasRequiredBufferTime;
function requireBufferTime() {
  if (hasRequiredBufferTime) return bufferTime;
  hasRequiredBufferTime = 1;
  var __values = bufferTime && bufferTime.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(bufferTime, "__esModule", { value: true });
  bufferTime.bufferTime = void 0;
  var Subscription_1 = /* @__PURE__ */ requireSubscription();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var arrRemove_1 = /* @__PURE__ */ requireArrRemove();
  var async_12 = /* @__PURE__ */ requireAsync();
  var args_1 = /* @__PURE__ */ requireArgs();
  var executeSchedule_1 = /* @__PURE__ */ requireExecuteSchedule();
  function bufferTime$1(bufferTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_12.asyncScheduler;
    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
    var maxBufferSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = function(record) {
        var buffer2 = record.buffer, subs = record.subs;
        subs.unsubscribe();
        arrRemove_1.arrRemove(bufferRecords, record);
        subscriber.next(buffer2);
        restartOnEmit && startBuffer();
      };
      var startBuffer = function() {
        if (bufferRecords) {
          var subs = new Subscription_1.Subscription();
          subscriber.add(subs);
          var buffer2 = [];
          var record_1 = {
            buffer: buffer2,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      };
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer2 = record.buffer;
            buffer2.push(value);
            maxBufferSize <= buffer2.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return)) _a2.call(recordsCopy_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, void 0, function() {
        return bufferRecords = null;
      });
      source.subscribe(bufferTimeSubscriber);
    });
  }
  bufferTime.bufferTime = bufferTime$1;
  return bufferTime;
}
var bufferToggle = {};
var hasRequiredBufferToggle;
function requireBufferToggle() {
  if (hasRequiredBufferToggle) return bufferToggle;
  hasRequiredBufferToggle = 1;
  var __values = bufferToggle && bufferToggle.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(bufferToggle, "__esModule", { value: true });
  bufferToggle.bufferToggle = void 0;
  var Subscription_1 = /* @__PURE__ */ requireSubscription();
  var lift_1 = /* @__PURE__ */ requireLift();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var arrRemove_1 = /* @__PURE__ */ requireArrRemove();
  function bufferToggle$1(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var buffer2 = [];
        buffers.push(buffer2);
        var closingSubscription = new Subscription_1.Subscription();
        var emitBuffer = function() {
          arrRemove_1.arrRemove(buffers, buffer2);
          subscriber.next(buffer2);
          closingSubscription.unsubscribe();
        };
        closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer2 = buffers_1_1.value;
            buffer2.push(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }, function() {
        while (buffers.length > 0) {
          subscriber.next(buffers.shift());
        }
        subscriber.complete();
      }));
    });
  }
  bufferToggle.bufferToggle = bufferToggle$1;
  return bufferToggle;
}
var bufferWhen = {};
var hasRequiredBufferWhen;
function requireBufferWhen() {
  if (hasRequiredBufferWhen) return bufferWhen;
  hasRequiredBufferWhen = 1;
  Object.defineProperty(bufferWhen, "__esModule", { value: true });
  bufferWhen.bufferWhen = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function bufferWhen$1(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffer2 = null;
      var closingSubscriber = null;
      var openBuffer = function() {
        closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
        var b = buffer2;
        buffer2 = [];
        b && subscriber.next(b);
        innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
      };
      openBuffer();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
      }, function() {
        buffer2 && subscriber.next(buffer2);
        subscriber.complete();
      }, void 0, function() {
        return buffer2 = closingSubscriber = null;
      }));
    });
  }
  bufferWhen.bufferWhen = bufferWhen$1;
  return bufferWhen;
}
var catchError = {};
var hasRequiredCatchError;
function requireCatchError() {
  if (hasRequiredCatchError) return catchError;
  hasRequiredCatchError = 1;
  Object.defineProperty(catchError, "__esModule", { value: true });
  catchError.catchError = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var lift_1 = /* @__PURE__ */ requireLift();
  function catchError$1(selector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        handledResult = innerFrom_1.innerFrom(selector(err, catchError$1(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }
  catchError.catchError = catchError$1;
  return catchError;
}
var combineAll = {};
var combineLatestAll = {};
var joinAllInternals = {};
var toArray = {};
var reduce = {};
var scanInternals = {};
var hasRequiredScanInternals;
function requireScanInternals() {
  if (hasRequiredScanInternals) return scanInternals;
  hasRequiredScanInternals = 1;
  Object.defineProperty(scanInternals, "__esModule", { value: true });
  scanInternals.scanInternals = void 0;
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function scanInternals$1(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state2 = seed;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        state2 = hasState ? accumulator(state2, value, i) : (hasState = true, value);
        emitOnNext && subscriber.next(state2);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state2);
        subscriber.complete();
      }));
    };
  }
  scanInternals.scanInternals = scanInternals$1;
  return scanInternals;
}
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce) return reduce;
  hasRequiredReduce = 1;
  Object.defineProperty(reduce, "__esModule", { value: true });
  reduce.reduce = void 0;
  var scanInternals_1 = /* @__PURE__ */ requireScanInternals();
  var lift_1 = /* @__PURE__ */ requireLift();
  function reduce$1(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
  }
  reduce.reduce = reduce$1;
  return reduce;
}
var hasRequiredToArray;
function requireToArray() {
  if (hasRequiredToArray) return toArray;
  hasRequiredToArray = 1;
  Object.defineProperty(toArray, "__esModule", { value: true });
  toArray.toArray = void 0;
  var reduce_1 = /* @__PURE__ */ requireReduce();
  var lift_1 = /* @__PURE__ */ requireLift();
  var arrReducer = function(arr, value) {
    return arr.push(value), arr;
  };
  function toArray$1() {
    return lift_1.operate(function(source, subscriber) {
      reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
    });
  }
  toArray.toArray = toArray$1;
  return toArray;
}
var hasRequiredJoinAllInternals;
function requireJoinAllInternals() {
  if (hasRequiredJoinAllInternals) return joinAllInternals;
  hasRequiredJoinAllInternals = 1;
  Object.defineProperty(joinAllInternals, "__esModule", { value: true });
  joinAllInternals.joinAllInternals = void 0;
  var identity_1 = /* @__PURE__ */ requireIdentity();
  var mapOneOrManyArgs_1 = /* @__PURE__ */ requireMapOneOrManyArgs();
  var pipe_1 = /* @__PURE__ */ requirePipe();
  var mergeMap_1 = /* @__PURE__ */ requireMergeMap();
  var toArray_1 = /* @__PURE__ */ requireToArray();
  function joinAllInternals$1(joinFn, project) {
    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
      return joinFn(sources);
    }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
  }
  joinAllInternals.joinAllInternals = joinAllInternals$1;
  return joinAllInternals;
}
var hasRequiredCombineLatestAll;
function requireCombineLatestAll() {
  if (hasRequiredCombineLatestAll) return combineLatestAll;
  hasRequiredCombineLatestAll = 1;
  Object.defineProperty(combineLatestAll, "__esModule", { value: true });
  combineLatestAll.combineLatestAll = void 0;
  var combineLatest_1 = /* @__PURE__ */ requireCombineLatest$1();
  var joinAllInternals_1 = /* @__PURE__ */ requireJoinAllInternals();
  function combineLatestAll$1(project) {
    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
  }
  combineLatestAll.combineLatestAll = combineLatestAll$1;
  return combineLatestAll;
}
var hasRequiredCombineAll;
function requireCombineAll() {
  if (hasRequiredCombineAll) return combineAll;
  hasRequiredCombineAll = 1;
  Object.defineProperty(combineAll, "__esModule", { value: true });
  combineAll.combineAll = void 0;
  var combineLatestAll_1 = /* @__PURE__ */ requireCombineLatestAll();
  combineAll.combineAll = combineLatestAll_1.combineLatestAll;
  return combineAll;
}
var combineLatestWith = {};
var combineLatest = {};
var hasRequiredCombineLatest;
function requireCombineLatest() {
  if (hasRequiredCombineLatest) return combineLatest;
  hasRequiredCombineLatest = 1;
  var __read = combineLatest && combineLatest.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = combineLatest && combineLatest.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(combineLatest, "__esModule", { value: true });
  combineLatest.combineLatest = void 0;
  var combineLatest_1 = /* @__PURE__ */ requireCombineLatest$1();
  var lift_1 = /* @__PURE__ */ requireLift();
  var argsOrArgArray_1 = /* @__PURE__ */ requireArgsOrArgArray();
  var mapOneOrManyArgs_1 = /* @__PURE__ */ requireMapOneOrManyArgs();
  var pipe_1 = /* @__PURE__ */ requirePipe();
  var args_1 = /* @__PURE__ */ requireArgs();
  function combineLatest$12() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args2);
    return resultSelector ? pipe_1.pipe(combineLatest$12.apply(void 0, __spreadArray([], __read(args2))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
      combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args2))))(subscriber);
    });
  }
  combineLatest.combineLatest = combineLatest$12;
  return combineLatest;
}
var hasRequiredCombineLatestWith;
function requireCombineLatestWith() {
  if (hasRequiredCombineLatestWith) return combineLatestWith;
  hasRequiredCombineLatestWith = 1;
  var __read = combineLatestWith && combineLatestWith.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = combineLatestWith && combineLatestWith.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(combineLatestWith, "__esModule", { value: true });
  combineLatestWith.combineLatestWith = void 0;
  var combineLatest_1 = /* @__PURE__ */ requireCombineLatest();
  function combineLatestWith$1() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return combineLatest_1.combineLatest.apply(void 0, __spreadArray([], __read(otherSources)));
  }
  combineLatestWith.combineLatestWith = combineLatestWith$1;
  return combineLatestWith;
}
var concatMap = {};
var hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap) return concatMap;
  hasRequiredConcatMap = 1;
  Object.defineProperty(concatMap, "__esModule", { value: true });
  concatMap.concatMap = void 0;
  var mergeMap_1 = /* @__PURE__ */ requireMergeMap();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function concatMap$1(project, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
  }
  concatMap.concatMap = concatMap$1;
  return concatMap;
}
var concatMapTo = {};
var hasRequiredConcatMapTo;
function requireConcatMapTo() {
  if (hasRequiredConcatMapTo) return concatMapTo;
  hasRequiredConcatMapTo = 1;
  Object.defineProperty(concatMapTo, "__esModule", { value: true });
  concatMapTo.concatMapTo = void 0;
  var concatMap_1 = /* @__PURE__ */ requireConcatMap();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function concatMapTo$1(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
      return innerObservable;
    }, resultSelector) : concatMap_1.concatMap(function() {
      return innerObservable;
    });
  }
  concatMapTo.concatMapTo = concatMapTo$1;
  return concatMapTo;
}
var concatWith = {};
var concat = {};
var hasRequiredConcat;
function requireConcat() {
  if (hasRequiredConcat) return concat;
  hasRequiredConcat = 1;
  var __read = concat && concat.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = concat && concat.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(concat, "__esModule", { value: true });
  concat.concat = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var concatAll_1 = /* @__PURE__ */ requireConcatAll();
  var args_1 = /* @__PURE__ */ requireArgs();
  var from_1 = /* @__PURE__ */ requireFrom();
  function concat$12() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args2);
    return lift_1.operate(function(source, subscriber) {
      concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args2)), scheduler)).subscribe(subscriber);
    });
  }
  concat.concat = concat$12;
  return concat;
}
var hasRequiredConcatWith;
function requireConcatWith() {
  if (hasRequiredConcatWith) return concatWith;
  hasRequiredConcatWith = 1;
  var __read = concatWith && concatWith.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = concatWith && concatWith.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(concatWith, "__esModule", { value: true });
  concatWith.concatWith = void 0;
  var concat_1 = /* @__PURE__ */ requireConcat();
  function concatWith$1() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return concat_1.concat.apply(void 0, __spreadArray([], __read(otherSources)));
  }
  concatWith.concatWith = concatWith$1;
  return concatWith;
}
var connect = {};
var fromSubscribable = {};
var hasRequiredFromSubscribable;
function requireFromSubscribable() {
  if (hasRequiredFromSubscribable) return fromSubscribable;
  hasRequiredFromSubscribable = 1;
  Object.defineProperty(fromSubscribable, "__esModule", { value: true });
  fromSubscribable.fromSubscribable = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  function fromSubscribable$1(subscribable) {
    return new Observable_1.Observable(function(subscriber) {
      return subscribable.subscribe(subscriber);
    });
  }
  fromSubscribable.fromSubscribable = fromSubscribable$1;
  return fromSubscribable;
}
var hasRequiredConnect;
function requireConnect() {
  if (hasRequiredConnect) return connect;
  hasRequiredConnect = 1;
  Object.defineProperty(connect, "__esModule", { value: true });
  connect.connect = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var lift_1 = /* @__PURE__ */ requireLift();
  var fromSubscribable_1 = /* @__PURE__ */ requireFromSubscribable();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject();
    }
  };
  function connect$1(selector, config2) {
    if (config2 === void 0) {
      config2 = DEFAULT_CONFIG;
    }
    var connector = config2.connector;
    return lift_1.operate(function(source, subscriber) {
      var subject = connector();
      innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
      subscriber.add(source.subscribe(subject));
    });
  }
  connect.connect = connect$1;
  return connect;
}
var count = {};
var hasRequiredCount;
function requireCount() {
  if (hasRequiredCount) return count;
  hasRequiredCount = 1;
  Object.defineProperty(count, "__esModule", { value: true });
  count.count = void 0;
  var reduce_1 = /* @__PURE__ */ requireReduce();
  function count$1(predicate) {
    return reduce_1.reduce(function(total, value, i) {
      return !predicate || predicate(value, i) ? total + 1 : total;
    }, 0);
  }
  count.count = count$1;
  return count;
}
var debounce = {};
var hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce) return debounce;
  hasRequiredDebounce = 1;
  Object.defineProperty(debounce, "__esModule", { value: true });
  debounce.debounce = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function debounce$1(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = function() {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value;
        durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
        innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, void 0, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  }
  debounce.debounce = debounce$1;
  return debounce;
}
var debounceTime = {};
var hasRequiredDebounceTime;
function requireDebounceTime() {
  if (hasRequiredDebounceTime) return debounceTime;
  hasRequiredDebounceTime = 1;
  Object.defineProperty(debounceTime, "__esModule", { value: true });
  debounceTime.debounceTime = void 0;
  var async_12 = /* @__PURE__ */ requireAsync();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function debounceTime$1(dueTime, scheduler) {
    if (scheduler === void 0) {
      scheduler = async_12.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();
        if (now < targetTime) {
          activeTask = this.schedule(void 0, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        lastValue = value;
        lastTime = scheduler.now();
        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, void 0, function() {
        lastValue = activeTask = null;
      }));
    });
  }
  debounceTime.debounceTime = debounceTime$1;
  return debounceTime;
}
var defaultIfEmpty = {};
var hasRequiredDefaultIfEmpty;
function requireDefaultIfEmpty() {
  if (hasRequiredDefaultIfEmpty) return defaultIfEmpty;
  hasRequiredDefaultIfEmpty = 1;
  Object.defineProperty(defaultIfEmpty, "__esModule", { value: true });
  defaultIfEmpty.defaultIfEmpty = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function defaultIfEmpty$1(defaultValue) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }
  defaultIfEmpty.defaultIfEmpty = defaultIfEmpty$1;
  return defaultIfEmpty;
}
var delay = {};
var delayWhen = {};
var take = {};
var hasRequiredTake;
function requireTake() {
  if (hasRequiredTake) return take;
  hasRequiredTake = 1;
  Object.defineProperty(take, "__esModule", { value: true });
  take.take = void 0;
  var empty_1 = /* @__PURE__ */ requireEmpty();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function take$1(count2) {
    return count2 <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count2) {
          subscriber.next(value);
          if (count2 <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }
  take.take = take$1;
  return take;
}
var ignoreElements = {};
var hasRequiredIgnoreElements;
function requireIgnoreElements() {
  if (hasRequiredIgnoreElements) return ignoreElements;
  hasRequiredIgnoreElements = 1;
  Object.defineProperty(ignoreElements, "__esModule", { value: true });
  ignoreElements.ignoreElements = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var noop_1 = /* @__PURE__ */ requireNoop();
  function ignoreElements$1() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
    });
  }
  ignoreElements.ignoreElements = ignoreElements$1;
  return ignoreElements;
}
var mapTo = {};
var hasRequiredMapTo;
function requireMapTo() {
  if (hasRequiredMapTo) return mapTo;
  hasRequiredMapTo = 1;
  Object.defineProperty(mapTo, "__esModule", { value: true });
  mapTo.mapTo = void 0;
  var map_1 = /* @__PURE__ */ requireMap();
  function mapTo$1(value) {
    return map_1.map(function() {
      return value;
    });
  }
  mapTo.mapTo = mapTo$1;
  return mapTo;
}
var hasRequiredDelayWhen;
function requireDelayWhen() {
  if (hasRequiredDelayWhen) return delayWhen;
  hasRequiredDelayWhen = 1;
  Object.defineProperty(delayWhen, "__esModule", { value: true });
  delayWhen.delayWhen = void 0;
  var concat_1 = /* @__PURE__ */ requireConcat$1();
  var take_1 = /* @__PURE__ */ requireTake();
  var ignoreElements_1 = /* @__PURE__ */ requireIgnoreElements();
  var mapTo_1 = /* @__PURE__ */ requireMapTo();
  var mergeMap_1 = /* @__PURE__ */ requireMergeMap();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function delayWhen$1(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen$1(delayDurationSelector)));
      };
    }
    return mergeMap_1.mergeMap(function(value, index) {
      return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
    });
  }
  delayWhen.delayWhen = delayWhen$1;
  return delayWhen;
}
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay) return delay;
  hasRequiredDelay = 1;
  Object.defineProperty(delay, "__esModule", { value: true });
  delay.delay = void 0;
  var async_12 = /* @__PURE__ */ requireAsync();
  var delayWhen_1 = /* @__PURE__ */ requireDelayWhen();
  var timer_1 = /* @__PURE__ */ requireTimer();
  function delay$1(due, scheduler) {
    if (scheduler === void 0) {
      scheduler = async_12.asyncScheduler;
    }
    var duration = timer_1.timer(due, scheduler);
    return delayWhen_1.delayWhen(function() {
      return duration;
    });
  }
  delay.delay = delay$1;
  return delay;
}
var dematerialize = {};
var hasRequiredDematerialize;
function requireDematerialize() {
  if (hasRequiredDematerialize) return dematerialize;
  hasRequiredDematerialize = 1;
  Object.defineProperty(dematerialize, "__esModule", { value: true });
  dematerialize.dematerialize = void 0;
  var Notification_1 = /* @__PURE__ */ requireNotification();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function dematerialize$1() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
        return Notification_1.observeNotification(notification, subscriber);
      }));
    });
  }
  dematerialize.dematerialize = dematerialize$1;
  return dematerialize;
}
var distinct = {};
var hasRequiredDistinct;
function requireDistinct() {
  if (hasRequiredDistinct) return distinct;
  hasRequiredDistinct = 1;
  Object.defineProperty(distinct, "__esModule", { value: true });
  distinct.distinct = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function distinct$1(keySelector, flushes) {
    return lift_1.operate(function(source, subscriber) {
      var distinctKeys = /* @__PURE__ */ new Set();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var key = keySelector ? keySelector(value) : value;
        if (!distinctKeys.has(key)) {
          distinctKeys.add(key);
          subscriber.next(value);
        }
      }));
      flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return distinctKeys.clear();
      }, noop_1.noop));
    });
  }
  distinct.distinct = distinct$1;
  return distinct;
}
var distinctUntilChanged = {};
var hasRequiredDistinctUntilChanged;
function requireDistinctUntilChanged() {
  if (hasRequiredDistinctUntilChanged) return distinctUntilChanged;
  hasRequiredDistinctUntilChanged = 1;
  Object.defineProperty(distinctUntilChanged, "__esModule", { value: true });
  distinctUntilChanged.distinctUntilChanged = void 0;
  var identity_1 = /* @__PURE__ */ requireIdentity();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function distinctUntilChanged$1(comparator, keySelector) {
    if (keySelector === void 0) {
      keySelector = identity_1.identity;
    }
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return lift_1.operate(function(source, subscriber) {
      var previousKey;
      var first2 = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var currentKey = keySelector(value);
        if (first2 || !comparator(previousKey, currentKey)) {
          first2 = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  }
  distinctUntilChanged.distinctUntilChanged = distinctUntilChanged$1;
  function defaultCompare(a, b) {
    return a === b;
  }
  return distinctUntilChanged;
}
var distinctUntilKeyChanged = {};
var hasRequiredDistinctUntilKeyChanged;
function requireDistinctUntilKeyChanged() {
  if (hasRequiredDistinctUntilKeyChanged) return distinctUntilKeyChanged;
  hasRequiredDistinctUntilKeyChanged = 1;
  Object.defineProperty(distinctUntilKeyChanged, "__esModule", { value: true });
  distinctUntilKeyChanged.distinctUntilKeyChanged = void 0;
  var distinctUntilChanged_1 = /* @__PURE__ */ requireDistinctUntilChanged();
  function distinctUntilKeyChanged$1(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
      return compare ? compare(x[key], y[key]) : x[key] === y[key];
    });
  }
  distinctUntilKeyChanged.distinctUntilKeyChanged = distinctUntilKeyChanged$1;
  return distinctUntilKeyChanged;
}
var elementAt = {};
var throwIfEmpty = {};
var hasRequiredThrowIfEmpty;
function requireThrowIfEmpty() {
  if (hasRequiredThrowIfEmpty) return throwIfEmpty;
  hasRequiredThrowIfEmpty = 1;
  Object.defineProperty(throwIfEmpty, "__esModule", { value: true });
  throwIfEmpty.throwIfEmpty = void 0;
  var EmptyError_1 = /* @__PURE__ */ requireEmptyError();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function throwIfEmpty$1(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  throwIfEmpty.throwIfEmpty = throwIfEmpty$1;
  function defaultErrorFactory() {
    return new EmptyError_1.EmptyError();
  }
  return throwIfEmpty;
}
var hasRequiredElementAt;
function requireElementAt() {
  if (hasRequiredElementAt) return elementAt;
  hasRequiredElementAt = 1;
  Object.defineProperty(elementAt, "__esModule", { value: true });
  elementAt.elementAt = void 0;
  var ArgumentOutOfRangeError_1 = /* @__PURE__ */ requireArgumentOutOfRangeError();
  var filter_1 = /* @__PURE__ */ requireFilter();
  var throwIfEmpty_1 = /* @__PURE__ */ requireThrowIfEmpty();
  var defaultIfEmpty_1 = /* @__PURE__ */ requireDefaultIfEmpty();
  var take_1 = /* @__PURE__ */ requireTake();
  function elementAt$1(index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(filter_1.filter(function(v, i) {
        return i === index;
      }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }));
    };
  }
  elementAt.elementAt = elementAt$1;
  return elementAt;
}
var endWith = {};
var hasRequiredEndWith;
function requireEndWith() {
  if (hasRequiredEndWith) return endWith;
  hasRequiredEndWith = 1;
  var __read = endWith && endWith.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = endWith && endWith.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(endWith, "__esModule", { value: true });
  endWith.endWith = void 0;
  var concat_1 = /* @__PURE__ */ requireConcat$1();
  var of_1 = /* @__PURE__ */ requireOf();
  function endWith$1() {
    var values2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values2[_i] = arguments[_i];
    }
    return function(source) {
      return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray([], __read(values2))));
    };
  }
  endWith.endWith = endWith$1;
  return endWith;
}
var every = {};
var hasRequiredEvery;
function requireEvery() {
  if (hasRequiredEvery) return every;
  hasRequiredEvery = 1;
  Object.defineProperty(every, "__esModule", { value: true });
  every.every = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function every$1(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (!predicate.call(thisArg, value, index++, source)) {
          subscriber.next(false);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  every.every = every$1;
  return every;
}
var exhaust = {};
var exhaustAll = {};
var exhaustMap = {};
var hasRequiredExhaustMap;
function requireExhaustMap() {
  if (hasRequiredExhaustMap) return exhaustMap;
  hasRequiredExhaustMap = 1;
  Object.defineProperty(exhaustMap, "__esModule", { value: true });
  exhaustMap.exhaustMap = void 0;
  var map_1 = /* @__PURE__ */ requireMap();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function exhaustMap$1(project, resultSelector) {
    if (resultSelector) {
      return function(source) {
        return source.pipe(exhaustMap$1(function(a, i) {
          return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          }));
        }));
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      var innerSub = null;
      var isComplete = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
        if (!innerSub) {
          innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            innerSub = null;
            isComplete && subscriber.complete();
          });
          innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
        }
      }, function() {
        isComplete = true;
        !innerSub && subscriber.complete();
      }));
    });
  }
  exhaustMap.exhaustMap = exhaustMap$1;
  return exhaustMap;
}
var hasRequiredExhaustAll;
function requireExhaustAll() {
  if (hasRequiredExhaustAll) return exhaustAll;
  hasRequiredExhaustAll = 1;
  Object.defineProperty(exhaustAll, "__esModule", { value: true });
  exhaustAll.exhaustAll = void 0;
  var exhaustMap_1 = /* @__PURE__ */ requireExhaustMap();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  function exhaustAll$1() {
    return exhaustMap_1.exhaustMap(identity_1.identity);
  }
  exhaustAll.exhaustAll = exhaustAll$1;
  return exhaustAll;
}
var hasRequiredExhaust;
function requireExhaust() {
  if (hasRequiredExhaust) return exhaust;
  hasRequiredExhaust = 1;
  Object.defineProperty(exhaust, "__esModule", { value: true });
  exhaust.exhaust = void 0;
  var exhaustAll_1 = /* @__PURE__ */ requireExhaustAll();
  exhaust.exhaust = exhaustAll_1.exhaustAll;
  return exhaust;
}
var expand = {};
var hasRequiredExpand;
function requireExpand() {
  if (hasRequiredExpand) return expand;
  hasRequiredExpand = 1;
  Object.defineProperty(expand, "__esModule", { value: true });
  expand.expand = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var mergeInternals_1 = /* @__PURE__ */ requireMergeInternals();
  function expand$1(project, concurrent, scheduler) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
    });
  }
  expand.expand = expand$1;
  return expand;
}
var finalize = {};
var hasRequiredFinalize;
function requireFinalize() {
  if (hasRequiredFinalize) return finalize;
  hasRequiredFinalize = 1;
  Object.defineProperty(finalize, "__esModule", { value: true });
  finalize.finalize = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  function finalize$1(callback) {
    return lift_1.operate(function(source, subscriber) {
      try {
        source.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  }
  finalize.finalize = finalize$1;
  return finalize;
}
var find = {};
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind) return find;
  hasRequiredFind = 1;
  Object.defineProperty(find, "__esModule", { value: true });
  find.createFind = find.find = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function find$1(predicate, thisArg) {
    return lift_1.operate(createFind(predicate, thisArg, "value"));
  }
  find.find = find$1;
  function createFind(predicate, thisArg, emit) {
    var findIndex2 = emit === "index";
    return function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        if (predicate.call(thisArg, value, i, source)) {
          subscriber.next(findIndex2 ? i : value);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(findIndex2 ? -1 : void 0);
        subscriber.complete();
      }));
    };
  }
  find.createFind = createFind;
  return find;
}
var findIndex = {};
var hasRequiredFindIndex;
function requireFindIndex() {
  if (hasRequiredFindIndex) return findIndex;
  hasRequiredFindIndex = 1;
  Object.defineProperty(findIndex, "__esModule", { value: true });
  findIndex.findIndex = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var find_1 = /* @__PURE__ */ requireFind();
  function findIndex$1(predicate, thisArg) {
    return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
  }
  findIndex.findIndex = findIndex$1;
  return findIndex;
}
var first = {};
var hasRequiredFirst;
function requireFirst() {
  if (hasRequiredFirst) return first;
  hasRequiredFirst = 1;
  Object.defineProperty(first, "__esModule", { value: true });
  first.first = void 0;
  var EmptyError_1 = /* @__PURE__ */ requireEmptyError();
  var filter_1 = /* @__PURE__ */ requireFilter();
  var take_1 = /* @__PURE__ */ requireTake();
  var defaultIfEmpty_1 = /* @__PURE__ */ requireDefaultIfEmpty();
  var throwIfEmpty_1 = /* @__PURE__ */ requireThrowIfEmpty();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  function first$1(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError();
      }));
    };
  }
  first.first = first$1;
  return first;
}
var groupBy = {};
var hasRequiredGroupBy;
function requireGroupBy() {
  if (hasRequiredGroupBy) return groupBy;
  hasRequiredGroupBy = 1;
  Object.defineProperty(groupBy, "__esModule", { value: true });
  groupBy.groupBy = void 0;
  var Observable_1 = /* @__PURE__ */ requireObservable();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function groupBy$1(keySelector, elementOrOptions, duration, connector) {
    return lift_1.operate(function(source, subscriber) {
      var element;
      if (!elementOrOptions || typeof elementOrOptions === "function") {
        element = elementOrOptions;
      } else {
        duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
      }
      var groups = /* @__PURE__ */ new Map();
      var notify = function(cb) {
        groups.forEach(cb);
        cb(subscriber);
      };
      var handleError = function(err) {
        return notify(function(consumer) {
          return consumer.error(err);
        });
      };
      var activeGroups = 0;
      var teardownAttempted = false;
      var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
        try {
          var key_1 = keySelector(value);
          var group_1 = groups.get(key_1);
          if (!group_1) {
            groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
            var grouped = createGroupedObservable(key_1, group_1);
            subscriber.next(grouped);
            if (duration) {
              var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                group_1.complete();
                durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
              }, void 0, void 0, function() {
                return groups.delete(key_1);
              });
              groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
            }
          }
          group_1.next(element ? element(value) : value);
        } catch (err) {
          handleError(err);
        }
      }, function() {
        return notify(function(consumer) {
          return consumer.complete();
        });
      }, handleError, function() {
        return groups.clear();
      }, function() {
        teardownAttempted = true;
        return activeGroups === 0;
      });
      source.subscribe(groupBySourceSubscriber);
      function createGroupedObservable(key, groupSubject) {
        var result = new Observable_1.Observable(function(groupSubscriber) {
          activeGroups++;
          var innerSub = groupSubject.subscribe(groupSubscriber);
          return function() {
            innerSub.unsubscribe();
            --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
          };
        });
        result.key = key;
        return result;
      }
    });
  }
  groupBy.groupBy = groupBy$1;
  return groupBy;
}
var isEmpty = {};
var hasRequiredIsEmpty;
function requireIsEmpty() {
  if (hasRequiredIsEmpty) return isEmpty;
  hasRequiredIsEmpty = 1;
  Object.defineProperty(isEmpty, "__esModule", { value: true });
  isEmpty.isEmpty = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function isEmpty$1() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        subscriber.next(false);
        subscriber.complete();
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  isEmpty.isEmpty = isEmpty$1;
  return isEmpty;
}
var last = {};
var takeLast = {};
var hasRequiredTakeLast;
function requireTakeLast() {
  if (hasRequiredTakeLast) return takeLast;
  hasRequiredTakeLast = 1;
  var __values = takeLast && takeLast.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(takeLast, "__esModule", { value: true });
  takeLast.takeLast = void 0;
  var empty_1 = /* @__PURE__ */ requireEmpty();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function takeLast$1(count2) {
    return count2 <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var buffer2 = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        buffer2.push(value);
        count2 < buffer2.length && buffer2.shift();
      }, function() {
        var e_1, _a;
        try {
          for (var buffer_1 = __values(buffer2), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value = buffer_1_1.value;
            subscriber.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        subscriber.complete();
      }, void 0, function() {
        buffer2 = null;
      }));
    });
  }
  takeLast.takeLast = takeLast$1;
  return takeLast;
}
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast) return last;
  hasRequiredLast = 1;
  Object.defineProperty(last, "__esModule", { value: true });
  last.last = void 0;
  var EmptyError_1 = /* @__PURE__ */ requireEmptyError();
  var filter_1 = /* @__PURE__ */ requireFilter();
  var takeLast_1 = /* @__PURE__ */ requireTakeLast();
  var throwIfEmpty_1 = /* @__PURE__ */ requireThrowIfEmpty();
  var defaultIfEmpty_1 = /* @__PURE__ */ requireDefaultIfEmpty();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  function last$1(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError();
      }));
    };
  }
  last.last = last$1;
  return last;
}
var materialize = {};
var hasRequiredMaterialize;
function requireMaterialize() {
  if (hasRequiredMaterialize) return materialize;
  hasRequiredMaterialize = 1;
  Object.defineProperty(materialize, "__esModule", { value: true });
  materialize.materialize = void 0;
  var Notification_1 = /* @__PURE__ */ requireNotification();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function materialize$1() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(Notification_1.Notification.createNext(value));
      }, function() {
        subscriber.next(Notification_1.Notification.createComplete());
        subscriber.complete();
      }, function(err) {
        subscriber.next(Notification_1.Notification.createError(err));
        subscriber.complete();
      }));
    });
  }
  materialize.materialize = materialize$1;
  return materialize;
}
var max = {};
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  Object.defineProperty(max, "__esModule", { value: true });
  max.max = void 0;
  var reduce_1 = /* @__PURE__ */ requireReduce();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function max$12(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
      return comparer(x, y) > 0 ? x : y;
    } : function(x, y) {
      return x > y ? x : y;
    });
  }
  max.max = max$12;
  return max;
}
var flatMap = {};
var hasRequiredFlatMap;
function requireFlatMap() {
  if (hasRequiredFlatMap) return flatMap;
  hasRequiredFlatMap = 1;
  Object.defineProperty(flatMap, "__esModule", { value: true });
  flatMap.flatMap = void 0;
  var mergeMap_1 = /* @__PURE__ */ requireMergeMap();
  flatMap.flatMap = mergeMap_1.mergeMap;
  return flatMap;
}
var mergeMapTo = {};
var hasRequiredMergeMapTo;
function requireMergeMapTo() {
  if (hasRequiredMergeMapTo) return mergeMapTo;
  hasRequiredMergeMapTo = 1;
  Object.defineProperty(mergeMapTo, "__esModule", { value: true });
  mergeMapTo.mergeMapTo = void 0;
  var mergeMap_1 = /* @__PURE__ */ requireMergeMap();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function mergeMapTo$1(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, resultSelector, concurrent);
    }
    if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, concurrent);
  }
  mergeMapTo.mergeMapTo = mergeMapTo$1;
  return mergeMapTo;
}
var mergeScan = {};
var hasRequiredMergeScan;
function requireMergeScan() {
  if (hasRequiredMergeScan) return mergeScan;
  hasRequiredMergeScan = 1;
  Object.defineProperty(mergeScan, "__esModule", { value: true });
  mergeScan.mergeScan = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var mergeInternals_1 = /* @__PURE__ */ requireMergeInternals();
  function mergeScan$1(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return lift_1.operate(function(source, subscriber) {
      var state2 = seed;
      return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
        return accumulator(state2, value, index);
      }, concurrent, function(value) {
        state2 = value;
      }, false, void 0, function() {
        return state2 = null;
      });
    });
  }
  mergeScan.mergeScan = mergeScan$1;
  return mergeScan;
}
var mergeWith = {};
var merge = {};
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge;
  hasRequiredMerge = 1;
  var __read = merge && merge.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = merge && merge.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(merge, "__esModule", { value: true });
  merge.merge = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var mergeAll_1 = /* @__PURE__ */ requireMergeAll();
  var args_1 = /* @__PURE__ */ requireArgs();
  var from_1 = /* @__PURE__ */ requireFrom();
  function merge$12() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args2);
    var concurrent = args_1.popNumber(args2, Infinity);
    return lift_1.operate(function(source, subscriber) {
      mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args2)), scheduler)).subscribe(subscriber);
    });
  }
  merge.merge = merge$12;
  return merge;
}
var hasRequiredMergeWith;
function requireMergeWith() {
  if (hasRequiredMergeWith) return mergeWith;
  hasRequiredMergeWith = 1;
  var __read = mergeWith && mergeWith.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = mergeWith && mergeWith.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(mergeWith, "__esModule", { value: true });
  mergeWith.mergeWith = void 0;
  var merge_1 = /* @__PURE__ */ requireMerge();
  function mergeWith$1() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return merge_1.merge.apply(void 0, __spreadArray([], __read(otherSources)));
  }
  mergeWith.mergeWith = mergeWith$1;
  return mergeWith;
}
var min = {};
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  Object.defineProperty(min, "__esModule", { value: true });
  min.min = void 0;
  var reduce_1 = /* @__PURE__ */ requireReduce();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function min$12(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
      return comparer(x, y) < 0 ? x : y;
    } : function(x, y) {
      return x < y ? x : y;
    });
  }
  min.min = min$12;
  return min;
}
var multicast = {};
var hasRequiredMulticast;
function requireMulticast() {
  if (hasRequiredMulticast) return multicast;
  hasRequiredMulticast = 1;
  Object.defineProperty(multicast, "__esModule", { value: true });
  multicast.multicast = void 0;
  var ConnectableObservable_1 = /* @__PURE__ */ requireConnectableObservable();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  var connect_1 = /* @__PURE__ */ requireConnect();
  function multicast$1(subjectOrSubjectFactory, selector) {
    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
      return subjectOrSubjectFactory;
    };
    if (isFunction_1.isFunction(selector)) {
      return connect_1.connect(selector, {
        connector: subjectFactory
      });
    }
    return function(source) {
      return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
    };
  }
  multicast.multicast = multicast$1;
  return multicast;
}
var onErrorResumeNextWith = {};
var hasRequiredOnErrorResumeNextWith;
function requireOnErrorResumeNextWith() {
  if (hasRequiredOnErrorResumeNextWith) return onErrorResumeNextWith;
  hasRequiredOnErrorResumeNextWith = 1;
  var __read = onErrorResumeNextWith && onErrorResumeNextWith.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = onErrorResumeNextWith && onErrorResumeNextWith.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(onErrorResumeNextWith, "__esModule", { value: true });
  onErrorResumeNextWith.onErrorResumeNext = onErrorResumeNextWith.onErrorResumeNextWith = void 0;
  var argsOrArgArray_1 = /* @__PURE__ */ requireArgsOrArgArray();
  var onErrorResumeNext_1 = /* @__PURE__ */ requireOnErrorResumeNext();
  function onErrorResumeNextWith$1() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return function(source) {
      return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources)));
    };
  }
  onErrorResumeNextWith.onErrorResumeNextWith = onErrorResumeNextWith$1;
  onErrorResumeNextWith.onErrorResumeNext = onErrorResumeNextWith$1;
  return onErrorResumeNextWith;
}
var pairwise = {};
var hasRequiredPairwise;
function requirePairwise() {
  if (hasRequiredPairwise) return pairwise;
  hasRequiredPairwise = 1;
  Object.defineProperty(pairwise, "__esModule", { value: true });
  pairwise.pairwise = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function pairwise$1() {
    return lift_1.operate(function(source, subscriber) {
      var prev;
      var hasPrev = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var p = prev;
        prev = value;
        hasPrev && subscriber.next([p, value]);
        hasPrev = true;
      }));
    });
  }
  pairwise.pairwise = pairwise$1;
  return pairwise;
}
var pluck = {};
var hasRequiredPluck;
function requirePluck() {
  if (hasRequiredPluck) return pluck;
  hasRequiredPluck = 1;
  Object.defineProperty(pluck, "__esModule", { value: true });
  pluck.pluck = void 0;
  var map_1 = /* @__PURE__ */ requireMap();
  function pluck$1() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
      throw new Error("list of properties cannot be empty.");
    }
    return map_1.map(function(x) {
      var currentProp = x;
      for (var i = 0; i < length; i++) {
        var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
        if (typeof p !== "undefined") {
          currentProp = p;
        } else {
          return void 0;
        }
      }
      return currentProp;
    });
  }
  pluck.pluck = pluck$1;
  return pluck;
}
var publish = {};
var hasRequiredPublish;
function requirePublish() {
  if (hasRequiredPublish) return publish;
  hasRequiredPublish = 1;
  Object.defineProperty(publish, "__esModule", { value: true });
  publish.publish = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var multicast_1 = /* @__PURE__ */ requireMulticast();
  var connect_1 = /* @__PURE__ */ requireConnect();
  function publish$1(selector) {
    return selector ? function(source) {
      return connect_1.connect(selector)(source);
    } : function(source) {
      return multicast_1.multicast(new Subject_1.Subject())(source);
    };
  }
  publish.publish = publish$1;
  return publish;
}
var publishBehavior = {};
var hasRequiredPublishBehavior;
function requirePublishBehavior() {
  if (hasRequiredPublishBehavior) return publishBehavior;
  hasRequiredPublishBehavior = 1;
  Object.defineProperty(publishBehavior, "__esModule", { value: true });
  publishBehavior.publishBehavior = void 0;
  var BehaviorSubject_1 = /* @__PURE__ */ requireBehaviorSubject();
  var ConnectableObservable_1 = /* @__PURE__ */ requireConnectableObservable();
  function publishBehavior$1(initialValue) {
    return function(source) {
      var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  }
  publishBehavior.publishBehavior = publishBehavior$1;
  return publishBehavior;
}
var publishLast = {};
var hasRequiredPublishLast;
function requirePublishLast() {
  if (hasRequiredPublishLast) return publishLast;
  hasRequiredPublishLast = 1;
  Object.defineProperty(publishLast, "__esModule", { value: true });
  publishLast.publishLast = void 0;
  var AsyncSubject_1 = /* @__PURE__ */ requireAsyncSubject();
  var ConnectableObservable_1 = /* @__PURE__ */ requireConnectableObservable();
  function publishLast$1() {
    return function(source) {
      var subject = new AsyncSubject_1.AsyncSubject();
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  }
  publishLast.publishLast = publishLast$1;
  return publishLast;
}
var publishReplay = {};
var hasRequiredPublishReplay;
function requirePublishReplay() {
  if (hasRequiredPublishReplay) return publishReplay;
  hasRequiredPublishReplay = 1;
  Object.defineProperty(publishReplay, "__esModule", { value: true });
  publishReplay.publishReplay = void 0;
  var ReplaySubject_1 = /* @__PURE__ */ requireReplaySubject();
  var multicast_1 = /* @__PURE__ */ requireMulticast();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function publishReplay$1(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
      timestampProvider = selectorOrScheduler;
    }
    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
    return function(source) {
      return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source);
    };
  }
  publishReplay.publishReplay = publishReplay$1;
  return publishReplay;
}
var raceWith = {};
var hasRequiredRaceWith;
function requireRaceWith() {
  if (hasRequiredRaceWith) return raceWith;
  hasRequiredRaceWith = 1;
  var __read = raceWith && raceWith.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = raceWith && raceWith.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(raceWith, "__esModule", { value: true });
  raceWith.raceWith = void 0;
  var race_1 = /* @__PURE__ */ requireRace$1();
  var lift_1 = /* @__PURE__ */ requireLift();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  function raceWith$1() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
    });
  }
  raceWith.raceWith = raceWith$1;
  return raceWith;
}
var repeat = {};
var hasRequiredRepeat;
function requireRepeat() {
  if (hasRequiredRepeat) return repeat;
  hasRequiredRepeat = 1;
  Object.defineProperty(repeat, "__esModule", { value: true });
  repeat.repeat = void 0;
  var empty_1 = /* @__PURE__ */ requireEmpty();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var timer_1 = /* @__PURE__ */ requireTimer();
  function repeat$1(countOrConfig) {
    var _a;
    var count2 = Infinity;
    var delay2;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
      } else {
        count2 = countOrConfig;
      }
    }
    return count2 <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = function() {
        sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
        sourceSub = null;
        if (delay2 != null) {
          var notifier = typeof delay2 === "number" ? timer_1.timer(delay2) : innerFrom_1.innerFrom(delay2(soFar));
          var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      };
      var subscribeToSource = function() {
        var syncUnsub = false;
        sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
          if (++soFar < count2) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      };
      subscribeToSource();
    });
  }
  repeat.repeat = repeat$1;
  return repeat;
}
var repeatWhen = {};
var hasRequiredRepeatWhen;
function requireRepeatWhen() {
  if (hasRequiredRepeatWhen) return repeatWhen;
  hasRequiredRepeatWhen = 1;
  Object.defineProperty(repeatWhen, "__esModule", { value: true });
  repeatWhen.repeatWhen = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function repeatWhen$1(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var completions$;
      var isNotifierComplete = false;
      var isMainComplete = false;
      var checkComplete = function() {
        return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
      };
      var getCompletionSubject = function() {
        if (!completions$) {
          completions$ = new Subject_1.Subject();
          innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (innerSub) {
              subscribeForRepeatWhen();
            } else {
              syncResub = true;
            }
          }, function() {
            isNotifierComplete = true;
            checkComplete();
          }));
        }
        return completions$;
      };
      var subscribeForRepeatWhen = function() {
        isMainComplete = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
          isMainComplete = true;
          !checkComplete() && getCompletionSubject().next();
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRepeatWhen();
        }
      };
      subscribeForRepeatWhen();
    });
  }
  repeatWhen.repeatWhen = repeatWhen$1;
  return repeatWhen;
}
var retry = {};
var hasRequiredRetry;
function requireRetry() {
  if (hasRequiredRetry) return retry;
  hasRequiredRetry = 1;
  Object.defineProperty(retry, "__esModule", { value: true });
  retry.retry = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  var timer_1 = /* @__PURE__ */ requireTimer();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function retry$1(configOrCount) {
    if (configOrCount === void 0) {
      configOrCount = Infinity;
    }
    var config2;
    if (configOrCount && typeof configOrCount === "object") {
      config2 = configOrCount;
    } else {
      config2 = {
        count: configOrCount
      };
    }
    var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
    return count2 <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value);
        }, void 0, function(err) {
          if (soFar++ < count2) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay2 != null) {
              var notifier = typeof delay2 === "number" ? timer_1.timer(delay2) : innerFrom_1.innerFrom(delay2(err, soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  }
  retry.retry = retry$1;
  return retry;
}
var retryWhen = {};
var hasRequiredRetryWhen;
function requireRetryWhen() {
  if (hasRequiredRetryWhen) return retryWhen;
  hasRequiredRetryWhen = 1;
  Object.defineProperty(retryWhen, "__esModule", { value: true });
  retryWhen.retryWhen = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function retryWhen$1(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var errors$;
      var subscribeForRetryWhen = function() {
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          if (!errors$) {
            errors$ = new Subject_1.Subject();
            innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              return innerSub ? subscribeForRetryWhen() : syncResub = true;
            }));
          }
          if (errors$) {
            errors$.next(err);
          }
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRetryWhen();
        }
      };
      subscribeForRetryWhen();
    });
  }
  retryWhen.retryWhen = retryWhen$1;
  return retryWhen;
}
var sample = {};
var hasRequiredSample;
function requireSample() {
  if (hasRequiredSample) return sample;
  hasRequiredSample = 1;
  Object.defineProperty(sample, "__esModule", { value: true });
  sample.sample = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var lift_1 = /* @__PURE__ */ requireLift();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function sample$1(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
      }));
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      }, noop_1.noop));
    });
  }
  sample.sample = sample$1;
  return sample;
}
var sampleTime = {};
var hasRequiredSampleTime;
function requireSampleTime() {
  if (hasRequiredSampleTime) return sampleTime;
  hasRequiredSampleTime = 1;
  Object.defineProperty(sampleTime, "__esModule", { value: true });
  sampleTime.sampleTime = void 0;
  var async_12 = /* @__PURE__ */ requireAsync();
  var sample_1 = /* @__PURE__ */ requireSample();
  var interval_1 = /* @__PURE__ */ requireInterval();
  function sampleTime$1(period, scheduler) {
    if (scheduler === void 0) {
      scheduler = async_12.asyncScheduler;
    }
    return sample_1.sample(interval_1.interval(period, scheduler));
  }
  sampleTime.sampleTime = sampleTime$1;
  return sampleTime;
}
var scan = {};
var hasRequiredScan;
function requireScan() {
  if (hasRequiredScan) return scan;
  hasRequiredScan = 1;
  Object.defineProperty(scan, "__esModule", { value: true });
  scan.scan = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var scanInternals_1 = /* @__PURE__ */ requireScanInternals();
  function scan$1(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
  }
  scan.scan = scan$1;
  return scan;
}
var sequenceEqual = {};
var hasRequiredSequenceEqual;
function requireSequenceEqual() {
  if (hasRequiredSequenceEqual) return sequenceEqual;
  hasRequiredSequenceEqual = 1;
  Object.defineProperty(sequenceEqual, "__esModule", { value: true });
  sequenceEqual.sequenceEqual = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function sequenceEqual$1(compareTo, comparator) {
    if (comparator === void 0) {
      comparator = function(a, b) {
        return a === b;
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var aState = createState();
      var bState = createState();
      var emit = function(isEqual) {
        subscriber.next(isEqual);
        subscriber.complete();
      };
      var createSubscriber = function(selfState, otherState) {
        var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
          var buffer2 = otherState.buffer, complete = otherState.complete;
          if (buffer2.length === 0) {
            complete ? emit(false) : selfState.buffer.push(a);
          } else {
            !comparator(a, buffer2.shift()) && emit(false);
          }
        }, function() {
          selfState.complete = true;
          var complete = otherState.complete, buffer2 = otherState.buffer;
          complete && emit(buffer2.length === 0);
          sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
        });
        return sequenceEqualSubscriber;
      };
      source.subscribe(createSubscriber(aState, bState));
      innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
    });
  }
  sequenceEqual.sequenceEqual = sequenceEqual$1;
  function createState() {
    return {
      buffer: [],
      complete: false
    };
  }
  return sequenceEqual;
}
var share = {};
var hasRequiredShare;
function requireShare() {
  if (hasRequiredShare) return share;
  hasRequiredShare = 1;
  var __read = share && share.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = share && share.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(share, "__esModule", { value: true });
  share.share = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var Subscriber_1 = /* @__PURE__ */ requireSubscriber();
  var lift_1 = /* @__PURE__ */ requireLift();
  function share$1(options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.connector, connector = _a === void 0 ? function() {
      return new Subject_1.Subject();
    } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount2 = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
        resetConnection = void 0;
      };
      var reset = function() {
        cancelReset();
        connection = subject = void 0;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
      };
      return lift_1.operate(function(source, subscriber) {
        refCount2++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
        subscriber.add(function() {
          refCount2--;
          if (refCount2 === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount2 > 0) {
          connection = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              return dest.next(value);
            },
            error: function(err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom_1.innerFrom(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  }
  share.share = share$1;
  function handleReset(reset, on) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new Subscriber_1.SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray([], __read(args2)))).subscribe(onSubscriber);
  }
  return share;
}
var shareReplay = {};
var hasRequiredShareReplay;
function requireShareReplay() {
  if (hasRequiredShareReplay) return shareReplay;
  hasRequiredShareReplay = 1;
  Object.defineProperty(shareReplay, "__esModule", { value: true });
  shareReplay.shareReplay = void 0;
  var ReplaySubject_1 = /* @__PURE__ */ requireReplaySubject();
  var share_1 = /* @__PURE__ */ requireShare();
  function shareReplay$1(configOrBufferSize, windowTime2, scheduler) {
    var _a, _b, _c;
    var bufferSize;
    var refCount2 = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
    }
    return share_1.share({
      connector: function() {
        return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime2, scheduler);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount2
    });
  }
  shareReplay.shareReplay = shareReplay$1;
  return shareReplay;
}
var single = {};
var hasRequiredSingle;
function requireSingle() {
  if (hasRequiredSingle) return single;
  hasRequiredSingle = 1;
  Object.defineProperty(single, "__esModule", { value: true });
  single.single = void 0;
  var EmptyError_1 = /* @__PURE__ */ requireEmptyError();
  var SequenceError_1 = /* @__PURE__ */ requireSequenceError();
  var NotFoundError_1 = /* @__PURE__ */ requireNotFoundError();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function single$1(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var singleValue;
      var seenValue = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        seenValue = true;
        if (!predicate || predicate(value, index++, source)) {
          hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
          hasValue = true;
          singleValue = value;
        }
      }, function() {
        if (hasValue) {
          subscriber.next(singleValue);
          subscriber.complete();
        } else {
          subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
        }
      }));
    });
  }
  single.single = single$1;
  return single;
}
var skip = {};
var hasRequiredSkip;
function requireSkip() {
  if (hasRequiredSkip) return skip;
  hasRequiredSkip = 1;
  Object.defineProperty(skip, "__esModule", { value: true });
  skip.skip = void 0;
  var filter_1 = /* @__PURE__ */ requireFilter();
  function skip$1(count2) {
    return filter_1.filter(function(_, index) {
      return count2 <= index;
    });
  }
  skip.skip = skip$1;
  return skip;
}
var skipLast = {};
var hasRequiredSkipLast;
function requireSkipLast() {
  if (hasRequiredSkipLast) return skipLast;
  hasRequiredSkipLast = 1;
  Object.defineProperty(skipLast, "__esModule", { value: true });
  skipLast.skipLast = void 0;
  var identity_1 = /* @__PURE__ */ requireIdentity();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function skipLast$1(skipCount) {
    return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var ring = new Array(skipCount);
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var valueIndex = seen++;
        if (valueIndex < skipCount) {
          ring[valueIndex] = value;
        } else {
          var index = valueIndex % skipCount;
          var oldValue = ring[index];
          ring[index] = value;
          subscriber.next(oldValue);
        }
      }));
      return function() {
        ring = null;
      };
    });
  }
  skipLast.skipLast = skipLast$1;
  return skipLast;
}
var skipUntil = {};
var hasRequiredSkipUntil;
function requireSkipUntil() {
  if (hasRequiredSkipUntil) return skipUntil;
  hasRequiredSkipUntil = 1;
  Object.defineProperty(skipUntil, "__esModule", { value: true });
  skipUntil.skipUntil = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var noop_1 = /* @__PURE__ */ requireNoop();
  function skipUntil$1(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
        taking = true;
      }, noop_1.noop);
      innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return taking && subscriber.next(value);
      }));
    });
  }
  skipUntil.skipUntil = skipUntil$1;
  return skipUntil;
}
var skipWhile = {};
var hasRequiredSkipWhile;
function requireSkipWhile() {
  if (hasRequiredSkipWhile) return skipWhile;
  hasRequiredSkipWhile = 1;
  Object.defineProperty(skipWhile, "__esModule", { value: true });
  skipWhile.skipWhile = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function skipWhile$1(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
      }));
    });
  }
  skipWhile.skipWhile = skipWhile$1;
  return skipWhile;
}
var startWith = {};
var hasRequiredStartWith;
function requireStartWith() {
  if (hasRequiredStartWith) return startWith;
  hasRequiredStartWith = 1;
  Object.defineProperty(startWith, "__esModule", { value: true });
  startWith.startWith = void 0;
  var concat_1 = /* @__PURE__ */ requireConcat$1();
  var args_1 = /* @__PURE__ */ requireArgs();
  var lift_1 = /* @__PURE__ */ requireLift();
  function startWith$1() {
    var values2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values2[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(values2);
    return lift_1.operate(function(source, subscriber) {
      (scheduler ? concat_1.concat(values2, source, scheduler) : concat_1.concat(values2, source)).subscribe(subscriber);
    });
  }
  startWith.startWith = startWith$1;
  return startWith;
}
var switchAll = {};
var switchMap = {};
var hasRequiredSwitchMap;
function requireSwitchMap() {
  if (hasRequiredSwitchMap) return switchMap;
  hasRequiredSwitchMap = 1;
  Object.defineProperty(switchMap, "__esModule", { value: true });
  switchMap.switchMap = void 0;
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function switchMap$1(project, resultSelector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }
  switchMap.switchMap = switchMap$1;
  return switchMap;
}
var hasRequiredSwitchAll;
function requireSwitchAll() {
  if (hasRequiredSwitchAll) return switchAll;
  hasRequiredSwitchAll = 1;
  Object.defineProperty(switchAll, "__esModule", { value: true });
  switchAll.switchAll = void 0;
  var switchMap_1 = /* @__PURE__ */ requireSwitchMap();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  function switchAll$1() {
    return switchMap_1.switchMap(identity_1.identity);
  }
  switchAll.switchAll = switchAll$1;
  return switchAll;
}
var switchMapTo = {};
var hasRequiredSwitchMapTo;
function requireSwitchMapTo() {
  if (hasRequiredSwitchMapTo) return switchMapTo;
  hasRequiredSwitchMapTo = 1;
  Object.defineProperty(switchMapTo, "__esModule", { value: true });
  switchMapTo.switchMapTo = void 0;
  var switchMap_1 = /* @__PURE__ */ requireSwitchMap();
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  function switchMapTo$1(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
      return innerObservable;
    }, resultSelector) : switchMap_1.switchMap(function() {
      return innerObservable;
    });
  }
  switchMapTo.switchMapTo = switchMapTo$1;
  return switchMapTo;
}
var switchScan = {};
var hasRequiredSwitchScan;
function requireSwitchScan() {
  if (hasRequiredSwitchScan) return switchScan;
  hasRequiredSwitchScan = 1;
  Object.defineProperty(switchScan, "__esModule", { value: true });
  switchScan.switchScan = void 0;
  var switchMap_1 = /* @__PURE__ */ requireSwitchMap();
  var lift_1 = /* @__PURE__ */ requireLift();
  function switchScan$1(accumulator, seed) {
    return lift_1.operate(function(source, subscriber) {
      var state2 = seed;
      switchMap_1.switchMap(function(value, index) {
        return accumulator(state2, value, index);
      }, function(_, innerValue) {
        return state2 = innerValue, innerValue;
      })(source).subscribe(subscriber);
      return function() {
        state2 = null;
      };
    });
  }
  switchScan.switchScan = switchScan$1;
  return switchScan;
}
var takeUntil = {};
var hasRequiredTakeUntil;
function requireTakeUntil() {
  if (hasRequiredTakeUntil) return takeUntil;
  hasRequiredTakeUntil = 1;
  Object.defineProperty(takeUntil, "__esModule", { value: true });
  takeUntil.takeUntil = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var noop_1 = /* @__PURE__ */ requireNoop();
  function takeUntil$1(notifier) {
    return lift_1.operate(function(source, subscriber) {
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop_1.noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }
  takeUntil.takeUntil = takeUntil$1;
  return takeUntil;
}
var takeWhile = {};
var hasRequiredTakeWhile;
function requireTakeWhile() {
  if (hasRequiredTakeWhile) return takeWhile;
  hasRequiredTakeWhile = 1;
  Object.defineProperty(takeWhile, "__esModule", { value: true });
  takeWhile.takeWhile = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function takeWhile$1(predicate, inclusive) {
    if (inclusive === void 0) {
      inclusive = false;
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var result = predicate(value, index++);
        (result || inclusive) && subscriber.next(value);
        !result && subscriber.complete();
      }));
    });
  }
  takeWhile.takeWhile = takeWhile$1;
  return takeWhile;
}
var tap = {};
var hasRequiredTap;
function requireTap() {
  if (hasRequiredTap) return tap;
  hasRequiredTap = 1;
  Object.defineProperty(tap, "__esModule", { value: true });
  tap.tap = void 0;
  var isFunction_1 = /* @__PURE__ */ requireIsFunction();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  function tap$1(observerOrNext, error2, complete) {
    var tapObserver = isFunction_1.isFunction(observerOrNext) || error2 || complete ? { next: observerOrNext, error: error2, complete } : observerOrNext;
    return tapObserver ? lift_1.operate(function(source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity_1.identity;
  }
  tap.tap = tap$1;
  return tap;
}
var throttle = {};
var hasRequiredThrottle;
function requireThrottle() {
  if (hasRequiredThrottle) return throttle;
  hasRequiredThrottle = 1;
  Object.defineProperty(throttle, "__esModule", { value: true });
  throttle.throttle = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function throttle$1(durationSelector, config2) {
    return lift_1.operate(function(source, subscriber) {
      var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value) {
        return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send = function() {
        if (hasValue) {
          hasValue = false;
          var value = sendValue;
          sendValue = null;
          subscriber.next(value);
          !isComplete && startThrottle(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        sendValue = value;
        !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  }
  throttle.throttle = throttle$1;
  return throttle;
}
var throttleTime = {};
var hasRequiredThrottleTime;
function requireThrottleTime() {
  if (hasRequiredThrottleTime) return throttleTime;
  hasRequiredThrottleTime = 1;
  Object.defineProperty(throttleTime, "__esModule", { value: true });
  throttleTime.throttleTime = void 0;
  var async_12 = /* @__PURE__ */ requireAsync();
  var throttle_1 = /* @__PURE__ */ requireThrottle();
  var timer_1 = /* @__PURE__ */ requireTimer();
  function throttleTime$1(duration, scheduler, config2) {
    if (scheduler === void 0) {
      scheduler = async_12.asyncScheduler;
    }
    var duration$ = timer_1.timer(duration, scheduler);
    return throttle_1.throttle(function() {
      return duration$;
    }, config2);
  }
  throttleTime.throttleTime = throttleTime$1;
  return throttleTime;
}
var timeInterval = {};
var hasRequiredTimeInterval;
function requireTimeInterval() {
  if (hasRequiredTimeInterval) return timeInterval;
  hasRequiredTimeInterval = 1;
  Object.defineProperty(timeInterval, "__esModule", { value: true });
  timeInterval.TimeInterval = timeInterval.timeInterval = void 0;
  var async_12 = /* @__PURE__ */ requireAsync();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function timeInterval$1(scheduler) {
    if (scheduler === void 0) {
      scheduler = async_12.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var last2 = scheduler.now();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var now = scheduler.now();
        var interval2 = now - last2;
        last2 = now;
        subscriber.next(new TimeInterval(value, interval2));
      }));
    });
  }
  timeInterval.timeInterval = timeInterval$1;
  var TimeInterval = /* @__PURE__ */ function() {
    function TimeInterval2(value, interval2) {
      this.value = value;
      this.interval = interval2;
    }
    return TimeInterval2;
  }();
  timeInterval.TimeInterval = TimeInterval;
  return timeInterval;
}
var timeoutWith = {};
var hasRequiredTimeoutWith;
function requireTimeoutWith() {
  if (hasRequiredTimeoutWith) return timeoutWith;
  hasRequiredTimeoutWith = 1;
  Object.defineProperty(timeoutWith, "__esModule", { value: true });
  timeoutWith.timeoutWith = void 0;
  var async_12 = /* @__PURE__ */ requireAsync();
  var isDate_1 = /* @__PURE__ */ requireIsDate();
  var timeout_1 = /* @__PURE__ */ requireTimeout();
  function timeoutWith$1(due, withObservable, scheduler) {
    var first2;
    var each;
    var _with;
    scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_12.async;
    if (isDate_1.isValidDate(due)) {
      first2 = due;
    } else if (typeof due === "number") {
      each = due;
    }
    if (withObservable) {
      _with = function() {
        return withObservable;
      };
    } else {
      throw new TypeError("No observable provided to switch to");
    }
    if (first2 == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return timeout_1.timeout({
      first: first2,
      each,
      scheduler,
      with: _with
    });
  }
  timeoutWith.timeoutWith = timeoutWith$1;
  return timeoutWith;
}
var timestamp = {};
var hasRequiredTimestamp;
function requireTimestamp() {
  if (hasRequiredTimestamp) return timestamp;
  hasRequiredTimestamp = 1;
  Object.defineProperty(timestamp, "__esModule", { value: true });
  timestamp.timestamp = void 0;
  var dateTimestampProvider_1 = /* @__PURE__ */ requireDateTimestampProvider();
  var map_1 = /* @__PURE__ */ requireMap();
  function timestamp$1(timestampProvider) {
    if (timestampProvider === void 0) {
      timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
    }
    return map_1.map(function(value) {
      return { value, timestamp: timestampProvider.now() };
    });
  }
  timestamp.timestamp = timestamp$1;
  return timestamp;
}
var window$1 = {};
var hasRequiredWindow;
function requireWindow() {
  if (hasRequiredWindow) return window$1;
  hasRequiredWindow = 1;
  Object.defineProperty(window$1, "__esModule", { value: true });
  window$1.window = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function window2(windowBoundaries) {
    return lift_1.operate(function(source, subscriber) {
      var windowSubject = new Subject_1.Subject();
      subscriber.next(windowSubject.asObservable());
      var errorHandler = function(err) {
        windowSubject.error(err);
        subscriber.error(err);
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
      }, function() {
        windowSubject.complete();
        subscriber.complete();
      }, errorHandler));
      innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        windowSubject.complete();
        subscriber.next(windowSubject = new Subject_1.Subject());
      }, noop_1.noop, errorHandler));
      return function() {
        windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
        windowSubject = null;
      };
    });
  }
  window$1.window = window2;
  return window$1;
}
var windowCount = {};
var hasRequiredWindowCount;
function requireWindowCount() {
  if (hasRequiredWindowCount) return windowCount;
  hasRequiredWindowCount = 1;
  var __values = windowCount && windowCount.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(windowCount, "__esModule", { value: true });
  windowCount.windowCount = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  function windowCount$1(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) {
      startWindowEvery = 0;
    }
    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return lift_1.operate(function(source, subscriber) {
      var windows = [new Subject_1.Subject()];
      var count2 = 0;
      subscriber.next(windows[0].asObservable());
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        try {
          for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
            var window_1 = windows_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        var c = count2 - windowSize + 1;
        if (c >= 0 && c % startEvery === 0) {
          windows.shift().complete();
        }
        if (++count2 % startEvery === 0) {
          var window_2 = new Subject_1.Subject();
          windows.push(window_2);
          subscriber.next(window_2.asObservable());
        }
      }, function() {
        while (windows.length > 0) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, function(err) {
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      }, function() {
        windows = null;
      }));
    });
  }
  windowCount.windowCount = windowCount$1;
  return windowCount;
}
var windowTime = {};
var hasRequiredWindowTime;
function requireWindowTime() {
  if (hasRequiredWindowTime) return windowTime;
  hasRequiredWindowTime = 1;
  Object.defineProperty(windowTime, "__esModule", { value: true });
  windowTime.windowTime = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var async_12 = /* @__PURE__ */ requireAsync();
  var Subscription_1 = /* @__PURE__ */ requireSubscription();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var arrRemove_1 = /* @__PURE__ */ requireArrRemove();
  var args_1 = /* @__PURE__ */ requireArgs();
  var executeSchedule_1 = /* @__PURE__ */ requireExecuteSchedule();
  function windowTime$1(windowTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_12.asyncScheduler;
    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
    var maxWindowSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var windowRecords = [];
      var restartOnClose = false;
      var closeWindow = function(record) {
        var window2 = record.window, subs = record.subs;
        window2.complete();
        subs.unsubscribe();
        arrRemove_1.arrRemove(windowRecords, record);
        restartOnClose && startWindow();
      };
      var startWindow = function() {
        if (windowRecords) {
          var subs = new Subscription_1.Subscription();
          subscriber.add(subs);
          var window_1 = new Subject_1.Subject();
          var record_1 = {
            window: window_1,
            subs,
            seen: 0
          };
          windowRecords.push(record_1);
          subscriber.next(window_1.asObservable());
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return closeWindow(record_1);
          }, windowTimeSpan);
        }
      };
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
      } else {
        restartOnClose = true;
      }
      startWindow();
      var loop = function(cb) {
        return windowRecords.slice().forEach(cb);
      };
      var terminate = function(cb) {
        loop(function(_a2) {
          var window2 = _a2.window;
          return cb(window2);
        });
        cb(subscriber);
        subscriber.unsubscribe();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        loop(function(record) {
          record.window.next(value);
          maxWindowSize <= ++record.seen && closeWindow(record);
        });
      }, function() {
        return terminate(function(consumer) {
          return consumer.complete();
        });
      }, function(err) {
        return terminate(function(consumer) {
          return consumer.error(err);
        });
      }));
      return function() {
        windowRecords = null;
      };
    });
  }
  windowTime.windowTime = windowTime$1;
  return windowTime;
}
var windowToggle = {};
var hasRequiredWindowToggle;
function requireWindowToggle() {
  if (hasRequiredWindowToggle) return windowToggle;
  hasRequiredWindowToggle = 1;
  var __values = windowToggle && windowToggle.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(windowToggle, "__esModule", { value: true });
  windowToggle.windowToggle = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var Subscription_1 = /* @__PURE__ */ requireSubscription();
  var lift_1 = /* @__PURE__ */ requireLift();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var arrRemove_1 = /* @__PURE__ */ requireArrRemove();
  function windowToggle$1(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var windows = [];
      var handleError = function(err) {
        while (0 < windows.length) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      };
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var window2 = new Subject_1.Subject();
        windows.push(window2);
        var closingSubscription = new Subscription_1.Subscription();
        var closeWindow = function() {
          arrRemove_1.arrRemove(windows, window2);
          window2.complete();
          closingSubscription.unsubscribe();
        };
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
        } catch (err) {
          handleError(err);
          return;
        }
        subscriber.next(window2.asObservable());
        closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        var windowsCopy = windows.slice();
        try {
          for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
            var window_1 = windowsCopy_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }, function() {
        while (0 < windows.length) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, handleError, function() {
        while (0 < windows.length) {
          windows.shift().unsubscribe();
        }
      }));
    });
  }
  windowToggle.windowToggle = windowToggle$1;
  return windowToggle;
}
var windowWhen = {};
var hasRequiredWindowWhen;
function requireWindowWhen() {
  if (hasRequiredWindowWhen) return windowWhen;
  hasRequiredWindowWhen = 1;
  Object.defineProperty(windowWhen, "__esModule", { value: true });
  windowWhen.windowWhen = void 0;
  var Subject_1 = /* @__PURE__ */ requireSubject();
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  function windowWhen$1(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var window2;
      var closingSubscriber;
      var handleError = function(err) {
        window2.error(err);
        subscriber.error(err);
      };
      var openWindow = function() {
        closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
        window2 === null || window2 === void 0 ? void 0 : window2.complete();
        window2 = new Subject_1.Subject();
        subscriber.next(window2.asObservable());
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector());
        } catch (err) {
          handleError(err);
          return;
        }
        closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
      };
      openWindow();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return window2.next(value);
      }, function() {
        window2.complete();
        subscriber.complete();
      }, handleError, function() {
        closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
        window2 = null;
      }));
    });
  }
  windowWhen.windowWhen = windowWhen$1;
  return windowWhen;
}
var withLatestFrom = {};
var hasRequiredWithLatestFrom;
function requireWithLatestFrom() {
  if (hasRequiredWithLatestFrom) return withLatestFrom;
  hasRequiredWithLatestFrom = 1;
  var __read = withLatestFrom && withLatestFrom.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = withLatestFrom && withLatestFrom.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(withLatestFrom, "__esModule", { value: true });
  withLatestFrom.withLatestFrom = void 0;
  var lift_1 = /* @__PURE__ */ requireLift();
  var OperatorSubscriber_1 = /* @__PURE__ */ requireOperatorSubscriber();
  var innerFrom_1 = /* @__PURE__ */ requireInnerFrom();
  var identity_1 = /* @__PURE__ */ requireIdentity();
  var noop_1 = /* @__PURE__ */ requireNoop();
  var args_1 = /* @__PURE__ */ requireArgs();
  function withLatestFrom$1() {
    var inputs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }
    var project = args_1.popResultSelector(inputs);
    return lift_1.operate(function(source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i2) {
        innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          otherValues[i2] = value;
          if (!ready && !hasValue[i2]) {
            hasValue[i2] = true;
            (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
          }
        }, noop_1.noop));
      };
      for (var i = 0; i < len; i++) {
        _loop_1(i);
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (ready) {
          var values2 = __spreadArray([value], __read(otherValues));
          subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values2))) : values2);
        }
      }));
    });
  }
  withLatestFrom.withLatestFrom = withLatestFrom$1;
  return withLatestFrom;
}
var zipAll = {};
var hasRequiredZipAll;
function requireZipAll() {
  if (hasRequiredZipAll) return zipAll;
  hasRequiredZipAll = 1;
  Object.defineProperty(zipAll, "__esModule", { value: true });
  zipAll.zipAll = void 0;
  var zip_1 = /* @__PURE__ */ requireZip$1();
  var joinAllInternals_1 = /* @__PURE__ */ requireJoinAllInternals();
  function zipAll$1(project) {
    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
  }
  zipAll.zipAll = zipAll$1;
  return zipAll;
}
var zipWith = {};
var zip = {};
var hasRequiredZip;
function requireZip() {
  if (hasRequiredZip) return zip;
  hasRequiredZip = 1;
  var __read = zip && zip.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = zip && zip.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(zip, "__esModule", { value: true });
  zip.zip = void 0;
  var zip_1 = /* @__PURE__ */ requireZip$1();
  var lift_1 = /* @__PURE__ */ requireLift();
  function zip$12() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return lift_1.operate(function(source, subscriber) {
      zip_1.zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
    });
  }
  zip.zip = zip$12;
  return zip;
}
var hasRequiredZipWith;
function requireZipWith() {
  if (hasRequiredZipWith) return zipWith;
  hasRequiredZipWith = 1;
  var __read = zipWith && zipWith.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = zipWith && zipWith.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(zipWith, "__esModule", { value: true });
  zipWith.zipWith = void 0;
  var zip_1 = /* @__PURE__ */ requireZip();
  function zipWith$1() {
    var otherInputs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherInputs[_i] = arguments[_i];
    }
    return zip_1.zip.apply(void 0, __spreadArray([], __read(otherInputs)));
  }
  zipWith.zipWith = zipWith$1;
  return zipWith;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  (function(exports2) {
    var __createBinding = cjs && cjs.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = cjs && cjs.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interval = exports2.iif = exports2.generate = exports2.fromEventPattern = exports2.fromEvent = exports2.from = exports2.forkJoin = exports2.empty = exports2.defer = exports2.connectable = exports2.concat = exports2.combineLatest = exports2.bindNodeCallback = exports2.bindCallback = exports2.UnsubscriptionError = exports2.TimeoutError = exports2.SequenceError = exports2.ObjectUnsubscribedError = exports2.NotFoundError = exports2.EmptyError = exports2.ArgumentOutOfRangeError = exports2.firstValueFrom = exports2.lastValueFrom = exports2.isObservable = exports2.identity = exports2.noop = exports2.pipe = exports2.NotificationKind = exports2.Notification = exports2.Subscriber = exports2.Subscription = exports2.Scheduler = exports2.VirtualAction = exports2.VirtualTimeScheduler = exports2.animationFrameScheduler = exports2.animationFrame = exports2.queueScheduler = exports2.queue = exports2.asyncScheduler = exports2.async = exports2.asapScheduler = exports2.asap = exports2.AsyncSubject = exports2.ReplaySubject = exports2.BehaviorSubject = exports2.Subject = exports2.animationFrames = exports2.observable = exports2.ConnectableObservable = exports2.Observable = void 0;
    exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.combineLatestWith = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = exports2.config = exports2.NEVER = exports2.EMPTY = exports2.scheduled = exports2.zip = exports2.using = exports2.timer = exports2.throwError = exports2.range = exports2.race = exports2.partition = exports2.pairs = exports2.onErrorResumeNext = exports2.of = exports2.never = exports2.merge = void 0;
    exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.pairwise = exports2.onErrorResumeNextWith = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = exports2.mergeAll = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = void 0;
    exports2.zipWith = exports2.zipAll = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = void 0;
    var Observable_1 = /* @__PURE__ */ requireObservable();
    Object.defineProperty(exports2, "Observable", { enumerable: true, get: function() {
      return Observable_1.Observable;
    } });
    var ConnectableObservable_1 = /* @__PURE__ */ requireConnectableObservable();
    Object.defineProperty(exports2, "ConnectableObservable", { enumerable: true, get: function() {
      return ConnectableObservable_1.ConnectableObservable;
    } });
    var observable_1 = /* @__PURE__ */ requireObservable$1();
    Object.defineProperty(exports2, "observable", { enumerable: true, get: function() {
      return observable_1.observable;
    } });
    var animationFrames_1 = /* @__PURE__ */ requireAnimationFrames();
    Object.defineProperty(exports2, "animationFrames", { enumerable: true, get: function() {
      return animationFrames_1.animationFrames;
    } });
    var Subject_1 = /* @__PURE__ */ requireSubject();
    Object.defineProperty(exports2, "Subject", { enumerable: true, get: function() {
      return Subject_1.Subject;
    } });
    var BehaviorSubject_1 = /* @__PURE__ */ requireBehaviorSubject();
    Object.defineProperty(exports2, "BehaviorSubject", { enumerable: true, get: function() {
      return BehaviorSubject_1.BehaviorSubject;
    } });
    var ReplaySubject_1 = /* @__PURE__ */ requireReplaySubject();
    Object.defineProperty(exports2, "ReplaySubject", { enumerable: true, get: function() {
      return ReplaySubject_1.ReplaySubject;
    } });
    var AsyncSubject_1 = /* @__PURE__ */ requireAsyncSubject();
    Object.defineProperty(exports2, "AsyncSubject", { enumerable: true, get: function() {
      return AsyncSubject_1.AsyncSubject;
    } });
    var asap_1 = /* @__PURE__ */ requireAsap();
    Object.defineProperty(exports2, "asap", { enumerable: true, get: function() {
      return asap_1.asap;
    } });
    Object.defineProperty(exports2, "asapScheduler", { enumerable: true, get: function() {
      return asap_1.asapScheduler;
    } });
    var async_12 = /* @__PURE__ */ requireAsync();
    Object.defineProperty(exports2, "async", { enumerable: true, get: function() {
      return async_12.async;
    } });
    Object.defineProperty(exports2, "asyncScheduler", { enumerable: true, get: function() {
      return async_12.asyncScheduler;
    } });
    var queue_1 = /* @__PURE__ */ requireQueue();
    Object.defineProperty(exports2, "queue", { enumerable: true, get: function() {
      return queue_1.queue;
    } });
    Object.defineProperty(exports2, "queueScheduler", { enumerable: true, get: function() {
      return queue_1.queueScheduler;
    } });
    var animationFrame_1 = /* @__PURE__ */ requireAnimationFrame();
    Object.defineProperty(exports2, "animationFrame", { enumerable: true, get: function() {
      return animationFrame_1.animationFrame;
    } });
    Object.defineProperty(exports2, "animationFrameScheduler", { enumerable: true, get: function() {
      return animationFrame_1.animationFrameScheduler;
    } });
    var VirtualTimeScheduler_1 = /* @__PURE__ */ requireVirtualTimeScheduler();
    Object.defineProperty(exports2, "VirtualTimeScheduler", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualTimeScheduler;
    } });
    Object.defineProperty(exports2, "VirtualAction", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualAction;
    } });
    var Scheduler_1 = /* @__PURE__ */ requireScheduler();
    Object.defineProperty(exports2, "Scheduler", { enumerable: true, get: function() {
      return Scheduler_1.Scheduler;
    } });
    var Subscription_1 = /* @__PURE__ */ requireSubscription();
    Object.defineProperty(exports2, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
    var Subscriber_1 = /* @__PURE__ */ requireSubscriber();
    Object.defineProperty(exports2, "Subscriber", { enumerable: true, get: function() {
      return Subscriber_1.Subscriber;
    } });
    var Notification_1 = /* @__PURE__ */ requireNotification();
    Object.defineProperty(exports2, "Notification", { enumerable: true, get: function() {
      return Notification_1.Notification;
    } });
    Object.defineProperty(exports2, "NotificationKind", { enumerable: true, get: function() {
      return Notification_1.NotificationKind;
    } });
    var pipe_1 = /* @__PURE__ */ requirePipe();
    Object.defineProperty(exports2, "pipe", { enumerable: true, get: function() {
      return pipe_1.pipe;
    } });
    var noop_1 = /* @__PURE__ */ requireNoop();
    Object.defineProperty(exports2, "noop", { enumerable: true, get: function() {
      return noop_1.noop;
    } });
    var identity_1 = /* @__PURE__ */ requireIdentity();
    Object.defineProperty(exports2, "identity", { enumerable: true, get: function() {
      return identity_1.identity;
    } });
    var isObservable_1 = /* @__PURE__ */ requireIsObservable();
    Object.defineProperty(exports2, "isObservable", { enumerable: true, get: function() {
      return isObservable_1.isObservable;
    } });
    var lastValueFrom_1 = /* @__PURE__ */ requireLastValueFrom();
    Object.defineProperty(exports2, "lastValueFrom", { enumerable: true, get: function() {
      return lastValueFrom_1.lastValueFrom;
    } });
    var firstValueFrom_1 = /* @__PURE__ */ requireFirstValueFrom();
    Object.defineProperty(exports2, "firstValueFrom", { enumerable: true, get: function() {
      return firstValueFrom_1.firstValueFrom;
    } });
    var ArgumentOutOfRangeError_1 = /* @__PURE__ */ requireArgumentOutOfRangeError();
    Object.defineProperty(exports2, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    } });
    var EmptyError_1 = /* @__PURE__ */ requireEmptyError();
    Object.defineProperty(exports2, "EmptyError", { enumerable: true, get: function() {
      return EmptyError_1.EmptyError;
    } });
    var NotFoundError_1 = /* @__PURE__ */ requireNotFoundError();
    Object.defineProperty(exports2, "NotFoundError", { enumerable: true, get: function() {
      return NotFoundError_1.NotFoundError;
    } });
    var ObjectUnsubscribedError_1 = /* @__PURE__ */ requireObjectUnsubscribedError();
    Object.defineProperty(exports2, "ObjectUnsubscribedError", { enumerable: true, get: function() {
      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    } });
    var SequenceError_1 = /* @__PURE__ */ requireSequenceError();
    Object.defineProperty(exports2, "SequenceError", { enumerable: true, get: function() {
      return SequenceError_1.SequenceError;
    } });
    var timeout_1 = /* @__PURE__ */ requireTimeout();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    var UnsubscriptionError_1 = /* @__PURE__ */ requireUnsubscriptionError();
    Object.defineProperty(exports2, "UnsubscriptionError", { enumerable: true, get: function() {
      return UnsubscriptionError_1.UnsubscriptionError;
    } });
    var bindCallback_1 = /* @__PURE__ */ requireBindCallback();
    Object.defineProperty(exports2, "bindCallback", { enumerable: true, get: function() {
      return bindCallback_1.bindCallback;
    } });
    var bindNodeCallback_1 = /* @__PURE__ */ requireBindNodeCallback();
    Object.defineProperty(exports2, "bindNodeCallback", { enumerable: true, get: function() {
      return bindNodeCallback_1.bindNodeCallback;
    } });
    var combineLatest_1 = /* @__PURE__ */ requireCombineLatest$1();
    Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var concat_1 = /* @__PURE__ */ requireConcat$1();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var connectable_1 = /* @__PURE__ */ requireConnectable();
    Object.defineProperty(exports2, "connectable", { enumerable: true, get: function() {
      return connectable_1.connectable;
    } });
    var defer_12 = /* @__PURE__ */ requireDefer();
    Object.defineProperty(exports2, "defer", { enumerable: true, get: function() {
      return defer_12.defer;
    } });
    var empty_1 = /* @__PURE__ */ requireEmpty();
    Object.defineProperty(exports2, "empty", { enumerable: true, get: function() {
      return empty_1.empty;
    } });
    var forkJoin_1 = /* @__PURE__ */ requireForkJoin();
    Object.defineProperty(exports2, "forkJoin", { enumerable: true, get: function() {
      return forkJoin_1.forkJoin;
    } });
    var from_1 = /* @__PURE__ */ requireFrom();
    Object.defineProperty(exports2, "from", { enumerable: true, get: function() {
      return from_1.from;
    } });
    var fromEvent_1 = /* @__PURE__ */ requireFromEvent();
    Object.defineProperty(exports2, "fromEvent", { enumerable: true, get: function() {
      return fromEvent_1.fromEvent;
    } });
    var fromEventPattern_1 = /* @__PURE__ */ requireFromEventPattern();
    Object.defineProperty(exports2, "fromEventPattern", { enumerable: true, get: function() {
      return fromEventPattern_1.fromEventPattern;
    } });
    var generate_1 = /* @__PURE__ */ requireGenerate();
    Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
      return generate_1.generate;
    } });
    var iif_1 = /* @__PURE__ */ requireIif();
    Object.defineProperty(exports2, "iif", { enumerable: true, get: function() {
      return iif_1.iif;
    } });
    var interval_1 = /* @__PURE__ */ requireInterval();
    Object.defineProperty(exports2, "interval", { enumerable: true, get: function() {
      return interval_1.interval;
    } });
    var merge_1 = /* @__PURE__ */ requireMerge$1();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var never_1 = /* @__PURE__ */ requireNever();
    Object.defineProperty(exports2, "never", { enumerable: true, get: function() {
      return never_1.never;
    } });
    var of_1 = /* @__PURE__ */ requireOf();
    Object.defineProperty(exports2, "of", { enumerable: true, get: function() {
      return of_1.of;
    } });
    var onErrorResumeNext_1 = /* @__PURE__ */ requireOnErrorResumeNext();
    Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNext_1.onErrorResumeNext;
    } });
    var pairs_1 = /* @__PURE__ */ requirePairs();
    Object.defineProperty(exports2, "pairs", { enumerable: true, get: function() {
      return pairs_1.pairs;
    } });
    var partition_1 = /* @__PURE__ */ requirePartition$1();
    Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var race_1 = /* @__PURE__ */ requireRace$1();
    Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var range_1 = /* @__PURE__ */ requireRange();
    Object.defineProperty(exports2, "range", { enumerable: true, get: function() {
      return range_1.range;
    } });
    var throwError_1 = /* @__PURE__ */ requireThrowError();
    Object.defineProperty(exports2, "throwError", { enumerable: true, get: function() {
      return throwError_1.throwError;
    } });
    var timer_1 = /* @__PURE__ */ requireTimer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var using_1 = /* @__PURE__ */ requireUsing();
    Object.defineProperty(exports2, "using", { enumerable: true, get: function() {
      return using_1.using;
    } });
    var zip_1 = /* @__PURE__ */ requireZip$1();
    Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var scheduled_1 = /* @__PURE__ */ requireScheduled();
    Object.defineProperty(exports2, "scheduled", { enumerable: true, get: function() {
      return scheduled_1.scheduled;
    } });
    var empty_2 = /* @__PURE__ */ requireEmpty();
    Object.defineProperty(exports2, "EMPTY", { enumerable: true, get: function() {
      return empty_2.EMPTY;
    } });
    var never_2 = /* @__PURE__ */ requireNever();
    Object.defineProperty(exports2, "NEVER", { enumerable: true, get: function() {
      return never_2.NEVER;
    } });
    __exportStar(/* @__PURE__ */ requireTypes(), exports2);
    var config_1 = /* @__PURE__ */ requireConfig();
    Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    var audit_1 = /* @__PURE__ */ requireAudit();
    Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = /* @__PURE__ */ requireAuditTime();
    Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = /* @__PURE__ */ requireBuffer();
    Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = /* @__PURE__ */ requireBufferCount();
    Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = /* @__PURE__ */ requireBufferTime();
    Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = /* @__PURE__ */ requireBufferToggle();
    Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = /* @__PURE__ */ requireBufferWhen();
    Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = /* @__PURE__ */ requireCatchError();
    Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = /* @__PURE__ */ requireCombineAll();
    Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = /* @__PURE__ */ requireCombineLatestAll();
    Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatestWith_1 = /* @__PURE__ */ requireCombineLatestWith();
    Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concatAll_1 = /* @__PURE__ */ requireConcatAll();
    Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = /* @__PURE__ */ requireConcatMap();
    Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = /* @__PURE__ */ requireConcatMapTo();
    Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = /* @__PURE__ */ requireConcatWith();
    Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = /* @__PURE__ */ requireConnect();
    Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = /* @__PURE__ */ requireCount();
    Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = /* @__PURE__ */ requireDebounce();
    Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = /* @__PURE__ */ requireDebounceTime();
    Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = /* @__PURE__ */ requireDefaultIfEmpty();
    Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = /* @__PURE__ */ requireDelay();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = /* @__PURE__ */ requireDelayWhen();
    Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = /* @__PURE__ */ requireDematerialize();
    Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = /* @__PURE__ */ requireDistinct();
    Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = /* @__PURE__ */ requireDistinctUntilChanged();
    Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = /* @__PURE__ */ requireDistinctUntilKeyChanged();
    Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = /* @__PURE__ */ requireElementAt();
    Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = /* @__PURE__ */ requireEndWith();
    Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = /* @__PURE__ */ requireEvery();
    Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = /* @__PURE__ */ requireExhaust();
    Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = /* @__PURE__ */ requireExhaustAll();
    Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = /* @__PURE__ */ requireExhaustMap();
    Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = /* @__PURE__ */ requireExpand();
    Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = /* @__PURE__ */ requireFilter();
    Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = /* @__PURE__ */ requireFinalize();
    Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = /* @__PURE__ */ requireFind();
    Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = /* @__PURE__ */ requireFindIndex();
    Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = /* @__PURE__ */ requireFirst();
    Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = /* @__PURE__ */ requireGroupBy();
    Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = /* @__PURE__ */ requireIgnoreElements();
    Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = /* @__PURE__ */ requireIsEmpty();
    Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = /* @__PURE__ */ requireLast();
    Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = /* @__PURE__ */ requireMap();
    Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = /* @__PURE__ */ requireMapTo();
    Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = /* @__PURE__ */ requireMaterialize();
    Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = /* @__PURE__ */ requireMax();
    Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var mergeAll_1 = /* @__PURE__ */ requireMergeAll();
    Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = /* @__PURE__ */ requireFlatMap();
    Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = /* @__PURE__ */ requireMergeMap();
    Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = /* @__PURE__ */ requireMergeMapTo();
    Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = /* @__PURE__ */ requireMergeScan();
    Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = /* @__PURE__ */ requireMergeWith();
    Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = /* @__PURE__ */ requireMin();
    Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = /* @__PURE__ */ requireMulticast();
    Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = /* @__PURE__ */ requireObserveOn();
    Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = /* @__PURE__ */ requireOnErrorResumeNextWith();
    Object.defineProperty(exports2, "onErrorResumeNextWith", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNextWith;
    } });
    var pairwise_1 = /* @__PURE__ */ requirePairwise();
    Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var pluck_1 = /* @__PURE__ */ requirePluck();
    Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = /* @__PURE__ */ requirePublish();
    Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = /* @__PURE__ */ requirePublishBehavior();
    Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = /* @__PURE__ */ requirePublishLast();
    Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = /* @__PURE__ */ requirePublishReplay();
    Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var raceWith_1 = /* @__PURE__ */ requireRaceWith();
    Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = /* @__PURE__ */ requireReduce();
    Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = /* @__PURE__ */ requireRepeat();
    Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = /* @__PURE__ */ requireRepeatWhen();
    Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = /* @__PURE__ */ requireRetry();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = /* @__PURE__ */ requireRetryWhen();
    Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = /* @__PURE__ */ requireRefCount();
    Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = /* @__PURE__ */ requireSample();
    Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = /* @__PURE__ */ requireSampleTime();
    Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = /* @__PURE__ */ requireScan();
    Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = /* @__PURE__ */ requireSequenceEqual();
    Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = /* @__PURE__ */ requireShare();
    Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = /* @__PURE__ */ requireShareReplay();
    Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = /* @__PURE__ */ requireSingle();
    Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = /* @__PURE__ */ requireSkip();
    Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = /* @__PURE__ */ requireSkipLast();
    Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = /* @__PURE__ */ requireSkipUntil();
    Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = /* @__PURE__ */ requireSkipWhile();
    Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = /* @__PURE__ */ requireStartWith();
    Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = /* @__PURE__ */ requireSubscribeOn();
    Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = /* @__PURE__ */ requireSwitchAll();
    Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = /* @__PURE__ */ requireSwitchMap();
    Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = /* @__PURE__ */ requireSwitchMapTo();
    Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = /* @__PURE__ */ requireSwitchScan();
    Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = /* @__PURE__ */ requireTake();
    Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = /* @__PURE__ */ requireTakeLast();
    Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = /* @__PURE__ */ requireTakeUntil();
    Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = /* @__PURE__ */ requireTakeWhile();
    Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = /* @__PURE__ */ requireTap();
    Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = /* @__PURE__ */ requireThrottle();
    Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = /* @__PURE__ */ requireThrottleTime();
    Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = /* @__PURE__ */ requireThrowIfEmpty();
    Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = /* @__PURE__ */ requireTimeInterval();
    Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_2 = /* @__PURE__ */ requireTimeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_2.timeout;
    } });
    var timeoutWith_1 = /* @__PURE__ */ requireTimeoutWith();
    Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = /* @__PURE__ */ requireTimestamp();
    Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = /* @__PURE__ */ requireToArray();
    Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = /* @__PURE__ */ requireWindow();
    Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = /* @__PURE__ */ requireWindowCount();
    Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = /* @__PURE__ */ requireWindowTime();
    Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = /* @__PURE__ */ requireWindowToggle();
    Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = /* @__PURE__ */ requireWindowWhen();
    Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = /* @__PURE__ */ requireWithLatestFrom();
    Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zipAll_1 = /* @__PURE__ */ requireZipAll();
    Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = /* @__PURE__ */ requireZipWith();
    Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  })(cjs);
  return cjs;
}
var operators = {};
var partition = {};
var hasRequiredPartition;
function requirePartition() {
  if (hasRequiredPartition) return partition;
  hasRequiredPartition = 1;
  Object.defineProperty(partition, "__esModule", { value: true });
  partition.partition = void 0;
  var not_1 = /* @__PURE__ */ requireNot();
  var filter_1 = /* @__PURE__ */ requireFilter();
  function partition$12(predicate, thisArg) {
    return function(source) {
      return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];
    };
  }
  partition.partition = partition$12;
  return partition;
}
var race = {};
var hasRequiredRace;
function requireRace() {
  if (hasRequiredRace) return race;
  hasRequiredRace = 1;
  var __read = race && race.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = race && race.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(race, "__esModule", { value: true });
  race.race = void 0;
  var argsOrArgArray_1 = /* @__PURE__ */ requireArgsOrArgArray();
  var raceWith_1 = /* @__PURE__ */ requireRaceWith();
  function race$12() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    return raceWith_1.raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray_1.argsOrArgArray(args2))));
  }
  race.race = race$12;
  return race;
}
var hasRequiredOperators;
function requireOperators() {
  if (hasRequiredOperators) return operators;
  hasRequiredOperators = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeAll = exports2.merge = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.concat = exports2.combineLatestWith = exports2.combineLatest = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = void 0;
    exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.race = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.partition = exports2.pairwise = exports2.onErrorResumeNext = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = void 0;
    exports2.zipWith = exports2.zipAll = exports2.zip = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = void 0;
    var audit_1 = /* @__PURE__ */ requireAudit();
    Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = /* @__PURE__ */ requireAuditTime();
    Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = /* @__PURE__ */ requireBuffer();
    Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = /* @__PURE__ */ requireBufferCount();
    Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = /* @__PURE__ */ requireBufferTime();
    Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = /* @__PURE__ */ requireBufferToggle();
    Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = /* @__PURE__ */ requireBufferWhen();
    Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = /* @__PURE__ */ requireCatchError();
    Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = /* @__PURE__ */ requireCombineAll();
    Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = /* @__PURE__ */ requireCombineLatestAll();
    Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatest_1 = /* @__PURE__ */ requireCombineLatest();
    Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var combineLatestWith_1 = /* @__PURE__ */ requireCombineLatestWith();
    Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concat_1 = /* @__PURE__ */ requireConcat();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var concatAll_1 = /* @__PURE__ */ requireConcatAll();
    Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = /* @__PURE__ */ requireConcatMap();
    Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = /* @__PURE__ */ requireConcatMapTo();
    Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = /* @__PURE__ */ requireConcatWith();
    Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = /* @__PURE__ */ requireConnect();
    Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = /* @__PURE__ */ requireCount();
    Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = /* @__PURE__ */ requireDebounce();
    Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = /* @__PURE__ */ requireDebounceTime();
    Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = /* @__PURE__ */ requireDefaultIfEmpty();
    Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = /* @__PURE__ */ requireDelay();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = /* @__PURE__ */ requireDelayWhen();
    Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = /* @__PURE__ */ requireDematerialize();
    Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = /* @__PURE__ */ requireDistinct();
    Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = /* @__PURE__ */ requireDistinctUntilChanged();
    Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = /* @__PURE__ */ requireDistinctUntilKeyChanged();
    Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = /* @__PURE__ */ requireElementAt();
    Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = /* @__PURE__ */ requireEndWith();
    Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = /* @__PURE__ */ requireEvery();
    Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = /* @__PURE__ */ requireExhaust();
    Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = /* @__PURE__ */ requireExhaustAll();
    Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = /* @__PURE__ */ requireExhaustMap();
    Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = /* @__PURE__ */ requireExpand();
    Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = /* @__PURE__ */ requireFilter();
    Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = /* @__PURE__ */ requireFinalize();
    Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = /* @__PURE__ */ requireFind();
    Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = /* @__PURE__ */ requireFindIndex();
    Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = /* @__PURE__ */ requireFirst();
    Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = /* @__PURE__ */ requireGroupBy();
    Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = /* @__PURE__ */ requireIgnoreElements();
    Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = /* @__PURE__ */ requireIsEmpty();
    Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = /* @__PURE__ */ requireLast();
    Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = /* @__PURE__ */ requireMap();
    Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = /* @__PURE__ */ requireMapTo();
    Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = /* @__PURE__ */ requireMaterialize();
    Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = /* @__PURE__ */ requireMax();
    Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var merge_1 = /* @__PURE__ */ requireMerge();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var mergeAll_1 = /* @__PURE__ */ requireMergeAll();
    Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = /* @__PURE__ */ requireFlatMap();
    Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = /* @__PURE__ */ requireMergeMap();
    Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = /* @__PURE__ */ requireMergeMapTo();
    Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = /* @__PURE__ */ requireMergeScan();
    Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = /* @__PURE__ */ requireMergeWith();
    Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = /* @__PURE__ */ requireMin();
    Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = /* @__PURE__ */ requireMulticast();
    Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = /* @__PURE__ */ requireObserveOn();
    Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = /* @__PURE__ */ requireOnErrorResumeNextWith();
    Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNext;
    } });
    var pairwise_1 = /* @__PURE__ */ requirePairwise();
    Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var partition_1 = /* @__PURE__ */ requirePartition();
    Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var pluck_1 = /* @__PURE__ */ requirePluck();
    Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = /* @__PURE__ */ requirePublish();
    Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = /* @__PURE__ */ requirePublishBehavior();
    Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = /* @__PURE__ */ requirePublishLast();
    Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = /* @__PURE__ */ requirePublishReplay();
    Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var race_1 = /* @__PURE__ */ requireRace();
    Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var raceWith_1 = /* @__PURE__ */ requireRaceWith();
    Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = /* @__PURE__ */ requireReduce();
    Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = /* @__PURE__ */ requireRepeat();
    Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = /* @__PURE__ */ requireRepeatWhen();
    Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = /* @__PURE__ */ requireRetry();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = /* @__PURE__ */ requireRetryWhen();
    Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = /* @__PURE__ */ requireRefCount();
    Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = /* @__PURE__ */ requireSample();
    Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = /* @__PURE__ */ requireSampleTime();
    Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = /* @__PURE__ */ requireScan();
    Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = /* @__PURE__ */ requireSequenceEqual();
    Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = /* @__PURE__ */ requireShare();
    Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = /* @__PURE__ */ requireShareReplay();
    Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = /* @__PURE__ */ requireSingle();
    Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = /* @__PURE__ */ requireSkip();
    Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = /* @__PURE__ */ requireSkipLast();
    Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = /* @__PURE__ */ requireSkipUntil();
    Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = /* @__PURE__ */ requireSkipWhile();
    Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = /* @__PURE__ */ requireStartWith();
    Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = /* @__PURE__ */ requireSubscribeOn();
    Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = /* @__PURE__ */ requireSwitchAll();
    Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = /* @__PURE__ */ requireSwitchMap();
    Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = /* @__PURE__ */ requireSwitchMapTo();
    Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = /* @__PURE__ */ requireSwitchScan();
    Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = /* @__PURE__ */ requireTake();
    Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = /* @__PURE__ */ requireTakeLast();
    Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = /* @__PURE__ */ requireTakeUntil();
    Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = /* @__PURE__ */ requireTakeWhile();
    Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = /* @__PURE__ */ requireTap();
    Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = /* @__PURE__ */ requireThrottle();
    Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = /* @__PURE__ */ requireThrottleTime();
    Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = /* @__PURE__ */ requireThrowIfEmpty();
    Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = /* @__PURE__ */ requireTimeInterval();
    Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_1 = /* @__PURE__ */ requireTimeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var timeoutWith_1 = /* @__PURE__ */ requireTimeoutWith();
    Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = /* @__PURE__ */ requireTimestamp();
    Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = /* @__PURE__ */ requireToArray();
    Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = /* @__PURE__ */ requireWindow();
    Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = /* @__PURE__ */ requireWindowCount();
    Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = /* @__PURE__ */ requireWindowTime();
    Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = /* @__PURE__ */ requireWindowToggle();
    Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = /* @__PURE__ */ requireWindowWhen();
    Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = /* @__PURE__ */ requireWithLatestFrom();
    Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zip_1 = /* @__PURE__ */ requireZip();
    Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var zipAll_1 = /* @__PURE__ */ requireZipAll();
    Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = /* @__PURE__ */ requireZipWith();
    Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  })(operators);
  return operators;
}
var waitOn_1;
var hasRequiredWaitOn;
function requireWaitOn() {
  if (hasRequiredWaitOn) return waitOn_1;
  hasRequiredWaitOn = 1;
  const fs = require$$6;
  const { promisify } = require$$1;
  const Joi = requireLib();
  const https = require$$4;
  const net = require$$4$2;
  const util = require$$1;
  const axiosPkg = requireAxios().default;
  const { isBoolean, isEmpty: isEmpty2, negate, noop: noop2, once, partial, pick, zip: zip2 } = requireFp();
  const { NEVER, combineLatest: combineLatest2, from: from2, merge: merge2, throwError: throwError2, timer: timer2 } = /* @__PURE__ */ requireCjs();
  const { distinctUntilChanged: distinctUntilChanged2, map: map2, mergeMap: mergeMap2, scan: scan2, startWith: startWith2, take: take2, takeWhile: takeWhile2 } = /* @__PURE__ */ requireOperators();
  const axios = axiosPkg.create({ adapter: "http" });
  const isNotABoolean = negate(isBoolean);
  const isNotEmpty = negate(isEmpty2);
  const fstat = promisify(fs.stat);
  const PREFIX_RE = /^((https?-get|https?|tcp|socket|file):)(.+)$/;
  const HOST_PORT_RE = /^(([^:]*):)?(\d+)$/;
  const HTTP_GET_RE = /^https?-get:/;
  const HTTP_UNIX_RE = /^http:\/\/unix:([^:]+):(.+)$/;
  const TIMEOUT_ERR_MSG = "Timed out waiting for";
  const WAIT_ON_SCHEMA = Joi.object({
    resources: Joi.array().items(Joi.string().required()).required(),
    delay: Joi.number().integer().min(0).default(0),
    httpTimeout: Joi.number().integer().min(0),
    interval: Joi.number().integer().min(0).default(250),
    log: Joi.boolean().default(false),
    reverse: Joi.boolean().default(false),
    simultaneous: Joi.number().integer().min(1).default(Infinity),
    timeout: Joi.number().integer().min(0).default(Infinity),
    validateStatus: Joi.function(),
    verbose: Joi.boolean().default(false),
    window: Joi.number().integer().min(0).default(750),
    tcpTimeout: Joi.number().integer().min(0).default(300),
    // http/https options
    ca: [Joi.string(), Joi.binary()],
    cert: [Joi.string(), Joi.binary()],
    key: [Joi.string(), Joi.binary(), Joi.object()],
    passphrase: Joi.string(),
    proxy: [Joi.boolean(), Joi.object()],
    auth: Joi.object({
      username: Joi.string(),
      password: Joi.string()
    }),
    strictSSL: Joi.boolean().default(false),
    followRedirect: Joi.boolean().default(true),
    // HTTP 3XX responses
    headers: Joi.object()
  });
  function waitOn2(opts, cb) {
    if (cb !== void 0) {
      return waitOnImpl(opts, cb);
    } else {
      return new Promise(function(resolve, reject) {
        waitOnImpl(opts, function(err) {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
  }
  function waitOnImpl(opts, cbFunc) {
    const cbOnce = once(cbFunc);
    const validResult = WAIT_ON_SCHEMA.validate(opts);
    if (validResult.error) {
      return cbOnce(validResult.error);
    }
    const validatedOpts = {
      ...validResult.value,
      // use defaults
      // window needs to be at least interval
      ...validResult.value.window < validResult.value.interval ? { window: validResult.value.interval } : {},
      ...validResult.value.verbose ? { log: true } : {}
      // if debug logging then normal log is also enabled
    };
    const { resources, log: shouldLog, timeout: timeout2, verbose, reverse } = validatedOpts;
    const output = verbose ? console.log.bind() : noop2;
    const log = shouldLog ? console.log.bind() : noop2;
    const logWaitingForWDeps = partial(logWaitingFor, [{ log, resources }]);
    const createResourceWithDeps$ = partial(createResource$, [{ validatedOpts, output, log }]);
    let lastResourcesState = resources;
    const timeoutError$ = timeout2 !== Infinity ? timer2(timeout2).pipe(
      mergeMap2(() => {
        const resourcesWaitingFor = determineRemainingResources(resources, lastResourcesState).join(", ");
        return throwError2(Error(`${TIMEOUT_ERR_MSG}: ${resourcesWaitingFor}`));
      })
    ) : NEVER;
    function cleanup(err) {
      if (err) {
        if (err.message.startsWith(TIMEOUT_ERR_MSG)) {
          log("wait-on(%s) %s; exiting with error", process.pid, err.message);
        } else {
          log("wait-on(%s) exiting with error", process.pid, err);
        }
      } else {
        log("wait-on(%s) complete", process.pid);
      }
      cbOnce(err);
    }
    if (reverse) {
      log("wait-on reverse mode - waiting for resources to be unavailable");
    }
    logWaitingForWDeps(resources);
    const resourcesCompleted$ = combineLatest2(resources.map(createResourceWithDeps$));
    merge2(timeoutError$, resourcesCompleted$).pipe(takeWhile2((resourceStates) => resourceStates.some((x) => !x))).subscribe({
      next: (resourceStates) => {
        lastResourcesState = resourceStates;
        logWaitingForWDeps(resourceStates);
      },
      error: cleanup,
      complete: cleanup
    });
  }
  function logWaitingFor({ log, resources }, resourceStates) {
    const remainingResources = determineRemainingResources(resources, resourceStates);
    if (isNotEmpty(remainingResources)) {
      log(`waiting for ${remainingResources.length} resources: ${remainingResources.join(", ")}`);
    }
  }
  function determineRemainingResources(resources, resourceStates) {
    const resourceAndStateTuples = zip2(resources, resourceStates);
    return resourceAndStateTuples.filter(([
      ,
      /* r */
      s
    ]) => !s).map(([
      r
      /*, s */
    ]) => r);
  }
  function createResource$(deps, resource) {
    const prefix = extractPrefix(resource);
    switch (prefix) {
      case "https-get:":
      case "http-get:":
      case "https:":
      case "http:":
        return createHTTP$(deps, resource);
      case "tcp:":
        return createTCP$(deps, resource);
      case "socket:":
        return createSocket$(deps, resource);
      default:
        return createFileResource$(deps, resource);
    }
  }
  function createFileResource$({ validatedOpts: { delay: delay2, interval: interval2, reverse, simultaneous, window: stabilityWindow }, output }, resource) {
    const filePath = extractPath(resource);
    const checkOperator = reverse ? map2((size) => size === -1) : scan2(
      // check that file exists and the size is stable
      (acc, x) => {
        if (x > -1) {
          const { size, t } = acc;
          const now = Date.now();
          if (size !== -1 && x === size) {
            if (now >= t + stabilityWindow) {
              output(`  file stabilized at size:${size} file:${filePath}`);
              return true;
            }
            output(`  file exists, checking for size change during stability window, size:${size} file:${filePath}`);
            return acc;
          }
          output(`  file exists, checking for size changes, size:${x} file:${filePath}`);
          return { size: x, t: now };
        }
        return acc;
      },
      { size: -1, t: Date.now() }
    );
    return timer2(delay2, interval2).pipe(
      mergeMap2(() => {
        output(`checking file stat for file:${filePath} ...`);
        return from2(getFileSize(filePath));
      }, simultaneous),
      checkOperator,
      map2((x) => isNotABoolean(x) ? false : x),
      startWith2(false),
      distinctUntilChanged2(),
      take2(2)
    );
  }
  function extractPath(resource) {
    const m = PREFIX_RE.exec(resource);
    if (m) {
      return m[3];
    }
    return resource;
  }
  function extractPrefix(resource) {
    const m = PREFIX_RE.exec(resource);
    if (m) {
      return m[1];
    }
    return "";
  }
  async function getFileSize(filePath) {
    try {
      const { size } = await fstat(filePath);
      return size;
    } catch {
      return -1;
    }
  }
  function createHTTP$({ validatedOpts, output }, resource) {
    const {
      delay: delay2,
      followRedirect,
      httpTimeout: timeout2,
      interval: interval2,
      proxy,
      reverse,
      simultaneous,
      strictSSL: rejectUnauthorized
    } = validatedOpts;
    const method = HTTP_GET_RE.test(resource) ? "get" : "head";
    const url = resource.replace("-get:", ":");
    const matchHttpUnixSocket = HTTP_UNIX_RE.exec(url);
    const urlSocketOptions = matchHttpUnixSocket ? { socketPath: matchHttpUnixSocket[1], url: matchHttpUnixSocket[2] } : { url };
    const socketPathDesc = urlSocketOptions.socketPath ? `socketPath:${urlSocketOptions.socketPath}` : "";
    const httpOptions = {
      ...pick(["auth", "headers", "validateStatus"], validatedOpts),
      httpsAgent: new https.Agent({
        rejectUnauthorized,
        ...pick(["ca", "cert", "key", "passphrase"], validatedOpts)
      }),
      ...followRedirect ? {} : { maxRedirects: 0 },
      // defaults to 5 (enabled)
      proxy,
      // can be undefined, false, or object
      ...timeout2 && { timeout: timeout2 },
      ...urlSocketOptions,
      method
      // by default it provides full response object
      // validStatus is 2xx unless followRedirect is true (default)
    };
    const checkFn = reverse ? negateAsync(httpCallSucceeds) : httpCallSucceeds;
    return timer2(delay2, interval2).pipe(
      mergeMap2(() => {
        output(`making HTTP(S) ${method} request to ${socketPathDesc} url:${urlSocketOptions.url} ...`);
        return from2(checkFn(output, httpOptions));
      }, simultaneous),
      startWith2(false),
      distinctUntilChanged2(),
      take2(2)
    );
  }
  async function httpCallSucceeds(output, httpOptions) {
    try {
      const result = await axios(httpOptions);
      output(
        `  HTTP(S) result for ${httpOptions.url}: ${util.inspect(
          pick(["status", "statusText", "headers", "data"], result)
        )}`
      );
      return true;
    } catch (err) {
      output(`  HTTP(S) error for ${httpOptions.url} ${err.toString()}`);
      return false;
    }
  }
  function createTCP$({ validatedOpts: { delay: delay2, interval: interval2, tcpTimeout, reverse, simultaneous }, output }, resource) {
    const tcpPath = extractPath(resource);
    const checkFn = reverse ? negateAsync(tcpExists) : tcpExists;
    return timer2(delay2, interval2).pipe(
      mergeMap2(() => {
        output(`making TCP connection to ${tcpPath} ...`);
        return from2(checkFn(output, tcpPath, tcpTimeout));
      }, simultaneous),
      startWith2(false),
      distinctUntilChanged2(),
      take2(2)
    );
  }
  async function tcpExists(output, tcpPath, tcpTimeout) {
    const [
      ,
      ,
      /* full, hostWithColon */
      hostMatched,
      port
    ] = HOST_PORT_RE.exec(tcpPath);
    const host = hostMatched || "localhost";
    return new Promise((resolve) => {
      const conn = net.connect(port, host).on("error", (err) => {
        output(`  error connecting to TCP host:${host} port:${port} ${err.toString()}`);
        resolve(false);
      }).on("timeout", () => {
        output(`  timed out connecting to TCP host:${host} port:${port} tcpTimeout:${tcpTimeout}ms`);
        conn.end();
        resolve(false);
      }).on("connect", () => {
        output(`  TCP connection successful to host:${host} port:${port}`);
        conn.end();
        resolve(true);
      });
      conn.setTimeout(tcpTimeout);
    });
  }
  function createSocket$({ validatedOpts: { delay: delay2, interval: interval2, reverse, simultaneous }, output }, resource) {
    const socketPath = extractPath(resource);
    const checkFn = reverse ? negateAsync(socketExists) : socketExists;
    return timer2(delay2, interval2).pipe(
      mergeMap2(() => {
        output(`making socket connection to ${socketPath} ...`);
        return from2(checkFn(output, socketPath));
      }, simultaneous),
      startWith2(false),
      distinctUntilChanged2(),
      take2(2)
    );
  }
  async function socketExists(output, socketPath) {
    return new Promise((resolve) => {
      const conn = net.connect(socketPath).on("error", (err) => {
        output(`  error connecting to socket socket:${socketPath} ${err.toString()}`);
        resolve(false);
      }).on("connect", () => {
        output(`  connected to socket:${socketPath}`);
        conn.end();
        resolve(true);
      });
    });
  }
  function negateAsync(asyncFn) {
    return async function(...args2) {
      return !await asyncFn(...args2);
    };
  }
  waitOn_1 = waitOn2;
  return waitOn_1;
}
var waitOnExports = requireWaitOn();
const waitOn = /* @__PURE__ */ getDefaultExportFromCjs(waitOnExports);
const waitOn$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: waitOn
}, [waitOnExports]);
exports.waitOn = waitOn$1;
